<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Analysis of Frames in World of Warcraft | Andy Dote</title><meta name=keywords content><meta name=description content="In this post we will be looking at how the Frame and associated objects are (probably) constructed behind the scenes. This will all be done via inspection in lua from the games scripting engine.
The basic display item in Warcraft is the Frame. Frames are not only use for displaying data, but used to listen to events in the background. Another interesting characteristic of a Frame is that you cannot destroy them."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2013/11/17/analasys-of-frames-in-world-of-warcraft/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Analysis of Frames in World of Warcraft"><meta property="og:description" content="In this post we will be looking at how the Frame and associated objects are (probably) constructed behind the scenes. This will all be done via inspection in lua from the games scripting engine.
The basic display item in Warcraft is the Frame. Frames are not only use for displaying data, but used to listen to events in the background. Another interesting characteristic of a Frame is that you cannot destroy them."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2013/11/17/analasys-of-frames-in-world-of-warcraft/"><meta property="article:section" content="post"><meta property="article:published_time" content="2013-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2013-11-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Analysis of Frames in World of Warcraft"><meta name=twitter:description content="In this post we will be looking at how the Frame and associated objects are (probably) constructed behind the scenes. This will all be done via inspection in lua from the games scripting engine.
The basic display item in Warcraft is the Frame. Frames are not only use for displaying data, but used to listen to events in the background. Another interesting characteristic of a Frame is that you cannot destroy them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Analysis of Frames in World of Warcraft","item":"https://andydote.co.uk/2013/11/17/analasys-of-frames-in-world-of-warcraft/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Analysis of Frames in World of Warcraft","name":"Analysis of Frames in World of Warcraft","description":"In this post we will be looking at how the Frame and associated objects are (probably) constructed behind the scenes. This will all be done via inspection in lua from the games scripting engine.\nThe basic display item in Warcraft is the Frame. Frames are not only use for displaying data, but used to listen to events in the background. Another interesting characteristic of a Frame is that you cannot destroy them.","keywords":[],"articleBody":"In this post we will be looking at how the Frame and associated objects are (probably) constructed behind the scenes. This will all be done via inspection in lua from the games scripting engine.\nThe basic display item in Warcraft is the Frame. Frames are not only use for displaying data, but used to listen to events in the background. Another interesting characteristic of a Frame is that you cannot destroy them. Once they are created, Frames exist for the lifetime of the UI (until the player logs out, or reloads their UI.)\nFirst Question A lot of frames are created in the lifetime of the Warcraft UI, so they should be reasonably light weight. It seems unlikely that all methods are defined on a frame directly, as this would increase a blank/empty frames memory footprint considerably.\nBecause of this, it would be reasonable to expect that all methods are defined on a metatable, and that a frame created by CreateFrame is just a blank table with a metatable containing all the methods. A simple implementation of CreateFrame could be:\nfunction CreateFrame(type, name, parent, inherits) local widget = {} local meta = _metas[type] setmetatable(widget, { __index = meta }) widget:SetName(name) widget:SetParent(parent) --something to handle templates... return widget end The following function will display all of the methods found on the Frame’s metatable:\nCode: local frame = CreateFrame(\"Frame\") local meta = getmetatable(frame) print(\"meta\", meta) print(\"index\", meta.__index) for name, value in pairs(meta.__index) do print(name, value) end Output: meta table: 000000000D42E610 index table: 000000000D42E660 IsMovable function: 000000000D07F140 SetAlpha function: 000000000D07E800 SetScript function: 000000000D07E0C0 ... Interestingly, if you run this script after reloading your UI, the hash of the meta is the same every time.\nThe next point to investigate is how other frame types are built up. As widgets have a hierarchical structure (see the Widget Hierarchy at wowprogramming.com), it might be the case that the FrameMeta has a metatable of the methods which represent VisibleRegion, Region or ScriptObject. The Widget Hierarchy hints that it won’t be a metatable chain, as some widgets inherit multiple other types (e.g. Frame inherits VisibleRegion and ScriptObject). The following function will recurse metatables, and verify if a Frame and a Button share any metatables:\nCode: local function printTable(t) local meta = getmetatable(t) if not meta then return end if not meta.__index then return end local index = meta.__index print(\"meta:\", meta, \"meta.index:\" index) printTable(meta) end print(\"Frame:\") printTable(CreateFrame(\"Frame\")) print(\"Button:\") printTable(CreateFrame(\"Button\")) Output: Frame: meta: table: 000000000C8F8B40 meta.index: table: 000000000C8F8B90 Button: meta: table: 000000000C8F8BE0 meta.index: table: 000000000C8F8C30 The output of this indicates that each Widget type has it’s own metatable, which helps give a starting point to implementing a new version.\nImplementing The WowInterfakes project needs to be able to create all Widgets, so using a similar method as the Warcraft implementation made sense. As there is no inheritance between Widgets, using a Mixin style for building metatables makes most sense. The result of building the metatables is stored, and only done once on start up.\nlocal builder = {} builder.init = function() builder.metas = {} local frameMeta = {} builder.applyUIObject(frameMeta) builder.applyParentedObject(frameMeta) builder.applyRegion(frameMeta) builder.applyVisibleRegion(frameMeta) builder.applyScriptObject(frameMeta) builder.applyFrame(frameMeta) builder.metas.frame = { __index = frameMeta } end Each apply method mixes in the functionality for their type. applyRegion gets reused for a Texture as well as a Frame for example.\nInternally, all mixed in methods write and read to a table on the self parameter (called __storage), which holds each widgets values:\nbuilder.applyFrame = function(region) region.SetBackdrop = function(self, backdrop) self.__storage.backdrop = backdrop end region.RegisterEvent = function(self, event) eventRegistry.register(self, event) end region.CreateTexture = function(self, name, layer, inherits, sublevel) return builder.createTexture(self, name, layer, inherits, sublevel) end end When createFrame is called, we create a new table with a table in __storage, and apply the standard frame metatable to it. At this point, the new table is a working Frame, which takes up very little in the way of resources (two tables worth of memory). Initialisation is finished by populating a few properties (some things like frame name are not publicly accessible, so they are written to the backing __storage directly), and apply any templates specified.\nbuilder.createFrame = function(type, name, parent, template) local frame = { __storage = {} } setmetatable(frame, builder.metas.frame) frame.__storage.name = name --no publicly accessable SetName method() frame:SetParent(parent) if template and template ~= \"\" then templateManager.apply(template, frame) end return frame end Conclusion It seems likely that the CreateFrame method in Warcraft is defined in C, rather than in lua somewhere, so where a widget stores it’s data internally is unknown. However for the purpose of re-implementing CreateFrame, we can use a table on each widget. Another option would have been a single table keyed by the returned widget, and store all the data centrally rather than on the individual frames.\n","wordCount":"786","inLanguage":"en","datePublished":"2013-11-17T00:00:00Z","dateModified":"2013-11-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2013/11/17/analasys-of-frames-in-world-of-warcraft/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Analysis of Frames in World of Warcraft</h1><div class=post-meta><span title='2013-11-17 00:00:00 +0000 UTC'>November 17, 2013</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>In this post we will be looking at how the <code>Frame</code> and associated objects are (probably) constructed behind the scenes. This will all be done via inspection in lua from the games scripting engine.</p><p>The basic display item in Warcraft is the <code>Frame</code>. Frames are not only use for displaying data, but used to listen to events in the background. Another interesting characteristic of a <code>Frame</code> is that you cannot destroy them. Once they are created, Frames exist for the lifetime of the UI (until the player logs out, or reloads their UI.)</p><h2 id=first-question>First Question<a hidden class=anchor aria-hidden=true href=#first-question>#</a></h2><p>A lot of frames are created in the lifetime of the Warcraft UI, so they should be reasonably light weight. It seems unlikely that all methods are defined on a frame directly, as this would increase a blank/empty frames memory footprint considerably.</p><p>Because of this, it would be reasonable to expect that all methods are defined on a metatable, and that a frame created by <code>CreateFrame</code> is just a blank table with a metatable containing all the methods. A simple implementation of <code>CreateFrame</code> could be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>CreateFrame</span>(type, name, parent, inherits)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>local</span> widget <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>local</span> meta <span style=color:#f92672>=</span> _metas[type]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	setmetatable(widget, { __index <span style=color:#f92672>=</span> meta })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	widget:SetName(name)
</span></span><span style=display:flex><span>	widget:SetParent(parent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>--something to handle templates...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> widget
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>The following function will display all of the methods found on the Frame&rsquo;s metatable:</p><h3 id=code>Code:<a hidden class=anchor aria-hidden=true href=#code>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> frame <span style=color:#f92672>=</span> CreateFrame(<span style=color:#e6db74>&#34;Frame&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> meta <span style=color:#f92672>=</span> getmetatable(frame)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;meta&#34;</span>, meta)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;index&#34;</span>, meta.__index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> name, value <span style=color:#66d9ef>in</span> pairs(meta.__index) <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>	print(name, value)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h3 id=output>Output:<a hidden class=anchor aria-hidden=true href=#output>#</a></h3><pre><code>meta table: 000000000D42E610
index table: 000000000D42E660
IsMovable function: 000000000D07F140
SetAlpha function: 000000000D07E800
SetScript function: 000000000D07E0C0
...
</code></pre><p>Interestingly, if you run this script after reloading your UI, the hash of the meta is the same every time.</p><p>The next point to investigate is how other frame types are built up. As widgets have a hierarchical structure (see the <a href=http://wowprogramming.com/docs/widgets_hierarchy>Widget Hierarchy</a> at wowprogramming.com), it might be the case that the <code>FrameMeta</code> has a metatable of the methods which represent <code>VisibleRegion</code>, <code>Region</code> or <code>ScriptObject</code>. The Widget Hierarchy hints that it won&rsquo;t be a metatable chain, as some widgets inherit multiple other types (e.g. <code>Frame</code> inherits <code>VisibleRegion</code> and <code>ScriptObject</code>). The following function will recurse metatables, and verify if a <code>Frame</code> and a <code>Button</code> share any metatables:</p><h3 id=code-1>Code:<a hidden class=anchor aria-hidden=true href=#code-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>printTable</span>(t)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>local</span> meta <span style=color:#f92672>=</span> getmetatable(t)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> meta <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> meta.__index <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>local</span> index <span style=color:#f92672>=</span> meta.__index
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>&#34;meta:&#34;</span>, meta, <span style=color:#e6db74>&#34;meta.index:&#34;</span> index)
</span></span><span style=display:flex><span>	printTable(meta)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Frame:&#34;</span>)
</span></span><span style=display:flex><span>printTable(CreateFrame(<span style=color:#e6db74>&#34;Frame&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Button:&#34;</span>)
</span></span><span style=display:flex><span>printTable(CreateFrame(<span style=color:#e6db74>&#34;Button&#34;</span>))
</span></span></code></pre></div><h3 id=output-1>Output:<a hidden class=anchor aria-hidden=true href=#output-1>#</a></h3><pre><code>Frame:
meta: table: 000000000C8F8B40 meta.index: table: 000000000C8F8B90
Button:
meta: table: 000000000C8F8BE0 meta.index: table: 000000000C8F8C30
</code></pre><p>The output of this indicates that each Widget type has it&rsquo;s own metatable, which helps give a starting point to implementing a new version.</p><h2 id=implementing>Implementing<a hidden class=anchor aria-hidden=true href=#implementing>#</a></h2><p>The <a href=https://github.com/Pondidum/WowInterfakes>WowInterfakes</a> project needs to be able to create all Widgets, so using a similar method as the Warcraft implementation made sense. As there is no inheritance between Widgets, using a Mixin style for building metatables makes most sense. The result of building the metatables is stored, and only done once on start up.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> builder <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>builder.init <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	builder.metas <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>local</span> frameMeta <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	builder.applyUIObject(frameMeta)
</span></span><span style=display:flex><span>	builder.applyParentedObject(frameMeta)
</span></span><span style=display:flex><span>	builder.applyRegion(frameMeta)
</span></span><span style=display:flex><span>	builder.applyVisibleRegion(frameMeta)
</span></span><span style=display:flex><span>	builder.applyScriptObject(frameMeta)
</span></span><span style=display:flex><span>	builder.applyFrame(frameMeta)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	builder.metas.frame <span style=color:#f92672>=</span> { __index <span style=color:#f92672>=</span> frameMeta }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>Each <code>apply</code> method mixes in the functionality for their type. <code>applyRegion</code> gets reused for a <code>Texture</code> as well as a <code>Frame</code> for example.</p><p>Internally, all mixed in methods write and read to a table on the <code>self</code> parameter (called <code>__storage</code>), which holds each widgets values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>builder.applyFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(region)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	region.SetBackdrop <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, backdrop)
</span></span><span style=display:flex><span>		self.__storage.backdrop <span style=color:#f92672>=</span> backdrop
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	region.RegisterEvent <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, event)
</span></span><span style=display:flex><span>		eventRegistry.register(self, event)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	region.CreateTexture <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, name, layer, inherits, sublevel)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> builder.createTexture(self, name, layer, inherits, sublevel)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>When <code>createFrame</code> is called, we create a new table with a table in <code>__storage</code>, and apply the standard frame metatable to it. At this point, the new table is a working <code>Frame</code>, which takes up very little in the way of resources (two tables worth of memory). Initialisation is finished by populating a few properties (some things like frame name are not publicly accessible, so they are written to the backing <code>__storage</code> directly), and apply any templates specified.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>builder.createFrame <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(type, name, parent, template)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>local</span> frame <span style=color:#f92672>=</span> { __storage <span style=color:#f92672>=</span> {} }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	setmetatable(frame, builder.metas.frame)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	frame.__storage.name <span style=color:#f92672>=</span> name  <span style=color:#75715e>--no publicly accessable SetName method()</span>
</span></span><span style=display:flex><span>	frame:SetParent(parent)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> template <span style=color:#f92672>and</span> template <span style=color:#f92672>~=</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>		templateManager.apply(template, frame)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> frame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>It seems likely that the <code>CreateFrame</code> method in Warcraft is defined in C, rather than in lua somewhere, so where a widget stores it&rsquo;s data internally is unknown. However for the purpose of re-implementing CreateFrame, we can use a table on each widget. Another option would have been a single table keyed by the returned widget, and store all the data centrally rather than on the individual frames.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/02/02/specialising-a-general-application/><span class=title>« Prev Page</span><br><span>Specialising a General Application</span></a>
<a class=next href=https://andydote.co.uk/2013/08/26/creating-a-fubumvc-website/><span class=title>Next Page »</span><br><span>Creating a FubuMvc website</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>