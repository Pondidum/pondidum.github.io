<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>separation on Andy Dote</title><link>https://andydote.co.uk/tags/separation/</link><description>Recent content in separation on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 19 May 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/separation/rss.xml" rel="self" type="application/rss+xml"/><item><title>Using StructureMap Registries for better separation</title><link>https://andydote.co.uk/2014/05/19/using-structuremap-registries/</link><pubDate>Mon, 19 May 2014 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2014/05/19/using-structuremap-registries/</guid><description>When it comes to configuring StructureMap, it supports the use of Registries. Registries support everything that the standard configure method does(new Container(c =&amp;gt; { /* */});).
There are two main reasons that I use the registries rather then doing all my configuration in the Container&amp;rsquo;s lambda: separation of concerns (one registry per area of code) and easier testing (which we will go into shortly).
The only down side I can see to using registries is that it can scatter your configuration across your codebase - but if you have ReSharper, doing a &amp;lsquo;Find Implementations&amp;rsquo; on Registry will find them all for you, so it really isn&amp;rsquo;t much of a down side.</description><content:encoded><![CDATA[<p>When it comes to configuring StructureMap, it supports the use of <a href="http://fubuworld.com/structuremap/registration/registry-dsl/">Registries</a>.  Registries support everything that the standard configure method does(<code>new Container(c =&gt; { /* */});</code>).</p>
<p>There are two main reasons that I use the registries rather then doing all my configuration in the Container&rsquo;s lambda:  separation of concerns (one registry per area of code) and easier testing (which we will go into shortly).</p>
<p>The only down side I can see to using registries is that it can scatter your configuration across your codebase - but if you have ReSharper, doing a &lsquo;Find Implementations&rsquo; on <code>Registry</code> will find them all for you, so it really isn&rsquo;t much of a down side.</p>
<h2 id="separation-of-concerns">Separation of Concerns</h2>
<p>Taking <a href="https://github.com/Pondidum/NuCache">NuCache</a> as an example, in our app start we have <a href="https://github.com/Pondidum/NuCache/blob/master/NuCache/App_Start/ConfigureContainer.cs">ConfigureContainer.cs</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Register(HttpConfiguration config)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> container = <span style="color:#66d9ef">new</span> Container(c =&gt; c.Scan(a =&gt;
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		a.TheCallingAssembly();
</span></span><span style="display:flex;"><span>		a.WithDefaultConventions();
</span></span><span style="display:flex;"><span>		a.LookForRegistries();
</span></span><span style="display:flex;"><span>	}));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	config.DependencyResolver = <span style="color:#66d9ef">new</span> StructureMapDependencyResolver(container);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This snippet of code gets called as part of the AppStart, and tells StructureMap to use the default conventions (eg: <code>IFileSystem =&gt; FileSystem</code>), and to process any registries it finds.  The app then has multiple Registries with the actual configuration in (usually one per namespace, although not all namespaces have a registry).</p>
<p>For example, we have these two registries:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InfrastructureRegistry</span> : Registry
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> InfrastructureRegistry()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		For&lt;IPackageCache&gt;()
</span></span><span style="display:flex;"><span>			.Use&lt;FileSystemPackageCache&gt;()
</span></span><span style="display:flex;"><span>			.OnCreation(c =&gt; c.Initialise())
</span></span><span style="display:flex;"><span>			.Singleton();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ProxyBehaviourRegistry</span> : Registry
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> ProxyBehaviourRegistry ()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Scan(a =&gt;
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			a.TheCallingAssembly();
</span></span><span style="display:flex;"><span>			a.AddAllTypesOf&lt;IProxyBehaviour&gt;();
</span></span><span style="display:flex;"><span>		});
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <a href="https://github.com/Pondidum/NuCache/blob/master/NuCache/Infrastructure/InfrastructureRegistry.cs">InfrastructureRegistry</a> just specifies how to resolve an <code>IPackageCache</code>, as it has requires some extra initialisation and to be treated as a singleton.</p>
<p>The <a href="https://github.com/Pondidum/NuCache/blob/master/NuCache/ProxyBehaviour/ProxyBehaviourRegistry.cs">ProxyBehaviourRegistry</a> tells StructureMap to add all implementations of <code>IProxyBehaviour</code>, so that when we construct as <code>ProxyBehaviourSet</code>, which has a constructor parameter of <code>IEnumerable&lt;IProxyBehaviour&gt;</code> all the implementations are passed in for us.</p>
<h2 id="easier-testing">Easier Testing</h2>
<p>We can use the Registry feature of StructureMap to allow us to test parts of code as they would be in production.  This mostly applies to acceptance style testing, for example when I am testing the XmlRewriter, I want it to behave exactly as it would in production, with the same <code>IXElementTransform</code>s passed in.</p>
<p>To do this, we can use the <code>RewriterRegistry</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> container = <span style="color:#66d9ef">new</span> Container(<span style="color:#66d9ef">new</span> RewriterRegistry());
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rewriter = container.GetInstance&lt;XmlRewriter&gt;();
</span></span></code></pre></div><p>Here we create a new container with the <code>RewriterRegistry</code> passed directly into the constructor.  This gives us access to a container completely configured for using the <code>XmlRewriter</code>.  We can then fake the inputs and outputs to the method under test, keeping the whole system in a known production-like state.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> inputStream = GetType().Assembly.GetManifestResourceStream(<span style="color:#e6db74">&#34;NuCache.Tests.Packages.xml&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> outputStream = <span style="color:#66d9ef">new</span> MemoryStream())
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	rewriter.Rewrite(targetUri, inputStream, outputStream);
</span></span><span style="display:flex;"><span>	outputStream.Position = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_result = XDocument.Load(outputStream);
</span></span><span style="display:flex;"><span>	_namespace = _result.Root.Name.Namespace;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Hopefully this shows how useful and powerful feature StructureMap&rsquo;s Registries are.</p>
]]></content:encoded></item></channel></rss>