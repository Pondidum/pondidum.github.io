<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>ci on Andy Dote</title><link>https://andydote.co.uk/tags/ci/</link><description>Recent content in ci on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Wed, 02 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/ci/rss.xml" rel="self" type="application/rss+xml"/><item><title>Deploy != Release</title><link>https://andydote.co.uk/2022/11/02/deploy-doesnt-mean-release/</link><pubDate>Wed, 02 Nov 2022 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2022/11/02/deploy-doesnt-mean-release/</guid><description>Recently we were having a debate about release processes, and I wrote that deployments are not always equal to releases.
also deploy != release
â€”Andy, baiting discussion in Slack This turned out to be somewhat controversial until we discussed what I specifically meant by deploy and release.
As with all things, agreeing on definitions or understanding what someone means when they use a specific term is essential, so I thought I would write down a short blog post on it.</description></item><item><title>Content based change detection with Make</title><link>https://andydote.co.uk/2022/09/19/make-content-hash/</link><pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2022/09/19/make-content-hash/</guid><description>On several occasions when building complex projects, I have been tempted to set up Bazel to help speed up the build process; after all, it has a lot to offer: only building what has changed, caching built artifacts, and sharing that cache between machines for even more speed.
TLDR We can use Make and a couple of short shell scripts to implement file content-based caching and read/write that cache to remote storage, such as S3.</description></item><item><title>Against SemVer</title><link>https://andydote.co.uk/2018/12/16/against-semver/</link><pubDate>Sun, 16 Dec 2018 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2018/12/16/against-semver/</guid><description>Well, for Applications &amp;amp; Services at least. For libraries, SemVer is the way to go, assuming you can agree on what a breaking change is defined as.
But when it comes to Applications (or SaaS products, websites, etc.) SemVer starts to break down. The problem starts with the most obvious: What is a breaking change? How about a minor change?
What&amp;rsquo;s in a change? For example, if we were to change the UI of a web application, which caused no backend changes, from the user perspective it is probably a breaking change, but not from the developers perspective.</description></item><item><title>Branching and Red Builds</title><link>https://andydote.co.uk/2018/08/10/red-builds/</link><pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2018/08/10/red-builds/</guid><description>So this is a bit of a rant&amp;hellip;but hopefully with some solutions and workarounds too. So let&amp;rsquo;s kick things off with a nice statement:
I hate broken builds.
So everyone basically agrees on this point I think. The problem is that I mean all builds, including ones on shared feature branches.
Currently, I work on a number of projects which uses small(ish) feature branches. The way this works is that the team agrees on a new feature to work on creates a branch, and then each developer works on tasks, committing on their own branches, and Pull-Requesting to the feature branch.</description></item><item><title>CI: Thoughts on CC.Net and Hudson</title><link>https://andydote.co.uk/2009/07/14/ci-thoughts-on-ccnet-and-hudson/</link><pubDate>Tue, 14 Jul 2009 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2009/07/14/ci-thoughts-on-ccnet-and-hudson/</guid><description>I have been a fan of CI (Continuous Integration) for a long time now, and ever since I started with CI I have been using CruiseControl.Net. CCNet is incredibly powerful; you can make to do practically anything, and writing plugins for it is a breeze.
However, I do find that the config files get rather messy. I have tried many things and the current best solution seems to be to have one &amp;lsquo;master&amp;rsquo; config file with a set of includes to other files.</description></item></channel></rss>