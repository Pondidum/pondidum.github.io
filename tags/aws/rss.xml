<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>aws on Andy Dote</title><link>https://andydote.co.uk/tags/aws/</link><description>Recent content in aws on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sun, 17 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/aws/rss.xml" rel="self" type="application/rss+xml"/><item><title>Pulumi Conditional Infrastructure for Speed</title><link>https://andydote.co.uk/2022/07/17/pulumi-faster-processes/</link><pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2022/07/17/pulumi-faster-processes/</guid><description>One of the reasons I prefer Pulumi over Terraform is the additional control I have over my processes due to the fact that it&amp;rsquo;s a programming language.
For example, I have a CLI, that creates a cluster of machines for a user; the machines use IAM Authentication with Vault so that they can request certificates on boot. The trouble with this application is that it is slow; it takes 175 seconds on average to provision the machines, write the IAM information to Vault, and then re-run the cloud-init script on all the machines in the cluster (as when they first booted, the configuration hadn&amp;rsquo;t been written to Vault yet.</description></item><item><title>An NGINX and DNS based outage</title><link>https://andydote.co.uk/2022/04/23/nginx-dns/</link><pubDate>Sat, 23 Apr 2022 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2022/04/23/nginx-dns/</guid><description>I recently encountered a behaviour in Nginx that I didn&amp;rsquo;t expect and caused a production outage in the process. While I would love to blame DNS for this, as it&amp;rsquo;s usually the cause of most network-related issues, in this case, the fault lies with Nginx.
I was running a very simple Nginx proxy, relaying an internal service to the outside world. The internal service is behind an AWS ALB, and the Nginx configuration was proxying to the ALB&amp;rsquo;s FQDN:</description></item><item><title>Observability with Infrastructure as Code</title><link>https://andydote.co.uk/2021/03/01/observability-with-infrastructure-as-code/</link><pubDate>Mon, 01 Mar 2021 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2021/03/01/observability-with-infrastructure-as-code/</guid><description>This article was originally published on the Pulumi blog.
When using the Pulumi Automation API to create applications which can provision infrastructure, it is very handy to be able to use observability techniques to ensure the application functions correctly and to help see where performance bottlenecks are.
One of the applications I work on creates a VPC and Bastion host and then stores the credentials into a Vault instance. The problem is that the “create infrastructure” part is an opaque blob, in that I can see it takes 129 seconds to create, but I can’t see what it’s doing, or why it takes this amount of time.</description></item><item><title>Testing Immutable Infrastructure</title><link>https://andydote.co.uk/2019/01/01/immutable-infra/</link><pubDate>Tue, 01 Jan 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/01/01/immutable-infra/</guid><description>In my previous post, I glossed over one of the most important and useful parts of Immutable Infrastructure: Testability. There are many kinds of tests we can write for our infrastructure, but they should all be focused on the machine/service and maybe it&amp;rsquo;s nearest dependencies, not the entire system.
While this post focuses on testing a full machine (both locally in a VM, and remotely as an Amazon EC2 instance), it is also possible to do most of the same kind of tests against a Docker container.</description></item><item><title>Terraform, Kinesis Streams, Lambda and IAM problems</title><link>https://andydote.co.uk/2017/07/12/terraform-kinesis-lambda-iam/</link><pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/07/12/terraform-kinesis-lambda-iam/</guid><description>I hit an problem the recently with Terraform, when I was trying to hook up a Lambda Trigger to a Kinesis stream. Both the lambda itself, and the stream creation succeeded within Terraform, but the trigger would just stay stuck on &amp;ldquo;creating&amp;hellip;&amp;rdquo; for at least 5 minutes, before I got bored of waiting and killed the process. Several attempts at doing this had the same issue.
The code looked something along the lines of this:</description></item><item><title>S3 Multi-File upload with Terraform</title><link>https://andydote.co.uk/2017/04/23/s3-multi-file-upload-terraform/</link><pubDate>Sun, 23 Apr 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/04/23/s3-multi-file-upload-terraform/</guid><description>Hosting a static website with S3 is really easy, especially from terraform:
First off, we want a public readable S3 bucket policy, but we want to apply this only to one specific bucket. To achive that we can use Terraform&amp;rsquo;s template_file data block to merge in a value:
{ &amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;, &amp;#34;Statement&amp;#34;: [ { &amp;#34;Sid&amp;#34;: &amp;#34;PublicReadGetObject&amp;#34;, &amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;, &amp;#34;Principal&amp;#34;: &amp;#34;*&amp;#34;, &amp;#34;Action&amp;#34;: [ &amp;#34;s3:GetObject&amp;#34; ], &amp;#34;Resource&amp;#34;: [ &amp;#34;arn:aws:s3:::${bucket_name}/*&amp;#34; ] } ] } As you can see the interpolation syntax is pretty much the same as how you use variables in terraform itself.</description></item><item><title>Using Terraform to setup AWS API-Gateway and Lambda</title><link>https://andydote.co.uk/2017/03/17/terraform-aws-lambda-api-gateway/</link><pubDate>Fri, 17 Mar 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/03/17/terraform-aws-lambda-api-gateway/</guid><description>I have been writing simple webhook type applications using Claudiajs, which in behind the scenes is using Aws&amp;rsquo;s Lambda and Api Gateway to make things happen, but I really wanted to understand what exactly it was doing for me, and how I could achieve the same results using Terraform.
The Lambda Function I started off with a simple NodeJS function, in a file called index.js
exports.handler = function(event, context, callback) { callback(null, { statusCode: &amp;#39;200&amp;#39;, body: JSON.</description></item></channel></rss>