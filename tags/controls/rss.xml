<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>controls on Andy Dote</title><link>https://andydote.co.uk/tags/controls/</link><description>Recent content in controls on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 29 Oct 2012 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/controls/rss.xml" rel="self" type="application/rss+xml"/><item><title>Winforms Design Time support: exposing sub designers</title><link>https://andydote.co.uk/2012/10/29/winforms-design-time-support-exposing-sub-designers/</link><pubDate>Mon, 29 Oct 2012 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2012/10/29/winforms-design-time-support-exposing-sub-designers/</guid><description>When writing a UserControl, it is often desired to expose one or more of the sub-controls design-time support to the user of your control. It is reasonably straight forward to do, and here is a rundown of how:
We start off with our UserControl, in this case the imaginatively named TestControl:
The code behind looks like this:
[Designer(typeof(TestControlDesigner))] public partial class TestControl : UserControl { public TestControl() { InitializeComponent(); } [DesignerSerializationVisibility(DesignerSerializationVisibility.</description></item><item><title>Databinding to a DataGridView - The order of columns</title><link>https://andydote.co.uk/2010/10/20/databinding-to-a-datagridview-the-order-of-columns/</link><pubDate>Wed, 20 Oct 2010 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2010/10/20/databinding-to-a-datagridview-the-order-of-columns/</guid><description>A while ago I was writing a small history grid in one of our applications at work. It has a single HistoryItem object, which is fairly straightforward, something like this:
Class HistoryItem { public int ID { get{ return _id; } } public DateTime CreateDate { get { return _createDate; } } public String Creator { get { return _creatorName; } } public String Note { get { return _note; } } } This was populated into a List&amp;lt;HistoryItem&amp;gt; and bound to the DataGridView directly:</description></item><item><title>Microcontrollers for MenuItems</title><link>https://andydote.co.uk/2009/05/29/microcontrollers-for-menuitems/</link><pubDate>Fri, 29 May 2009 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2009/05/29/microcontrollers-for-menuitems/</guid><description>I have been working my way through Jeremy Miller&amp;rsquo;s excellent Build Your Own CAB Series (which would be even better if he felt like finishing!) and was very interested by the article on controlling menus with Microcontrollers.
After reading it and writing a version of it myself, I came to the conclusion that some parts of it seem to be wrong. All of the permissioning is done based on the menu items which fire ICommands, and several menu items could use the same ICommand.</description></item><item><title>Creating Non resizable controls</title><link>https://andydote.co.uk/2008/04/13/creating-non-resizable-controls/</link><pubDate>Sun, 13 Apr 2008 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2008/04/13/creating-non-resizable-controls/</guid><description>A control I was recently developing required being non-resizable when on the form. When the application is running, this would be easy enough, just set its AutoSize property to False, and don&amp;rsquo;t dock the control.
However, this leaves the problem of resizing in the designer. You could override the resize event of the control, but for reasons outlined earlier, such as flickering, I decided against this.
Somewhere on the internet (where else&amp;hellip;?</description></item><item><title>VB.NET &amp;amp; C# Fixed height User Controls</title><link>https://andydote.co.uk/2008/03/29/vbnet-c-fixed-height-user-controls/</link><pubDate>Sat, 29 Mar 2008 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2008/03/29/vbnet-c-fixed-height-user-controls/</guid><description>Another problem I came across recently was fixed height user controls. Someone at work had created a fixed height user control, by putting the following code in the paint event:
Me.Width = 20 Now while for the majority of cases this works, it doesn&amp;rsquo;t if you dock the control to the left or right of the form, as each time the Layout Engine tries to stick the top of the control to the top of the parent and the bottom of the control to the bottom of the parent, it fires the Paint() event.</description></item></channel></rss>