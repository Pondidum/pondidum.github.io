<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>cqrs on Andy Dote</title><link>https://andydote.co.uk/tags/cqrs/</link><description>Recent content in cqrs on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sat, 09 Sep 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/cqrs/rss.xml" rel="self" type="application/rss+xml"/><item><title>Repositories Revisited (and why CQRS is better)</title><link>https://andydote.co.uk/2017/09/09/repositories-revisited/</link><pubDate>Sat, 09 Sep 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/09/09/repositories-revisited/</guid><description>TLDR: I still don&amp;rsquo;t like Repositories!
Recently I had a discussion with a commenter on my The problems with, and solutions to Repositories post, and felt it was worth expanding on how I don&amp;rsquo;t use repositories.
My applications tend to use the mediator pattern to keep things decoupled (using the Mediatr library), and this means that I end up with &amp;ldquo;handler&amp;rdquo; classes which process messages; they load something from storage, call domain methods, and then write it back to storage, possibly returning some or all the data.</description></item><item><title>MediatR and Magic</title><link>https://andydote.co.uk/2017/01/07/mediatr-and-magic/</link><pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/01/07/mediatr-and-magic/</guid><description>Having recently watched Greg Young&amp;rsquo;s excellent talk on 8 Lines of Code I was thinking about how this kind of thinking applies to the mediator pattern, and specifically the MediatR implementation.
I have written about the advantages of CQRS with MediatR before, but having used it for a long time now, there are some parts which cause friction on a regular basis.
The problems Discoverability The biggest issue first. You have a controller with the following constructor:</description></item><item><title>CQS with Mediatr</title><link>https://andydote.co.uk/2016/03/19/cqs-with-mediatr/</link><pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2016/03/19/cqs-with-mediatr/</guid><description>This article is some extra thoughts I had on api structure after reading Derek Comartin.
Asides from the benefits that Derek mentions (no fat repositories, thin controllers), there are a number of other advantages that this style of architecture brings.
Ease of Testing By using Command and Queries, you end up with some very useful seams for writing tests.
For controllers With controllers, you typically use Dependency injection to provide an instance of IMediator:</description></item><item><title>The problems with and solutions to Repositories</title><link>https://andydote.co.uk/2015/03/28/problems-with-and-solutions-to-repositories/</link><pubDate>Sat, 28 Mar 2015 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2015/03/28/problems-with-and-solutions-to-repositories/</guid><description>Repositories are a design pattern which I have never been a huge fan of. I can see the use of them as a good layer boundary, but too often I see them being used all over the place instead of at an infrastructure level in a code base.
A particularly prevalent version of this misuse I see is self populating collections. These generally inherit List&amp;lt;TEntity&amp;gt; or Dictionary&amp;lt;TID, TEntity&amp;gt;, and provide a set of methods such as .</description></item></channel></rss>