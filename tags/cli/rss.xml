<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>cli on Andy Dote</title><link>https://andydote.co.uk/tags/cli/</link><description>Recent content in cli on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 16 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/cli/rss.xml" rel="self" type="application/rss+xml"/><item><title>Feature Flags in a CI Pipeline</title><link>https://andydote.co.uk/2023/01/16/feature-flags-ci/</link><pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2023/01/16/feature-flags-ci/</guid><description>Feature flags are a great tool for helping software development; they provide controlled feature rollouts, facilitate A/B testing, and help decouple deployment from release. So when it comes to building our software, why do we treat the CI pipeline without the same level of engineering as the production code?
So, why not use feature flags in your CI pipeline?
TLDR Reduce the risk of breaking a CI pipeline for all of a project&amp;rsquo;s developers by using the flagon CLI to query Feature Flags, opting developers into and out of new CI features and processes by targeting groups of developers or branch naming patterns.</description><content:encoded><![CDATA[<p>Feature flags are a great tool for helping software development; they provide controlled feature rollouts, facilitate A/B testing, and help decouple <a href="/2022/11/02/deploy-doesnt-mean-release/">deployment from release</a>.  So when it comes to building our software, why do we treat the CI pipeline without the same level of engineering as the production code?</p>
<p>So, why not use feature flags in your CI pipeline?</p>
<h2 id="tldr">TLDR</h2>
<p>Reduce the risk of breaking a CI pipeline for all of a project&rsquo;s developers by using the <a href="https://github.com/pondidum/flagon">flagon</a> CLI to query Feature Flags, opting developers into and out of new CI features and processes by targeting groups of developers or branch naming patterns.</p>
<h2 id="what-would-we-use-them-for">What would we use them for?</h2>
<p>There are a few things that spring to mind that we could use feature flags for:</p>
<ul>
<li>Migrating CI system</li>
<li>Job migration</li>
<li>Replacing a step</li>
<li>Trying a new step</li>
</ul>
<h2 id="why-would-using-flags-for-this-help">Why would using flags for this help?</h2>
<p>The answer is risk reduction.  I don&rsquo;t want to break parts of the build and deployment process for everyone in the project when I make a mistake in the pipelines, and a way to help mitigate that risk is feature flags.</p>
<p>With a feature flag, I can quickly opt people into or out of changes to the CI system, meaning that if something goes wrong, the impact is minimal.  It also allows me to monitor the effects of new vs old by having the flag states stored in our OTEL traces.  This lets me ask and answer questions like: is it faster?  Is it more reliable?  Does it work?</p>
<p>One of the most significant risks is migrating from one CI system to another, which is exactly what I have been doing recently.  We are leaving <code>Truly Awful CI</code> and migrating to <code>Github Actions</code>.  Let&rsquo;s see how that goes.</p>
<h2 id="migrating-from-old-to-new-ci">Migrating From Old to New CI</h2>
<p>The CI process, on a high level, looks like this.  The three types of deployment are <code>ephemeral</code>, which are short-lived environments named after the branch which created them, <code>development</code>, which is the common development environment, and <code>production</code>, which is the live application.  The <code>production</code> and <code>development</code> environments are deployed to whenever something is merged to <code>main</code>, and <code>ephemeral</code> is for any other branch.</p>

<div class="mermaid" align="left">
graph LR

    clone --> build --> test --> publish-container

    publish-container --> |$BRANCH != 'main'| trigger-deploy-ephemeral
    publish-container --> |$BRANCH == 'main'| trigger-deploy-development
    publish-container --> |$BRANCH == 'main'| trigger-deploy-production
</div>
<p>To phase the changeover to GitHub Actions, I am using the <a href="https://github.com/pondidum/flagon">flagon</a> CLI to access our feature flags.  The query uses both the user id (committer email) and branch name so that I can target rollouts based on a group of users or perhaps with a branch name pattern.</p>
<p>First, I create a duplicate workflow in GitHub Actions.  The docker container is published to a different tag, and all deployments have a feature flag condition added to them:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">jobs</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">flags</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">outputs</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">enable_ephemeral</span>: <span style="color:#ae81ff">${{ steps.query.outputs.enable_ephemeral }}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">steps</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Query Flags</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">id</span>: <span style="color:#ae81ff">query</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        ephemeral=$(flagon state &#34;ci-enable-gha-deployment&#34; &#34;false&#34; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          --user &#34;${email}&#34; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          --attr &#34;branch=${branch}&#34; \
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">          --output &#34;template={{.Value}}&#34; || true)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        echo &#34;enable_ephemeral=${ephemeral}&#34; &gt;&gt; &#34;${GITHUB_OUTPUT}&#34;</span>        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># build, test, etc.</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">deploy_ephemeral</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">./.github/workflows/deploy.yaml</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">needs</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">flags</span>
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">build</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">if</span>: <span style="color:#ae81ff">${{ github.ref_name != &#39;master&#39; &amp;&amp; needs.flags.outputs.enable_ephemeral == &#39;true&#39; }}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">target_env</span>: <span style="color:#ae81ff">ephemeral</span>
</span></span></code></pre></div><p>Then update the old CI pipeline to wrap the deployment trigger with a flag query:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ! flagon <span style="color:#e6db74">&#34;ci-enable-gha-deploy&#34;</span> <span style="color:#e6db74">&#34;true&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --user <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>email<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --attr <span style="color:#e6db74">&#34;environment=ephemeral&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --attr <span style="color:#e6db74">&#34;BRANCH=</span><span style="color:#e6db74">${</span>branch<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>; <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  awful-ci trigger <span style="color:#e6db74">&#34;deploy - ephemeral&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --sha <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>commit<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --branch <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>branch<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fi</span>
</span></span></code></pre></div><p>Note that the two CI systems are both querying the same flag, but the old system defaults to active, and the new system defaults to inactive.  This means that if the flagging service (LaunchDarkly in this case) cannot be reached, only one of the systems will be doing the deployment.</p>
<h2 id="rolling-out">Rolling out</h2>
<p>The plan for starting the switchover was as follows:</p>
<ol>
<li><code>ephemeral</code> for just me</li>
<li><code>ephemeral</code> environment for a small group of developers</li>
<li><code>ephemeral</code> for everyone</li>
<li><code>development</code> for everyone</li>
<li><code>production</code> for everyone</li>
<li>WAIT</li>
<li>Remove old implementation, remove flags</li>
</ol>
<p>During the rollout, the flag was switched on and off for various stages as small bugs were found.</p>
<p>For example, I discovered that the deployments only looked like they were working in GitHub Actions due to some artefacts still being uploaded to CDN by the old CI system.</p>
<h2 id="take-away">Take Away</h2>
<p>Based on my experience of using flags in this migration, it is a technique that I will be using more in the future when updating our CI pipelines.</p>
]]></content:encoded></item><item><title>Changelog Driven Versioning</title><link>https://andydote.co.uk/2022/11/22/changelogs/</link><pubDate>Tue, 22 Nov 2022 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2022/11/22/changelogs/</guid><description>Versioning is one of the many hard problems when it comes to writing software. There is no one correct way to do it, and all have various tradeoffs.
After reading keep a changelog, I was inspired to implement this into a couple of CLI tools that I am working on at the moment: Flagon (feature flags on the CLI, for CI usage), and Cas (Content Addressable Storage for Make), but I also wanted to solve my versioning and release process.</description><content:encoded><![CDATA[<p>Versioning is one of the many hard problems when it comes to writing software.  There is no one correct way to do it, and all have various tradeoffs.</p>
<p>After reading <a href="https://keepachangelog.com/en/1.0.0/">keep a changelog</a>, I was inspired to implement this into a couple of CLI tools that I am working on at the moment: <a href="https://github.com/pondidum/flagon">Flagon</a> (feature flags on the CLI, for CI usage), and <a href="https://github.com/pondidum/cas">Cas</a> (Content Addressable Storage for Make), but I also wanted to solve my versioning and release process.</p>
<h2 id="requirements">Requirements</h2>
<ul>
<li>Version number should be defined in only one place</li>
<li>A changelog should be associated with the version number</li>
<li>The binary should be able to print its version and changelog</li>
<li>The release (Github Release in this case) should also have the changelog and version</li>
<li>The commit released should be tagged with the version</li>
</ul>
<p>I came up with an idea: <strong>drive everything from the changelog.</strong></p>
<p>The changelog can be the source of truth: it contains the version number, date of release, and the actual changes within that version.  As the changelog is written in a standardised format it should be fairly easy to parse, and thus be handled by the binary itself.</p>
<h2 id="the-format">The Format</h2>
<p>I decided to follow the format from <a href="https://keepachangelog.com/en/1.0.0/">keep a changelog</a> as it is pretty minimal, in markdown, and easily parsable with a regex.  As an example, here is one of the versions lifted from <a href="https://github.com/Pondidum/Flagon/blob/main/changelog.md">flagon&rsquo;s changelog</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span># Changelog
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">## [0.0.1] - 2022-11-14
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Added
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> Exit with code <span style="color:#e6db74">`0`</span> if a flag is <span style="color:#e6db74">`true`</span>, and <span style="color:#e6db74">`1`</span> otherwise
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> Add <span style="color:#e6db74">`--silent`</span> flag, to suppress console information
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Changed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">-</span> Expand what information is written to traces
</span></span></code></pre></div><p>Each version entry follows the same format, which is parsable by a regex:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">sectionRegex</span> = <span style="color:#a6e22e">regexp</span>.<span style="color:#a6e22e">MustCompile</span>(<span style="color:#e6db74">`## \[(?P&lt;version&gt;.*)\]\s*-\s*(?P&lt;date&gt;.*)`</span>)</span></span></code></pre></div><footer style="margin: 10px auto;">
  <small><a href="https://github.com/Pondidum/flagon/blob/master/version/changelog.go">Source</a></small>
</footer>

<p>The parser itself is very short, and the result is an array of <code>ChangelogEntry</code>, giving the <code>version</code>, <code>date</code>, and text of the changes.</p>
<h2 id="using-the-changelog-from-the-application">Using the changelog from the application</h2>
<p>The changelog is embedded in the binary using the go <code>embed</code> package, and can then be exposed as CLI commands.  The application&rsquo;s <code>version</code> command exposes this information with several flags:</p>
<ul>
<li>
<p>no flags: print the version number and git short sha</p>
</li>
<li>
<p><code>--short</code>: only print the version number</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./flagon version --short
</span></span><span style="display:flex;"><span>0.0.1
</span></span></code></pre></div></li>
<li>
<p><code>--changelog</code>: pretty print the current version&rsquo;s changelog entry</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./flagon version --changelog
</span></span></code></pre></div><p><img loading="lazy" src="flagon-changelog.png" alt="flagon changelog as prettified markdown"  />
</p>
</li>
<li>
<p><code>--raw</code>: causes <code>--changelog</code> to print the markdown as written in the <code>changelog.md</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>./flagon version --changelog
</span></span><span style="display:flex;"><span>0.0.1 - local
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Added</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- Exit with code <span style="color:#e6db74">`</span>0<span style="color:#e6db74">`</span> <span style="color:#66d9ef">if</span> a flag is <span style="color:#e6db74">`</span>true<span style="color:#e6db74">`</span>, and <span style="color:#e6db74">`</span>1<span style="color:#e6db74">`</span> otherwise
</span></span><span style="display:flex;"><span>- Add <span style="color:#e6db74">`</span>--silent<span style="color:#e6db74">`</span> flag, to suppress console information
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">### Changed</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- Expand what information is written to traces
</span></span></code></pre></div></li>
</ul>
<h2 id="using-the-changelog-for-releases">Using the changelog for Releases</h2>
<p>In github actions when building the <code>main</code> branch, I use this to generate a version number, and write the current changelog entry to a temporary file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Generate Release Notes</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">if</span>: <span style="color:#ae81ff">github.ref_name == &#39;main&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">run</span>: |<span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    echo &#34;FLAGON_VERSION=$(./flagon version --short)&#34; &gt;&gt; &#34;${GITHUB_ENV}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    ./flagon version --changelog --raw &gt; release-notes.md</span>    
</span></span></code></pre></div><p>Which are then passed to the <code>action-gh-release</code> step:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>- <span style="color:#f92672">name</span>: <span style="color:#ae81ff">Release</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">if</span>: <span style="color:#ae81ff">github.ref_name == &#39;main&#39;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">uses</span>: <span style="color:#ae81ff">softprops/action-gh-release@v1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">with</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">${{ env.FLAGON_VERSION }}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">tag_name</span>: <span style="color:#ae81ff">${{ env.FLAGON_VERSION }}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">body_path</span>: <span style="color:#ae81ff">release-notes.md</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">files</span>: <span style="color:#ae81ff">flagon</span>
</span></span></code></pre></div><p>Which makes my releases match the version number of the binary, and have the correct release notes.</p>
<h2 id="further-work">Further Work</h2>
<p>This system isn&rsquo;t perfect (yet), but it works well for my projects.  I&rsquo;ve considered extracting it into its own package, but so far with only two applications using it I haven&rsquo;t hit the <a href="https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)">rule of 3 yet</a>.</p>
]]></content:encoded></item><item><title>A single project Windows Service and Console</title><link>https://andydote.co.uk/2015/08/30/single-project-service-and-console/</link><pubDate>Sun, 30 Aug 2015 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2015/08/30/single-project-service-and-console/</guid><description>I have found that when developing MicroServices, I often want to run them from within Visual Studio, or just as a console application, and not have to bother with the hassle of installing as windows services.
In the past I have seen this achieved by creating a Class Library project with all the actual implementation inside it, and then both a Console Application and Windows Service project referencing the library and doing nothing other than calling a .</description><content:encoded><![CDATA[<p>I have found that when developing MicroServices, I often want to run them from within Visual Studio, or just as a console application, and not have to bother with the hassle of installing as windows services.</p>
<p>In the past I have seen this achieved by creating a <code>Class Library</code> project with all the actual implementation inside it, and then both a <code>Console Application</code> and <code>Windows Service</code> project referencing the library and doing nothing other than calling a <code>.Start()</code> method or similar.</p>
<p>While this works, it has always bugged me as there should be a straight forward way of achieving a single exe to do both roles.  It turns out there is an easy way to do it too&hellip;</p>
<h2 id="creating-the-project">Creating the Project</h2>
<p>First, create a <code>WindowsService</code> project in VisualStudio:
<img loading="lazy" src="service-new.png" alt="New Windows Service"  />
</p>
<p>Then open the project properties, and change the project type to <code>Console Application</code> and set the startup object:
<img loading="lazy" src="service-project-type.png" alt="Service Type"  />
</p>
<p>Next, open <code>Service1.cs</code> and add a new method (and rename it to <code>Service</code> if you feel the need!):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> StartConsole()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	Console.WriteLine(<span style="color:#e6db74">&#34;Press any key to exit...&#34;</span>);
</span></span><span style="display:flex;"><span>	OnStart(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">string</span>[] { });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Console.ReadKey();
</span></span><span style="display:flex;"><span>	OnStop();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally  open <code>Program.cs</code> and replace the <code>Main</code> method:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> service = <span style="color:#66d9ef">new</span> Service();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> (Environment.UserInteractive)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		service.StartConsole();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		ServiceBase.Run(<span style="color:#66d9ef">new</span> ServiceBase[] { service });
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="displaying-output">Displaying Output</h2>
<p>Calling <code>Console.Write*</code> and <code>Console.Read*</code> methods when running as a windows service will cause exceptions to be thrown, which suggest that you should redirect the console streams to use them under a windows service.</p>
<p>As a MicroService you shouldn&rsquo;t need to be reading keys from the console (other than the one in our <code>StartConsole</code> method), but writing output would be useful&hellip;</p>
<p>To do this I like to use my logging library of choice (<a href="http://serilog.net/">Serilog</a>), which I have setup to write to files and to a console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> InitializeLogging()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> baseDirectory = AppDomain.CurrentDomain.BaseDirectory;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> logs = Path.Combine(baseDirectory, <span style="color:#e6db74">&#34;logs&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Directory.CreateDirectory(logs);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Log.Logger = <span style="color:#66d9ef">new</span> LoggerConfiguration()
</span></span><span style="display:flex;"><span>		.MinimumLevel.Debug()
</span></span><span style="display:flex;"><span>		.WriteTo.ColoredConsole()
</span></span><span style="display:flex;"><span>		.WriteTo.RollingFile(Path.Combine(logs, <span style="color:#e6db74">&#34;{Date}.log&#34;</span>))
</span></span><span style="display:flex;"><span>		.CreateLogger();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And call this method inside the <code>Service1</code> constructor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> Service()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	InitializeComponent();
</span></span><span style="display:flex;"><span>	InitializeLogging();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="the-edge-case">The Edge Case</h2>
<p>There is one slight edge case which I am aware of, which is that the <code>Environment.UserInteractive </code> property can return true even when running as a windows service if when you install the service you tick <code>Allow service to interact with desktop</code> checkbox:</p>
<p><img loading="lazy" src="service-interact.png" alt="Service-Logon"  />
</p>
<p>My only solution to this is: <strong>Don&rsquo;t tick that box</strong>. I don&rsquo;t think I have ever used that option anyway!</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Using this method means less code and projects to maintain, and a very easy path to go from running a service as a desktop application to service.</p>
]]></content:encoded></item></channel></rss>