<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>solid on Andy Dote</title><link>https://andydote.co.uk/tags/solid/</link><description>Recent content in solid on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sat, 15 Mar 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/solid/rss.xml" rel="self" type="application/rss+xml"/><item><title>SOLID Principles - DIP</title><link>https://andydote.co.uk/2014/03/15/solid-principles-dip/</link><pubDate>Sat, 15 Mar 2014 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2014/03/15/solid-principles-dip/</guid><description>Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Dependency Inversion Principle states that &amp;ldquo;Depend upon Abstractions. Do not depend upon concretions&amp;rdquo;. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don&amp;rsquo;t have to buy new set of devices when you move house, and you don&amp;rsquo;t have to buy a new house for your devices!</description></item><item><title>SOLID Principles - ISP</title><link>https://andydote.co.uk/2014/03/01/solid-principles-isp/</link><pubDate>Sat, 01 Mar 2014 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2014/03/01/solid-principles-isp/</guid><description>Interface Segregation Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
Interface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.
So as usual, lets start off with an set of types which don&amp;rsquo;t adhere to the principle.</description></item><item><title>SOLID Principles - LSP</title><link>https://andydote.co.uk/2014/02/23/solid-principles-lsp/</link><pubDate>Sun, 23 Feb 2014 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2014/02/23/solid-principles-lsp/</guid><description>Liskov Substitution Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Liskov Substitution Principle is states:
If S is a sub-type of T, then objects of type T maybe replaced with objects of type S
At face value, it means that a small class hierarchy like this:
public class FileEntry { } public class DbFileEntry : FileEntry { } And a method which takes in a FileEntry, can be called like this:</description></item><item><title>SOLID Principles - OCP</title><link>https://andydote.co.uk/2014/02/19/solid-principles-ocp/</link><pubDate>Wed, 19 Feb 2014 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2014/02/19/solid-principles-ocp/</guid><description>Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection.</description></item><item><title>SOLID Principles - SRP</title><link>https://andydote.co.uk/2014/02/18/solid-principles-srp/</link><pubDate>Tue, 18 Feb 2014 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2014/02/18/solid-principles-srp/</guid><description>Single Responsibility Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
SRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don&amp;rsquo;t see the use in their particular case.
A particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses.</description></item></channel></rss>