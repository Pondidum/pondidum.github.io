<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>nunit on Andy Dote</title><link>https://andydote.co.uk/tags/nunit/</link><description>Recent content in nunit on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sun, 09 Oct 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/nunit/rss.xml" rel="self" type="application/rss+xml"/><item><title>Shouldly: Why would you assert any other way?</title><link>https://andydote.co.uk/2016/10/09/assertion-style/</link><pubDate>Sun, 09 Oct 2016 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2016/10/09/assertion-style/</guid><description>I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used Shouldly in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit&amp;rsquo;s assertions.
I have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!</description><content:encoded><![CDATA[<p>I like to make my development life as easy as possible - and removing small irritations is a great way of doing this.  Having used <a href="http://docs.shouldly-lib.net/v2.4.0/docs">Shouldly</a> in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit&rsquo;s assertions.</p>
<p>I have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!</p>
<p>The rest of this post goes through the different assertion models, and how they differ from each other and, eventually, why everyone should be using Shouldly!</p>
<h2 id="the-most-basic">The Most Basic</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueOne = <span style="color:#e6db74">&#34;Something&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueTwo = <span style="color:#e6db74">&#34;Something else&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Debug.Assert(valueOne == valueTwo);
</span></span><span style="display:flex;"><span>Debug.Assert(valueOne == valueTwo, <span style="color:#e6db74">$&#34;{valueOne} should have been {valueTwo}&#34;</span>);
</span></span></code></pre></div><p>This is an assertion at it&rsquo;s most basic.  It will only assert if the condition is false, and optionally you can specify a 2nd parameter with a message.</p>
<p>This has a couple of good points to it. No external dependencies are required, and it is strong typed (as your condition has to compile.)  The down sides to this are that it is not very descriptive, and can only be used in Debug compiles (or with the DEBUG constant defined), meaning a Release mode build cannot be tested with this.</p>
<p>This also suffers from the descriptiveness problem - an output from this will only have a message saying an assertion failed, rather than anything helpful in figuring out why an assertion failed.</p>
<h2 id="nunits-first-attempt">NUnit&rsquo;s First Attempt</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueOne = <span style="color:#e6db74">&#34;Something&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueTwo = <span style="color:#e6db74">&#34;Something else&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Assert.AreEqual(valueOne, valueTwo);
</span></span><span style="display:flex;"><span>Assert.AreEqual(valueOne, valueTwo, <span style="color:#e6db74">$&#34;{valueOne} should have been {valueTwo}&#34;</span>);
</span></span></code></pre></div><p>This improves on the Most Basic version by working in Release mode builds, and as it only depends on the test framework, it doesn&rsquo;t add a dependency you didn&rsquo;t already have.</p>
<p>There are two things I dislike about this method: it remains as undescriptive as the first method, and it adds the problem of parameter ambiguity:  Which of the two parameters is the expected value, and which is the value under test? You can&rsquo;t tell without checking the method declaration.  While this is a small issue, it can cause headaches when you are trying to debug a test which has started failing, only to discover the assertion being the wrong way around was leading you astray!</p>
<h2 id="nunits-second-attempt">NUnit&rsquo;s Second Attempt</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueOne = <span style="color:#e6db74">&#34;Something&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueTwo = <span style="color:#e6db74">&#34;Something else&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Assert.That(valueOne, Is.EqualTo(valueTwo));
</span></span><span style="display:flex;"><span>Assert.That(valueOne, Is.EqualTo(valueTwo), <span style="color:#e6db74">$&#34;{valueOne} should have been {valueTwo}&#34;</span>);
</span></span></code></pre></div><p>This is an interesting attempt at readability.  On the one hand, it&rsquo;s very easy to read as a sentence, but it is very wordy, especially if you are wanting to do a Not equals <code>Is.Not.EqualTo(valueTwo)</code>.</p>
<p>This biggest problem with this however, is the complete loss of strong typing - both arguments are <code>object</code>.  This can trip you up when testing things such as Guids - especially if one of the values gets <code>.ToString()</code> on it at some point:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> id = Guid.NewGuid();
</span></span><span style="display:flex;"><span>Assert.That(id.ToString(), Is.EqualTo(id));
</span></span></code></pre></div><p>Not only will this compile, but when the test fails, unless you are paying close attention to the output, it will look like it should&rsquo;ve passed, as the only difference is the <code>&quot;</code> on either side of one of the values.</p>
<h2 id="shouldlys-version">Shouldly&rsquo;s Version</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueOne = <span style="color:#e6db74">&#34;Something&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> valueTwo = <span style="color:#e6db74">&#34;Something else&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>valueOne.ShouldBe(valueTwo);
</span></span><span style="display:flex;"><span>valueOne.ShouldBe(valueTwo, () =&gt; <span style="color:#e6db74">&#34;Custom Message&#34;</span>);
</span></span></code></pre></div><p>Finally we hit upon the <a href="http://docs.shouldly-lib.net/v2.4.0/docs">Shouldly</a> library.  This assertion library not only solves the code-time issues of strong typing, parameter clarity, and wordiness, it really improves the descriptiveness problem.</p>
<p>Shouldly uses the expression being tested against to create meaningful error messages:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">//nunit</span>
</span></span><span style="display:flex;"><span>Assert.That(map.IndexOfValue(<span style="color:#e6db74">&#34;boo&#34;</span>), Is.EqualTo(<span style="color:#ae81ff">2</span>));    <span style="color:#75715e">// -&gt; Expected 2 but was 1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//shouldly</span>
</span></span><span style="display:flex;"><span>map.IndexOfValue(<span style="color:#e6db74">&#34;boo&#34;</span>).ShouldBe(<span style="color:#ae81ff">2</span>);                    <span style="color:#75715e">// -&gt; map.IndexOfValue(&#34;boo&#34;) should be 2 but was 1</span>
</span></span></code></pre></div><p>This is even more pronounced when you are comparing collections:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">new</span>[] { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span> }.ShouldBe(<span style="color:#66d9ef">new</span>[] { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span> });
</span></span></code></pre></div><p>Produces the following output</p>
<pre tabindex="0"><code>should be
    [1, 2, 4]
but was
    [1, 2, 3]
difference
    [1, 2, *3*]
</code></pre><p>And when comparing strings, not only does it tell you they were different, but provides a visualisation of what was different:</p>
<pre tabindex="0"><code>input
    should be
&#34;this is a longer test sentence&#34;
    but was
&#34;this is a long test sentence&#34;
    difference
Difference     |                                |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
               |                               \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/
Index          | ...  9    10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29
Expected Value | ...  \s   l    o    n    g    e    r    \s   t    e    s    t    \s   s    e    n    t    e    n    c    e
Actual Value   | ...  \s   l    o    n    g    \s   t    e    s    t    \s   s    e    n    t    e    n    c    e
</code></pre><h2 id="finishing">Finishing</h2>
<p>So having seen the design time experience and rich output Shouldly gives you, why would you not use it?</p>
]]></content:encoded></item></channel></rss>