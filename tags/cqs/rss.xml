<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>cqs on Andy Dote</title><link>https://andydote.co.uk/tags/cqs/</link><description>Recent content in cqs on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Sat, 07 Jan 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/cqs/rss.xml" rel="self" type="application/rss+xml"/><item><title>MediatR and Magic</title><link>https://andydote.co.uk/2017/01/07/mediatr-and-magic/</link><pubDate>Sat, 07 Jan 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/01/07/mediatr-and-magic/</guid><description>Having recently watched Greg Young&amp;rsquo;s excellent talk on 8 Lines of Code I was thinking about how this kind of thinking applies to the mediator pattern, and specifically the MediatR implementation.
I have written about the advantages of CQRS with MediatR before, but having used it for a long time now, there are some parts which cause friction on a regular basis.
The problems Discoverability The biggest issue first. You have a controller with the following constructor:</description><content:encoded><![CDATA[<p>Having recently watched Greg Young&rsquo;s excellent talk on <a href="https://www.infoq.com/presentations/8-lines-code-refactoring">8 Lines of Code</a> I was thinking about how this kind of thinking applies to the mediator pattern, and specifically the <a href="https://github.com/jbogard/MediatR">MediatR</a> implementation.</p>
<p>I have written about the advantages of <a href="/2016/03/19/cqs-with-mediatr/">CQRS with MediatR</a> before, but having used it for a long time now, there are some parts which cause friction on a regular basis.</p>
<h2 id="the-problems">The problems</h2>
<h3 id="discoverability">Discoverability</h3>
<p>The biggest issue first.  You have a controller with the following constructor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> AddressController(IMediator mediator)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _mediator = mediator;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What messages does it emit? What handlers are used by it?  No idea without grepping for <code>_mediator.</code></p>
<h3 id="where-is-the-hander-for-x">Where is the hander for X?</h3>
<p>So you have a controller with a method which sends a <code>GetAllAddressesQuery</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AddressController</span> : ApiController
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> IEnumerable&lt;Address&gt; Get()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _mediator.Send(<span style="color:#66d9ef">new</span> GetAllAddressesQuery(User));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The fastest way to get to the handler definition is to hit <code>Ctrl+T</code> and type in <code>GetAllAddressesQueryHandler</code>.  This becomes more problematic on larger codebases when you can end up with many handlers with similar names.</p>
<h3 id="what-calls-commandqueryhandler">What calls {command|query}Handler?</h3>
<p>Given the following handler, what uses it?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GetAllAddressesQueryHandler</span> : IRequestHandler&lt;GetAllAddressesQuery, IEnumerable&lt;Address&gt;&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> IEnumerable&lt;Address&gt; Handle(GetAllAddressesQuery message)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With this problem you can use <code>Find Usages</code> on the <code>GetAllAddressesQuery</code> type parameter to find what calls it, so this isn&rsquo;t so bad at all.  The main problem is I am often doing <code>Find Usages</code> on the handler itself, not the message.</p>
<h2 id="solutions">Solutions</h2>
<h3 id="discoverability-1">Discoverability</h3>
<p>The team I am on at work felt this problem a lot before I joined, and had decided to role their own mediation pipeline.  It works much the same as MediatR, but rather than injecting an <code>IMediator</code> interface into the constructor, you inject interface(s) representing the handler(s) being used:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> AddressController(IGetAllAddressesQueryHandler getHandler, IAddAddressHandler addHandler)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _getHandler = getHandler;
</span></span><span style="display:flex;"><span>    _addHandler = addHandler;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The trade-offs made by this method are:</p>
<ul>
<li>The controllers are now more tightly coupled to the handlers (Handlers are mostly used by 1 controller anyway)</li>
<li>We can&rsquo;t easily do multicast messages (We almost never need to do this)</li>
<li>More types are required (the interface) for your handler (so what?)</li>
</ul>
<p>On the whole, I think this is a pretty good trade-off to be made, we get all the discoverability we wanted, and our controllers and handlers are still testable.</p>
<h3 id="what-callswhere-is-commandqueryhandler">What calls/Where is {command|query}Handler?</h3>
<p>This is also solved by the switch to our internal library, but we also augment the change by grouping everything into functionality groups:</p>
<pre tabindex="0"><code>Frontend
  Adddress
    AddressController.cs
    GetAllAddressesQuery.cs
    GetAllAddressesQueryHandler.cs
    IGetAllAddressesQueryHandler.cs
  Contact
    ContactController.cs
    ...
  Startup.cs
  project.json
</code></pre><p>I happen to prefer this structure to a folder for each role (e.g. <code>controllers</code>, <code>messages</code>, <code>handlers</code>), so this is not a hard change to make for me.</p>
<h2 id="magic">Magic</h2>
<p>As Greg noted in his video, the second you take in a 3rd party library, it&rsquo;s code you own (or are responsible for).  The changes we have made have really just traded some 3rd party magic for some internal magic.  How the handler pipeline gets constructed can be a mystery still (unless you go digging through the library), but it&rsquo;s a mystery we control.</p>
<p>The important part of this to note is that we felt a pain/friction with how we are working, and decided to change what trade-offs we were making.</p>
<p>What trade-offs are you making?  Is it worth changing the deal?</p>
]]></content:encoded></item><item><title>CQS with Mediatr</title><link>https://andydote.co.uk/2016/03/19/cqs-with-mediatr/</link><pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2016/03/19/cqs-with-mediatr/</guid><description>This article is some extra thoughts I had on api structure after reading Derek Comartin.
Asides from the benefits that Derek mentions (no fat repositories, thin controllers), there are a number of other advantages that this style of architecture brings.
Ease of Testing By using Command and Queries, you end up with some very useful seams for writing tests.
For controllers With controllers, you typically use Dependency injection to provide an instance of IMediator:</description><content:encoded><![CDATA[<p>This article is some extra thoughts I had on api structure after reading <a href="http://codeopinion.com/thin-controllers-cqrs-mediatr/">Derek Comartin</a>.</p>
<p>Asides from the benefits that Derek mentions (no fat repositories, thin controllers), there are a number of other advantages that this style of architecture brings.</p>
<h2 id="ease-of-testing">Ease of Testing</h2>
<p>By using Command and Queries, you end up with some very useful seams for writing tests.</p>
<h3 id="for-controllers">For controllers</h3>
<p>With controllers, you typically use Dependency injection to provide an instance of <code>IMediator</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AddressController</span> : ApiController
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> IMediator _mediator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> AddressController(IMediator mediator)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _mediator = mediator;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> IEnumerable&lt;Address&gt; Get()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _mediator.Send(<span style="color:#66d9ef">new</span> GetAllAddressesQuery(User));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You can now test the controller&rsquo;s actions return as you expect:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">[Fact]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> When_requesting_all_addresses()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> mediator = Substitute.For&lt;IMediator&gt;();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> controller = <span style="color:#66d9ef">new</span> AddressController(mediator);
</span></span><span style="display:flex;"><span>  controller.User = Substitute.For&lt;IPrincipal&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> result = controller.Get();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mediator
</span></span><span style="display:flex;"><span>      .Received(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>      .Send(Arg.Is&lt;GetAllAddressesQuery&gt;(q =&gt; q.User == controller.User));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is also useful when doing integration tests, as you can use <code>Microsoft.Owin.Testing.TestApp</code> to test that all the serialization, content negotiation etc works correctly, and still use a substituted mediator so you have known values to test with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[Fact]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">void</span> Addresses_get_should_return_an_empty_json_array()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> mediator = Substitute.For&lt;IMediator&gt;();
</span></span><span style="display:flex;"><span>    mediator.Send(Arg.Any&lt;GetAllAddressesQuery&gt;()).Returns(Enumerable.Empty&lt;Address&gt;());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> server = TestServer.Create(app =&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> api = <span style="color:#66d9ef">new</span> Startup(mediator);
</span></span><span style="display:flex;"><span>        api.Configuration(app);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> response = <span style="color:#66d9ef">await</span> _server
</span></span><span style="display:flex;"><span>        .CreateRequest(<span style="color:#e6db74">&#34;/api/address&#34;</span>)
</span></span><span style="display:flex;"><span>        .AddHeader(<span style="color:#e6db74">&#34;content-type&#34;</span>, <span style="color:#e6db74">&#34;application/json&#34;</span>)
</span></span><span style="display:flex;"><span>        .GetAsync();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> json = <span style="color:#66d9ef">await</span> response.Content.ReadAsStringAsync();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    json.ShouldBe(<span style="color:#e6db74">&#34;[]&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="for-handlers">For Handlers</h3>
<p>Handler are now isolated from the front end of your application, which means testing is a simple matter of creating an instance, passing in a message, and checking the result.  For example the <code>GetAllAddressesQuery</code> handler could be implemented like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GetAllAddressesQueryHandler</span> : IRequestHandler&lt;GetAllAddressesQuery, IEnumerable&lt;Address&gt;&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> IEnumerable&lt;Address&gt; Handle(GetAllAddressesQuery message)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (message.User == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> Enumerable.Empty&lt;Address&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> [] {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Address { Line1 = <span style="color:#e6db74">&#34;34 Home Road&#34;</span>, PostCode = <span style="color:#e6db74">&#34;BY2 9AX&#34;</span> }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And a test might look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">[Fact]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> When_no_user_is_specified()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> handler = <span style="color:#66d9ef">new</span> GetAllAddressesQueryHandler();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> result = handler.Handle(<span style="color:#66d9ef">new</span> GetAllAddressesQuery());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    result.ShouldBeEmpty();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="multiple-front-ends">Multiple Front Ends</h2>
<p>The next advantage of using Commmands and Queries is that you can support multiple frontends without code duplication.  This ties in very nicely with a <a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal architecture</a>. For example, one of my current projects has a set of commands and queries, which are used by a WebApi, and WebSocket connector, and a RabbitMQ adaptor.</p>
<p>This sample also makes use of <a href="https://www.nuget.org/packages/rabbitharness">RabbitHarness</a>, which provides a small interface for easy sending, listening and querying of queues and exchanges.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> RabbitMqConnector(IMediator mediator, IRabbitConnector connector) {
</span></span><span style="display:flex;"><span>    _mediator = mediator;
</span></span><span style="display:flex;"><span>    _connector = connector;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _connector.ListenTo(<span style="color:#66d9ef">new</span> QueueDefinition { Name = <span style="color:#e6db74">&#34;AddressQueries&#34;</span> }, OnMessage);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">bool</span> OnMessage(IBasicProperties props, GetAllAddressesQuery message)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//in this case, the message sent to RabbitMQ matches the query structure</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> addresses = _mediator.Send(message);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    _connector.SendTo(
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> QueueDefinition { Name = props.ReplyTo },
</span></span><span style="display:flex;"><span>        replyProps =&gt; replyProps.CorrelationID = props.CorrelationID,
</span></span><span style="display:flex;"><span>        addresses
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="vertical-slicing">Vertical Slicing</h2>
<p>This a soft-advantage of Commands and Queries I have found - you can have many more developers working in parallel on a project adding commands and queries etc, before you start treading on each others toes&hellip;and the only painful part is all the <code>*.csproj</code> merges you need to do!  Your mileage may vary on this one!</p>
<h2 id="disadvantages">Disadvantages</h2>
<p>In a large project, you can end up with a lot of extra classes, which can be daunting at first - one of my current projects has around 60 <code>IRequest</code> and <code>IRequestHandler</code> implementations.  As long as you follow a good naming convention, or sort them in to namespaces, it is not that much of a problem.</p>
<h2 id="overall">Overall</h2>
<p>Overall I like this pattern a lot - especially as it makes transitioning towards EventSourcing and/or full CQRS much easier.</p>
<p>How about you? What are your thoughts and experiences on this?</p>
]]></content:encoded></item></channel></rss>