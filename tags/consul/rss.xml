<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>consul on Andy Dote</title><link>https://andydote.co.uk/tags/consul/</link><description>Recent content in consul on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Mon, 04 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/consul/rss.xml" rel="self" type="application/rss+xml"/><item><title>Service Mesh with Consul Connect (and Nomad)</title><link>https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/</link><pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/</guid><description>When it comes to implementing a new feature in an application&amp;rsquo;s ecosystem, I don&amp;rsquo;t like spending my innovation tokens unless I have to, so I try not to add new tools to my infrastructure unless I really need them.
This same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don&amp;rsquo;t instantly setup Istio. Not because it&amp;rsquo;s bad - far from it - but because it&amp;rsquo;s extra complexity I would rather avoid, unless I need it.</description><content:encoded><![CDATA[<p>When it comes to implementing a new feature in an application&rsquo;s ecosystem, I <a href="https://mcfunley.com/choose-boring-technology">don&rsquo;t like spending my innovation tokens</a> unless I have to, so I try not to add new tools to my infrastructure unless I <em>really</em> need them.</p>
<p>This same approach comes when I either want, need, or have been told, to implement a Service Mesh.  This means I don&rsquo;t instantly setup <a href="https://istio.io/">Istio</a>.  Not because it&rsquo;s bad - far from it - but because it&rsquo;s extra complexity I would rather avoid, unless I need it.</p>
<p>But what alternatives are there?</p>
<p>In most large systems I have been involved with <a href="https://www.consul.io">Consul</a> has been deployed;  usually for Service Discovery, <a href="/2018/09/06/consul-feature-toggles/">Feature Toggles</a>, it&rsquo;s key-value store, or distributed locking.  As Consul has Service Mesh functionality built in, why not use that?</p>
<p>So let&rsquo;s dive into setting up a <a href="https://www.consul.io/docs/connect/index.html">Consul Connect</a> based Service Mesh.</p>
<h2 id="implementing">Implementing</h2>
<p>The demo for this is made up of two parts (taken from HashiCorp&rsquo;s consul demo repo): a counter and a dashboard.  The counter listens for HTTP requests and will return the number of requests it&rsquo;s handled.  The dashboard polls the counter and displays the current count.</p>
<p>All the source code for the demo is in the <a href="https://github.com/Pondidum/consul-connect-nomad-demo">Consul Connect Example Repository</a>.</p>
<p>Clone the repository, and run the build script to create the apps:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git clone https://github.com/Pondidum/consul-connect-nomad-demo
</span></span><span style="display:flex;"><span>cd consul-connect-nomad-demo
</span></span><span style="display:flex;"><span>./apps/build.sh
</span></span></code></pre></div><h3 id="local-run">Local Run</h3>
<p>Run the apps locally to prove they work, in two separate terminals:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">9001</span> ./apps/bin/counter
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">9002</span> ./apps/bin/dashboard
</span></span></code></pre></div><p>Open <code>http://localhost:9002</code> to see the counter running.</p>
<h3 id="start-a-cluster">Start A Cluster</h3>
<p>Now we have established our apps actually start, we can create a small Consul cluster.  I am using my Hashibox to do this, so you&rsquo;ll need libvirt and Vagrant installed to do this.</p>
<p>Running <code>vagrant up</code> will spawn three machines, which will form a Consul cluster, which we can now experiment in.  Once it is up and running, we can manually register the two applications into Consul&rsquo;s service mesh to check that our in cluster communication works.</p>
<p>First, the counter service.  The script writes a service definition into consul, which, by specifying the <code>connect</code> stanza, indicates this service is to be included in the service mesh.  Once this is done, the counter is started (and sent to the background), and a consul connect proxy is started for this service:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl --request PUT --url http://localhost:8500/v1/agent/service/register <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  --data <span style="color:#e6db74">&#39;{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;name&#34;: &#34;counter&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;port&#34;: 9001,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;connect&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      &#34;sidecar_service&#34;: {}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  }&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PORT<span style="color:#f92672">=</span><span style="color:#ae81ff">9001</span> /vagrant/apps/bin/counter &amp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>consul connect proxy -sidecar-for counter
</span></span></code></pre></div><p>We can run this script in a new terminal by running this command:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant ssh one -c <span style="color:#e6db74">&#39;/vagrant/scripts/counter.sh&#39;</span>
</span></span></code></pre></div><p>Finally, we start the dashboard.  The script is very similar, in that we write a service definiton into consul, start the service and run a proxy.  The only notable difference is the service registation payload itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;dashboard&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;port&#34;</span>: <span style="color:#ae81ff">9002</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;connect&#34;</span>: {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;sidecar_service&#34;</span>: {
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&#34;proxy&#34;</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&#34;upstreams&#34;</span>: [
</span></span><span style="display:flex;"><span>          { <span style="color:#f92672">&#34;destination_name&#34;</span>: <span style="color:#e6db74">&#34;counter&#34;</span>, <span style="color:#f92672">&#34;local_bind_port&#34;</span>: <span style="color:#ae81ff">8080</span> }
</span></span><span style="display:flex;"><span>        ]
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As before, it registers a service, and on what port it will be listening on, but in the <code>connect</code> stanza, we specify that we want to connect to the <code>counter</code>, and we want to talk to it on <code>localhost:8080</code>.</p>
<p>In a new terminal, you can run this script like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant ssh two -c <span style="color:#e6db74">&#39;/vagrant/scripts/dashboard.sh&#39;</span>
</span></span></code></pre></div><p>Now that both are up and running, you can open a browser to the dashboard and see it working: <code>http://two.karhu.xyz:9002</code>.  Once you are satisfied, you can stop the services by hitting <code>ctrl+c</code> in both terminals&hellip;or try running a second counter or dashboard on the third vagrant machine (<code>vagrant ssh three -c '/vagrant/scripts/dashboard.sh'</code>)</p>
<h3 id="nomad">Nomad</h3>
<p>Now that we have seen how to run the services manually let&rsquo;s see how easy it is to use the service mesh using <a href="https://nomadproject.io">Nomad</a>.</p>
<p>There are two nomad job definitions in the included project, so let&rsquo;s look at the counter&rsquo;s first:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">job</span> <span style="color:#e6db74">&#34;counter&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">datacenters</span> = [<span style="color:#e6db74">&#34;dc1&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">group</span> <span style="color:#e6db74">&#34;api&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">count</span> = <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">network</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">mode</span> = <span style="color:#e6db74">&#34;bridge&#34;</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">service</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;count-api&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">port</span> = <span style="color:#e6db74">&#34;9001&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">connect</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sidecar_service</span> {}
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">task</span> <span style="color:#e6db74">&#34;counter&#34;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">driver</span> = <span style="color:#e6db74">&#34;exec&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">config</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">command</span> = <span style="color:#e6db74">&#34;/vagrant/apps/bin/counter&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">env</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PORT</span> = <span style="color:#ae81ff">9001</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>network</code> stanza is set to <code>bridge</code> mode, which creates us an isolated network between all the services in the group only.  In our case, we will have a single <code>counter</code> service and the proxy.</p>
<p>The <code>service</code> stanza is replicating the same functionality we had by writing a service registration into Consul.  By specifying the <code>connect</code> part, Nomad knows that it also needs to start a proxy-based on the service stanza&rsquo;s settings, and will handle starting and stopping this proxy for us.</p>
<p>The <code>task &quot;counter&quot;</code> block uses the <code>exec</code> driver to run the counter app natively on the host, but <code>docker</code>, <code>java</code>, and others are available too.</p>
<p>To run this into our Nomad cluster, we can use the nomad CLI:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export NOMAD_ADDR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://one.karhu.xyz:4646&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nomad job run apps/counter/counter.nomad
</span></span></code></pre></div><p>The dashboard&rsquo;s Nomad job is very similar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#a6e22e">job</span> <span style="color:#e6db74">&#34;dashboard&#34;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">datacenters</span> = [<span style="color:#e6db74">&#34;dc1&#34;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">group</span> <span style="color:#e6db74">&#34;dashboard&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">network</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">mode</span> = <span style="color:#e6db74">&#34;bridge&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">port</span> <span style="color:#e6db74">&#34;http&#34;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">to</span>     = <span style="color:#ae81ff">9002</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">service</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">name</span> = <span style="color:#e6db74">&#34;count-dashboard&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">port</span> = <span style="color:#ae81ff">9002</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">connect</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">sidecar_service</span> {
</span></span><span style="display:flex;"><span>          <span style="color:#a6e22e">proxy</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">upstreams</span> {
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">destination_name</span> = <span style="color:#e6db74">&#34;count-api&#34;</span>
</span></span><span style="display:flex;"><span>              <span style="color:#a6e22e">local_bind_port</span>  = <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">task</span> <span style="color:#e6db74">&#34;dashboard&#34;</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">driver</span> = <span style="color:#e6db74">&#34;exec&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">config</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">command</span> = <span style="color:#e6db74">&#34;/vagrant/apps/bin/dashboard&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">env</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">PORT</span> = <span style="color:#e6db74">&#34;${NOMAD_PORT_http}&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">COUNTING_SERVICE_URL</span> = <span style="color:#e6db74">&#34;http://${NOMAD_UPSTREAM_ADDR_count_api}&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>network</code> block this time also specifies that we want to expose our service to the public.  As we don&rsquo;t have a <code>static = 9002</code> in the port definition, Nomad will assign one at random (this is better! You can avoid port clashes with multiple tasks on the same node), we do however specify that we will map to <code>9002</code>.  The rest of the file can use the Nomad variable <code>NOMAD_PORT_http</code> to get this port number, so we don&rsquo;t have to copy-paste the number everywhere.  Similarly, the <code>sidecar_service</code> stanza exposes a variable called <code>NOMAD_UPSTREAM_ADDR_&lt;destination_name&gt;</code>, so we can use that too for our dashboard task&rsquo;s environment variable values. This means we should only ever need to specify ports in 1 location in a Nomad file.</p>
<p>As with the counter, we can run the job using the CLI:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nomad job run apps/counter/dashboard.nomad
</span></span></code></pre></div><p>If we want to get the address and port the dashboard is actually running at, it is easiest to go through the UI, but you can also get the information from the console using the Nomad CLI and jq:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>allocation_id<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>nomad alloc status -json | jq -r <span style="color:#e6db74">&#39;.[] | select(.JobID == &#34;dashboard&#34;) | .ID&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>nomad alloc status -json <span style="color:#e6db74">&#34;</span>$allocation_id<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  | jq -r <span style="color:#e6db74">&#39;.AllocatedResources.Shared.Networks[0] | ( &#34;http://&#34; + .IP + &#34;:&#34; + (.DynamicPorts[] | select(.Label == &#34;http&#34;) | .Value | tostring))&#39;</span>
</span></span></code></pre></div><h2 id="wrapping-up">Wrapping Up</h2>
<p>With Consul Connect&rsquo;s supported APIs, there is great flexibility in how you can implement your service mesh; through definition files, through API requests, or through the container orchestrator directly.  Couple this with Consul already being in use in most systems I have been involved with, and hopefully you can see why it makes a great way of having a Service Mesh.</p>
]]></content:encoded></item><item><title>Consul DNS Fowarding in Alpine, revisited</title><link>https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/</link><pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/</guid><description>I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn&amp;rsquo;t resolve *.consul domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.
After a lot of googling and frustration, I was able to track down that it&amp;rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn&amp;rsquo;t do.</description><content:encoded><![CDATA[<p>I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn&rsquo;t resolve <code>*.consul</code> domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.</p>
<p>After a lot of googling and frustration, I was able to track down that it&rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn&rsquo;t do. From Musl libc&rsquo;s <a href="https://wiki.musl-libc.org/functional-differences-from-glibc.html">Functional differences from glibc</a> page, we can see under the Name Resolver/DNS section the relevant information:</p>
<blockquote>
<p>Traditional resolvers, including glibc&rsquo;s, make use of multiple nameserver lines in resolv.conf by trying each one in sequence and falling to the next after one times out. musl&rsquo;s resolver queries them all in parallel and accepts whichever response arrives first.</p>
</blockquote>
<p>The machine&rsquo;s <code>/etc/resolv.conf</code> file has two <code>nameserver</code> specified:</p>
<pre tabindex="0"><code>nameserver 127.0.0.1
nameserver 192.168.121.1
</code></pre><p>The first is our <code>Unbound</code> instance which handles the forwarding to Consul, and the second is the DHCP set DNS server, in this case, libvirt/qemu&rsquo;s dnsmasq instance.</p>
<p>When running in a glibc based system, queries go to the first <code>nameserver</code>, and then if that can&rsquo;t resolve the request, it is then sent to the next <code>nameserver</code>, and so forth. As Alpine Linux uses muslc, it makes the requests in parallel and uses the response from whichever response comes back first.</p>
<p><img loading="lazy" src="muslc-dns.png" alt="sequence diagram, showing parallel DNS requests"  />
</p>
<p>When the DHCP DNS server is a network hop away, the latency involved means our resolution usually works, as the queries will hit the local DNS and get a response first. However, when the DHCP DNS is not that far away, for example when it is the DNS server that libvirt runs in the virtual network the machine is attached to, it becomes much more likely to get a response from that DNS server first, causing the failures I was seeing.</p>
<p>The solution to this is to change the setup so that all requests go to Unbound, which can then decide where to send them on to.  This also has the additional benefits of making all DNS requests work the same on all systems; regardless of glibc or muslc being used.</p>
<p><img loading="lazy" src="unbound-dns.png" alt="sequence diagram, showing all DNS requests going through unbound"  />
</p>
<h2 id="rebuilding-dns-resolution">Rebuilding DNS Resolution</h2>
<p>You can follow the same instructions in my previous <a href="/2019/05/31/consul-dns-forwarding-alpine/#run-consul">Consul DNS forwarding</a> post to setup Consul, as that is already in the right state for us.</p>
<p>Once Consul is up and running, it&rsquo;s time to fix the rest of our pipeline.</p>
<h3 id="unbound">Unbound</h3>
<p>First, install <code>unbound</code> and configure it to start on boot:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk add unbound
</span></span><span style="display:flex;"><span>rc-update add unbound
</span></span></code></pre></div><p>The unbound config file (<code>/etc/unbound/unbound.conf</code>) is almost the same as the previous version, except we also have an <code>include</code> statement, pointing to a second config file, which we will generate shortly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">server</span>:
</span></span><span style="display:flex;"><span> <span style="color:#f92672">verbosity</span>: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">do-not-query-localhost</span>: <span style="color:#66d9ef">no</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">domain-insecure</span>: <span style="color:#e6db74">&#34;consul&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">stub-zone</span>:
</span></span><span style="display:flex;"><span> <span style="color:#f92672">name</span>: <span style="color:#e6db74">&#34;consul&#34;</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">stub-addr</span>: <span style="color:#ae81ff">127.0.0.1</span>@<span style="color:#ae81ff">8600</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">include</span>: <span style="color:#e6db74">&#34;/etc/unbound/forward.conf&#34;</span>
</span></span></code></pre></div><h3 id="dhclient">Dhclient</h3>
<p>Next, we install <code>dhclient</code> so that we can make use of it&rsquo;s hooks feature to generate our additional unbound config file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>apk add dhclient
</span></span></code></pre></div><p>Create a config file for dhclient (<code>/etc/dhcp/dhclient.conf</code>), which again is almost the same as the previous post, but this time doesn&rsquo;t specify <code>prepend domain-name-servers</code>:</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;
send host-name = gethostname();
request subnet-mask, broadcast-address, time-offset, routers,
 domain-name, domain-name-servers, domain-search, host-name,
 dhcp6.name-servers, dhcp6.domain-search, dhcp6.fqdn, dhcp6.sntp-servers,
 netbios-name-servers, netbios-scope, interface-mtu,
 rfc3442-classless-static-routes, ntp-servers;
</code></pre><p>Now we can write two hooks. The first is an enter hook, which we can use to write the <code>forward.conf</code> file out.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>touch /etc/dhclient-enter-hooks
</span></span><span style="display:flex;"><span>chmod +x /etc/dhclient-enter-hooks
</span></span></code></pre></div><p>The content is a single statement to write the <code>new_domain_name_servers</code> value into a <code>forward-zone</code> for unbound:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#e6db74">&lt;&lt;-EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">forward-zone:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> name: &#34;.&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74"> forward-addr: ${new_domain_name_servers}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span> | sudo tee /etc/unbound/forward.conf
</span></span></code></pre></div><p>The second hook is an exit ook, which runs after dhclient has finished writing out all the files it controls (such as <code>/etc/resolv.conf</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>touch /etc/dhclient-exit-hooks
</span></span><span style="display:flex;"><span>chmod +x /etc/dhclient-exit-hooks
</span></span></code></pre></div><p>The content is a single <code>sed</code> statement to replace the address of <code>nameserver</code> directives written to the <code>/etc/resolv.conf</code> with the unbound address:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>sudo sed -i <span style="color:#e6db74">&#39;s/nameserver.*/nameserver 127.0.0.1/g&#39;</span> /etc/resolv.conf
</span></span></code></pre></div><p>It&rsquo;s worth noting; we could put the content of the <code>enter</code> hook into the <code>exit</code> hook if you would rather.</p>
<p>Finally, we can delete our current <code>resolv.conf</code> and restart the networking service:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rm /etc/resolv.conf <span style="color:#75715e"># hack due to it dhclient making an invalid `chown` call.</span>
</span></span><span style="display:flex;"><span>rc-service networking restart
</span></span></code></pre></div><h2 id="testing">Testing</h2>
<p>We can now test that we can resolve the three kinds of address we care about:</p>
<ul>
<li><code>dig consul.service.consul</code> - should return the <code>eth0</code> ip of the machine</li>
<li><code>dig alpinetest.karhu.xyz</code> - should be resolved by libvirt&rsquo;s dnsmasq instance</li>
<li><code>dig example.com</code> - should be resolved by an upstream DNS server</li>
</ul>
<h2 id="conculsion">Conculsion</h2>
<p>This was an interesting and somewhat annoying problem to solve, but it means I have a more robust setup in my virtual machines now. It&rsquo;s interesting to note that if the DNS server from DHCP were not a local instance, the network latency added would make all the system function properly most of the time, as the local instance would answer before the remote instance could.</p>
]]></content:encoded></item><item><title>Creating a Vault instance with a TLS Consul Cluster</title><link>https://andydote.co.uk/2019/10/06/vault-consul-bootstrap/</link><pubDate>Sun, 06 Oct 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/10/06/vault-consul-bootstrap/</guid><description>So we want to set up a Vault instance, and have it&amp;rsquo;s storage be a TLS based Consul cluster. The problem is that the Consul cluster needs Vault to create the certificates for TLS, which is quite the catch-22. Luckily for us, quite easy to solve:
Start a temporary Vault instance as an intermediate ca Launch Consul cluster, using Vault to generate certificates Destroy temporary Vault instance Start a permanent Vault instance, with Consul as the store Reprovision the Consul cluster with certificates from the new Vault instance There is a repository on Github with all the scripts used, and a few more details on some options.</description><content:encoded><![CDATA[<p>So we want to set up a <a href="https://www.vaultproject.io/">Vault</a> instance, and have it&rsquo;s storage be a TLS based <a href="https://www.consul.io/">Consul</a> cluster.  The problem is that the Consul cluster needs Vault to create the certificates for TLS, which is quite the catch-22.  Luckily for us, quite easy to solve:</p>
<ol>
<li>Start a temporary Vault instance as an intermediate ca</li>
<li>Launch Consul cluster, using Vault to generate certificates</li>
<li>Destroy temporary Vault instance</li>
<li>Start a permanent Vault instance, with Consul as the store</li>
<li>Reprovision the Consul cluster with certificates from the new Vault instance</li>
</ol>
<p><img loading="lazy" src="consul-vault-bootstrap.png" alt="Sequence diagram of the previous numbered list"  />
</p>
<p>There is a <a href="https://github.com/Pondidum/vault-consul-bootstrap-demo">repository on Github with all the scripts</a> used, and a few more details on some options.</p>
<h2 id="assumptions">Assumptions:</h2>
<p>The Host machine needs the following software available in your <code>PATH</code>:</p>
<ul>
<li><a href="https://www.vagrantup.com/">Vagrant</a></li>
<li><a href="https://www.consul.io/">Consul</a></li>
<li><a href="https://www.vaultproject.io/">Vault</a></li>
</ul>
<p>You have a TLS Certificate you can use to create an intermediate CA with.  See this blog post for <a href="/2019/08/25/vault-development-ca/">How to create a local CA</a></p>
<h2 id="running">Running</h2>
<p>The <code>run.sh</code> script will do all of this for you, but an explanation of the steps is below:</p>
<ol>
<li>
<p>Start a Temporary Vault instance</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">storage &#34;inmem&#34; {}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">listener &#34;tcp&#34; {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  address = &#34;0.0.0.0:8200&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  tls_disable = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}&#39;</span> &gt; <span style="color:#e6db74">&#34;vault/temp_vault.hcl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vault server -config<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;vault/temp_vault.hcl&#34;</span> &amp;
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;</span>$!<span style="color:#e6db74">&#34;</span> &gt; vault.pid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export VAULT_TOKEN<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>./configure_vault.sh | tail -n 1<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
<li>
<p>Generate a Vault token for the Consul machines to use to authenticate with Vault</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export CONSUL_VAULT_TOKEN<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>vault write -field<span style="color:#f92672">=</span>token -force auth/token/create<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
<li>
<p>Launch 3 Consul nodes (uses the <code>CONSUL_VAULT_TOKEN</code> variable)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant up
</span></span></code></pre></div><p>The <code>vagrantfile</code> just declares 3 identical machines:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">Vagrant</span><span style="color:#f92672">.</span>configure(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>config<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>box <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pondidum/hashibox&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>provision <span style="color:#e6db74">&#34;consul&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">type</span>: <span style="color:#e6db74">&#34;shell&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;./provision.sh&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">env</span>: {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;VAULT_TOKEN&#34;</span> <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">ENV</span><span style="color:#f92672">[</span><span style="color:#e6db74">&#34;CONSUL_VAULT_TOKEN&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;c1&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c1<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    c1<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;consul1&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;c2&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c2<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    c2<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;consul2&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;c3&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c3<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    c3<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;consul3&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>The provisioning script just reads a certificate from Vault, and writes out pretty much the same configuration as in the last post on <a href="/2019/09/14/consul-tls-cluster">creating a TLS enabled Consul Cluster</a>, but you can view it in the <a href="https://github.com/Pondidum/vault-consul-bootstrap-demo">repository</a> for this demo too.</p>
</li>
<li>
<p>Create a local Consul server to communicate with the cluster:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./local_consul.sh
</span></span></code></pre></div><p>This is done so that the Vault instance can always communicate with the Consul cluster, no matter which Consul node we are reprovisioning later.  In a production environment, you would have this Consul server running on each machine that Vault is running on.</p>
</li>
<li>
<p>Stop the temporary Vault instance now that all nodes have a certificate</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kill <span style="color:#66d9ef">$(</span>cat vault.pid<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
<li>
<p>Start the persistent Vault instance, using the local Consul agent</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">storage &#34;consul&#34; {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  address = &#34;localhost:8501&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  scheme = &#34;https&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">listener &#34;tcp&#34; {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  address = &#34;0.0.0.0:8200&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  tls_disable = 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}&#39;</span> &gt; <span style="color:#e6db74">&#34;</span>$config_dir<span style="color:#e6db74">/persistent_vault.hcl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vault server -config<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$config_dir<span style="color:#e6db74">/persistent_vault.hcl&#34;</span> &gt; /dev/null &amp;
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;</span>$!<span style="color:#e6db74">&#34;</span> &gt; vault.pid
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export VAULT_TOKEN<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>./configure_vault.sh | tail -n 1<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
<li>
<p>Generate a new Vault token for the Consul machines to use to authenticate with Vault (same as step 2)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export CONSUL_VAULT_TOKEN<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>vault write -field<span style="color:#f92672">=</span>token -force auth/token/create<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
<li>
<p>Reprovision the Consul nodes with new certificates</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vagrant provision c1 --provision-with consul
</span></span><span style="display:flex;"><span>vagrant provision c2 --provision-with consul
</span></span><span style="display:flex;"><span>vagrant provision c3 --provision-with consul
</span></span></code></pre></div></li>
<li>
<p>Profit</p>
<p>To clean up the host&rsquo;s copy of Vault and Consul, you can run this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>kill <span style="color:#66d9ef">$(</span>cat vault.pid<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>kill <span style="color:#66d9ef">$(</span>cat consul.pid<span style="color:#66d9ef">)</span>
</span></span></code></pre></div></li>
</ol>
<h2 id="summary--further-actions">Summary &amp; Further Actions</h2>
<p>Luckily, this is the kind of thing that should only need doing once (or once per isolated environment).  When running in a real environment, you will also want to set up:</p>
<ul>
<li>ACL in Consul which locks down the KV storage Vault uses to only be visible/writeable by Vault</li>
<li>Provisioning the <code>VAULT_TOKEN</code> to the machines in a secure fashion</li>
<li>Periodic refresh of the Certificates uses in the Consul cluster</li>
</ul>
]]></content:encoded></item><item><title>Consul DNS Fowarding in Ubuntu, revisited</title><link>https://andydote.co.uk/2019/09/24/consul-ubuntu-dns-revisited/</link><pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/09/24/consul-ubuntu-dns-revisited/</guid><description>I was recently using my Hashibox for a test, and I noticed the DNS resolution didn&amp;rsquo;t seem to work. This was a bit worrying, as I have written about how to do DNS resolution with Consul forwarding in Ubuntu, and apparently something is wrong with how I do it. Interestingly, the Alpine version works fine, so it appears there is something not quite working with how I am configuring Systemd-resolved.</description><content:encoded><![CDATA[<p>I was recently using my <a href="https://github.com/pondidum/hashibox">Hashibox</a> for a test, and I noticed the DNS resolution didn&rsquo;t seem to work.  This was a bit worrying, as I have written about how to do <a href="/2019/05/29/consul-dns-forwarding/">DNS resolution with Consul forwarding in Ubuntu</a>, and apparently something is wrong with how I do it.  Interestingly, the <a href="/2019/05/31/consul-dns-forwarding-alpine/">Alpine version</a> works fine, so it appears there is something not quite working with how I am configuring Systemd-resolved.</p>
<p>So this post is how I figured out what was wrong, and how to do DNS resolution with Consul forwarding on Ubuntu properly!</p>
<h2 id="the-problem">The Problem</h2>
<p>If Consul is running on the host, I can only resolve <code>.consul</code> domains, and if Consul is not running, I can resolve anything else.  Clearly I have configured something wrong!</p>
<p>To summarise, I want to be able to resolve 3 kinds of address:</p>
<ul>
<li><code>*.consul</code> addresses should be handled by the local Consul instance</li>
<li><code>$HOSTNAME.mshome.net</code> should be handled by the Hyper-V DNS server (running on the Host machine)</li>
<li><code>reddit.com</code> public DNS should be resolved properly</li>
</ul>
<h2 id="discovery">Discovery</h2>
<p>To make sure that hostname resolution even works by default, I create a blank Ubuntu box in Hyper-V, using <a href="https://www.vagrantup.com/">Vagrant</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">Vagrant</span><span style="color:#f92672">.</span>configure(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>config<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>box <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bento/ubuntu-16.04&#34;</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>I set the hostname so that I can test that dns resolution works from the host machine to the guest machines too.  I next bring up the machine, SSH into it, and try to <code>dig</code> my hostmachine&rsquo;s DNS name (<code>spectre.mshome.net</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; vagrant up
</span></span><span style="display:flex;"><span>&gt; vagrant ssh
</span></span><span style="display:flex;"><span>&gt; dig spectre.mshome.net
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; spectre.mshome.net
</span></span><span style="display:flex;"><span>;; global options: +cmd
</span></span><span style="display:flex;"><span>;; Got answer:
</span></span><span style="display:flex;"><span>;; -&gt;&gt;HEADER<span style="color:#e6db74">&lt;&lt;- opco</span>de: QUERY, status: NOERROR, id: <span style="color:#ae81ff">12333</span>
</span></span><span style="display:flex;"><span>;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; QUESTION SECTION:
</span></span><span style="display:flex;"><span>;spectre.mshome.net.            IN      A
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; ANSWER SECTION:
</span></span><span style="display:flex;"><span>Spectre.mshome.net.     <span style="color:#ae81ff">0</span>       IN      A       192.168.181.161
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; Query time: <span style="color:#ae81ff">0</span> msec
</span></span><span style="display:flex;"><span>;; SERVER: 192.168.181.161#53<span style="color:#f92672">(</span>192.168.181.161<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>;; WHEN: Mon Sep <span style="color:#ae81ff">23</span> 21:57:26 UTC <span style="color:#ae81ff">2019</span>
</span></span><span style="display:flex;"><span>;; MSG SIZE  rcvd: <span style="color:#ae81ff">70</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&gt; exit
</span></span><span style="display:flex;"><span>&gt; vagrant destroy -f
</span></span></code></pre></div><p>As you can see, the host machine&rsquo;s DNS server responds with the right address.  Now that I know that this should work, we can tweak the <code>Vagrantfile</code> to start an instance of my Hashibox:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">Vagrant</span><span style="color:#f92672">.</span>configure(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>config<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>box <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pondidum/hashibox&#34;</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>When I run the same command sin this box, I get a slighty different response:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Ubuntu &lt;&lt;&gt;&gt; spectre.mshome.net
</span></span><span style="display:flex;"><span>;; global options: +cmd
</span></span><span style="display:flex;"><span>;; Got answer:
</span></span><span style="display:flex;"><span>;; -&gt;&gt;HEADER<span style="color:#e6db74">&lt;&lt;- opco</span>de: QUERY, status: NXDOMAIN, id: <span style="color:#ae81ff">57216</span>
</span></span><span style="display:flex;"><span>;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>;; WARNING: recursion requested but not available
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; OPT PSEUDOSECTION:
</span></span><span style="display:flex;"><span>; EDNS: version: 0, flags:; udp: <span style="color:#ae81ff">4096</span>
</span></span><span style="display:flex;"><span>;; QUESTION SECTION:
</span></span><span style="display:flex;"><span>;spectre.mshome.net.            IN      A
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; AUTHORITY SECTION:
</span></span><span style="display:flex;"><span>consul.                 <span style="color:#ae81ff">0</span>       IN      SOA     ns.consul. hostmaster.consul. <span style="color:#ae81ff">1569276784</span> <span style="color:#ae81ff">3600</span> <span style="color:#ae81ff">600</span> <span style="color:#ae81ff">86400</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>;; Query time: <span style="color:#ae81ff">1</span> msec
</span></span><span style="display:flex;"><span>;; SERVER: 127.0.0.1#53<span style="color:#f92672">(</span>127.0.0.1<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>;; WHEN: Mon Sep <span style="color:#ae81ff">23</span> 22:13:04 UTC <span style="color:#ae81ff">2019</span>
</span></span><span style="display:flex;"><span>;; MSG SIZE  rcvd: <span style="color:#ae81ff">103</span>
</span></span></code></pre></div><p>As intended, the DNS server on localhost responded&hellip;but it looks like Consul answered, not the inbuilt dns server (<code>systemd-resolved</code>), as I intended.</p>
<p>The reason for this is that I am running Consul&rsquo;s DNS endpoint on <code>8600</code>, and Systemd-Resolved cannot send requests to anything other than port <code>53</code>, so I use <code>iptables</code> to redirect the traffic from port <code>53</code> to <code>8600</code>, which means any local use of DNS will always be sent to Consul.</p>
<p>The reason it works when Consul is not running is that we have both <code>127.0.0.1</code> specified as a nameserver, and a fallback set to be the <code>eth0</code>&rsquo;s Gateway, so when Consul doesn&rsquo;t respond, the request hits the default DNS instead.</p>
<h2 id="the-solution-dnsmasq">The Solution: Dnsmasq.</h2>
<p>Basically, stop using <code>systemd-resolved</code> and use something that has a more flexible configuration.  Enter Dnsmasq.</p>
<p>Starting from the blank Ubuntu box, I install dnsmasq, and disable systemd-resolved.  Doing this might prevent any DNS resolutio working for a while&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt-get install -yq dnsmasq
</span></span><span style="display:flex;"><span>sudo systemctl disable systemd-resolved.service
</span></span></code></pre></div><p>If you would rather not disable <code>systemd-resolved</code> entirely, you can use these two lines instead to just switch off the local DNS stub:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;DNSStubListener=no&#34;</span> | sudo tee --append /etc/systemd/resolved.conf
</span></span><span style="display:flex;"><span>sudo systemctl restart systemd-resolved
</span></span></code></pre></div><p>Next I update <code>/etc/resolv.conf</code> to not be managed by Systemd, and point to where dnsmasq will be running:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo rm /etc/resolv.conf
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;nameserver 127.0.0.1&#34;</span> | sudo tee /etc/resolv.conf
</span></span></code></pre></div><p>The reason for deleting the file is that it was symlinked to the Systemd-Resolved managed file, so that link needed to be broken first to prevent Systemd interfering.</p>
<p>Lastly a minimal configuration for dnsmasq:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">port=53
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">resolv-file=/var/run/dnsmasq/resolv.conf
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">bind-interfaces
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">listen-address=127.0.0.1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">server=/consul/127.0.0.1#8600
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span> | sudo tee /etc/dnsmasq.d/default
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo systemctl restart dnsmasq
</span></span></code></pre></div><p>This config does a few things, the two most important lines are:</p>
<ul>
<li>
<p><code>resolv-file=/var/run/dnsmasq/resolv.conf</code> which is pointing to the default <code>resolv.conf</code> written by dnsmasq.  This file contains the default nameserver supplied by the default network connection, and I want to use this as a fallback for anything dnsmasq cannot resolve directly (which will be everything, except <code>.consul</code>).  In my case, the content of this file is just <code>nameserver 192.168.181.161</code>.</p>
</li>
<li>
<p><code>server=/consul/127.0.0.1#8600</code> specifies that any address ending in <code>.consul</code> should be forwarded to Consul, running at <code>127.0.0.1</code> on port <code>8600</code>.  No more <code>iptables</code> rules!</p>
</li>
</ul>
<h2 id="testing">Testing</h2>
<p>Now that I have a (probably) working DNS system, let&rsquo;s look at testing it properly this time.  There are 3 kinds of address I want to test:</p>
<ul>
<li>Consul resolution, e.g. <code>consul.service.consul</code> should return the current Consul instance address.</li>
<li>Hostname resolution, e.g. <code>spectre.mshome.net</code> should resolve to the machine hosting the VM.</li>
<li>Public resolution, e.g. <code>reddit.com</code> should resolve to&hellip;reddit.</li>
</ul>
<p>I also want to test that the latter two cases work when Consul is <strong>not</strong> running too.</p>
<p>So let&rsquo;s write a simple script to make sure these all work.  This way I can reuse the same script on other machines, and also with other VM providers to check DNS works as it should.  The entire script is here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>local_domain<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>1<span style="color:#66d9ef">:-</span>mshome.net<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>host_machine<span style="color:#f92672">=</span><span style="color:#e6db74">${</span>2<span style="color:#66d9ef">:-</span>spectre<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>consul agent -dev -client 0.0.0.0 -bind <span style="color:#e6db74">&#39;{{ GetInterfaceIP &#34;eth0&#34; }}&#39;</span> &gt; /dev/null &amp;
</span></span><span style="display:flex;"><span>sleep <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>consul_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig consul.service.consul +short<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>self_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig $HOSTNAME.$local_domain +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>host_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig $host_machine.$local_domain +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>reddit_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig reddit.com +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>kill %1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$consul_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get consul ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$self_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get self ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$host_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get host ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$reddit_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get reddit ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;==&gt; Consul Running: Success!&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>consul_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig consul.service.consul +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>self_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig $HOSTNAME.$local_domain +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>host_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig $host_machine.$local_domain +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>reddit_ip<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>dig reddit.com +short | tail -n 1<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$consul_ip<span style="color:#e6db74">&#34;</span> !<span style="color:#f92672">=</span> *<span style="color:#e6db74">&#34;;; connection timed out;&#34;</span>* <span style="color:#f92672">]]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Got a consul ip (</span>$consul_ip<span style="color:#e6db74">)&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$self_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get self ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$host_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get host ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;</span>$reddit_ip<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&#34;</span> <span style="color:#f92672">]</span> <span style="color:#f92672">&amp;&amp;</span> echo <span style="color:#e6db74">&#34;Didn&#39;t get reddit ip&#34;</span> &gt;&amp;<span style="color:#ae81ff">2</span> <span style="color:#f92672">&amp;&amp;</span> exit <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;==&gt; Consul Stopped: Success!&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>exit <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>What this does is:</p>
<ol>
<li>Read two command line arguments, or use defaults if not specified</li>
<li>Start Consul as a background job</li>
<li>Query 4 domains, storing the results</li>
<li>Stop Consul (<code>kill %1</code>)</li>
<li>Check an IP address came back for each domain</li>
<li>Query the same 4 domains, storing the results</li>
<li>Check that a timeout was received for <code>consul.service.consul</code></li>
<li>Check an IP address came back for the other domains</li>
</ol>
<p>To further prove that dnsmasq is forwarding requests correctly, I can include two more lines to <code>/etc/dnsmasq.d/default</code> to enable logging, and restart dnsmasq</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;log-queries&#34;</span> | sudo tee /etc/dnsmasq.d/default
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;log-facility=/var/log/dnsmasq.log&#34;</span> | sudo tee /etc/dnsmasq.d/default
</span></span><span style="display:flex;"><span>sudo systemctl restart dnsmasq
</span></span><span style="display:flex;"><span>dig consul.service.consul
</span></span></code></pre></div><p>Now I can view the log file and check that it received the DNS query and did the right thing.  In this case, it recieved the <code>consul.service.consul</code> query, and forwarded it to the local Consul instance:</p>
<pre tabindex="0"><code>Sep 24 06:30:50 dnsmasq[13635]: query[A] consul.service.consul from 127.0.0.1
Sep 24 06:30:50 dnsmasq[13635]: forwarded consul.service.consul to 127.0.0.1
Sep 24 06:30:50 dnsmasq[13635]: reply consul.service.consul is 192.168.181.172
</code></pre><p>I don&rsquo;t tend to keep DNS logging on in my Hashibox as the log files can grow very quickly.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Now that I have proven my DNS resolution works (I think), I have rolled it back into my Hashibox, and can now use machine names for setting up clusters, rather than having to specify IP addresses initially.</p>
]]></content:encoded></item><item><title>Creating a TLS enabled Consul cluster</title><link>https://andydote.co.uk/2019/09/14/consul-tls-cluster/</link><pubDate>Sat, 14 Sep 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/09/14/consul-tls-cluster/</guid><description>This post is going to go through how to set up a Consul cluster to communicate over TLS. I will be using Vagrant to create three machines locally, which will form my cluster, and in the provisioning step will use Vault to generate the certificates needed.
How to securely communicate with Vault to get the TLS certificates is out of scope for this post.
Host Configuration Unless you already have Vault running somewhere on your network, or have another mechanism to generate TLS certificates for each machine, you&amp;rsquo;ll need to start and configure Vault on the Host machine.</description><content:encoded><![CDATA[<p>This post is going to go through how to set up a <a href="https://www.consul.io/">Consul</a> cluster to communicate over TLS.  I will be using <a href="https://www.vagrantup.com/">Vagrant</a> to create three machines locally, which will form my cluster, and in the provisioning step will use Vault to generate the certificates needed.</p>
<p>How to securely communicate with Vault to get the TLS certificates is out of scope for this post.</p>
<h2 id="host-configuration">Host Configuration</h2>
<p>Unless you already have Vault running somewhere on your network, or have another mechanism to generate TLS certificates for each machine, you&rsquo;ll need to start and configure Vault on the Host machine.  I am using my <a href="https://andydote.co.uk/2019/08/25/vault-development-ca/#creating-a-vault-intermediate-ca">Vault Dev Intermediate CA script from my previous post</a>.</p>
<p>To set this up, all I need to do is run this on the host machine, which starts Vault in a docker container, and configures it as an intermediate certificate authority:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./run_int.sh
</span></span></code></pre></div><p>I also have DNS on my network setup for the <code>tecra.xyz</code> domain so will be using that to test with.</p>
<h2 id="consul-machine-configuration">Consul Machine Configuration</h2>
<p>The <code>Vagrantfile</code> is very minimal - I am using my <a href="https://app.vagrantup.com/pondidum/boxes/hashibox">Hashibox</a> (be aware the <code>libvirt</code> provider for this might not work, for some reason <code>vagrant package</code> with libvirt produces a non-bootable box).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">Vagrant</span><span style="color:#f92672">.</span>configure(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>config<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>box <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pondidum/hashibox&#34;</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>provision <span style="color:#e6db74">&#34;consul&#34;</span>, <span style="color:#e6db74">type</span>: <span style="color:#e6db74">&#34;shell&#34;</span>, <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;./provision.sh&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;c1&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c1<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    c1<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;consul1&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;c2&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c2<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    c2<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;consul2&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;c3&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>c3<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    c3<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;consul3&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>The hashibox script already has all the tools we&rsquo;ll need installed already: Consul, Vault, and jq.</p>
<p>First up, we request a certificate from Vault to use for Consul - How you get this certificate in a secure manner in a production environment is up to you.  There is a catch-22 here for me, in that in a production environment I use Vault with Consul as it&rsquo;s backing store&hellip;but Consul needs Vault to start!  I&rsquo;ll go over how I get around this in a future post.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export VAULT_ADDR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://vault.tecra.xyz:8200&#34;</span>
</span></span><span style="display:flex;"><span>export VAULT_TOKEN<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;vault&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>response<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>vault write pki/issue/cert -format<span style="color:#f92672">=</span>json common_name<span style="color:#f92672">=</span>$HOSTNAME.tecra.xyz alt_names<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;server.dc1.consul&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>config_dir<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/etc/consul.d&#34;</span>
</span></span></code></pre></div><p>The first thing to note is that we have specified an <code>alt_names</code> for the certificate - you <em>must</em> have a SAN of <code>server.$DC.$DOMAIN</code> so either <code>server.dc1.consul</code> or <code>server.euwest1.tecra.xyz</code>, and the <code>server</code> prefix is required!.</p>
<p>Next, we need to take all the certificates from the response and write them to the filesystem.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir -p <span style="color:#e6db74">&#34;</span>$config_dir<span style="color:#e6db74">/ca&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span> i<span style="color:#f92672">=</span>0; i&lt;<span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> | jq <span style="color:#e6db74">&#39;.data.ca_chain | length&#39;</span><span style="color:#66d9ef">)</span>; i++ <span style="color:#f92672">))</span>; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  cert<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> | jq -r <span style="color:#e6db74">&#34;.data.ca_chain[</span>$i<span style="color:#e6db74">]&#34;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>  name<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>echo <span style="color:#e6db74">&#34;</span>$cert<span style="color:#e6db74">&#34;</span> | openssl x509 -noout -subject -nameopt multiline | sed -n <span style="color:#e6db74">&#39;s/ *commonName *= //p&#39;</span> | sed <span style="color:#e6db74">&#39;s/\s//g&#39;</span><span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  echo <span style="color:#e6db74">&#34;</span>$cert<span style="color:#e6db74">&#34;</span> &gt; <span style="color:#e6db74">&#34;</span>$config_dir<span style="color:#e6db74">/ca/</span>$name<span style="color:#e6db74">.pem&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> | jq -r .data.private_key &gt; $config_dir/consul.key
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> | jq -r .data.certificate &gt; $config_dir/consul.crt
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;</span>$response<span style="color:#e6db74">&#34;</span> | jq -r .data.issuing_ca &gt;&gt; $config_dir/consul.crt
</span></span></code></pre></div><p>The <code>for</code> loop iterates through all of the certificates returned in the <code>ca_chain</code> and writes them into a <code>ca</code> directory.  We use <code>openssl</code> to get the name of the certificate, so the files are named nicely!</p>
<p>Finally, it writes the <code>private_key</code> for the node&rsquo;s certificate to <code>consul.key</code>, and both the <code>certificate</code> and <code>issuing_ca</code> to  the <code>consul.crt</code> file.</p>
<p>Now for the <code>consul.json</code>.  To setup a secure cluster, first of all we need to add the certificate configuration, pointing to the files we wrote earlier:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;ca_path&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#e6db74">&#34;$config_dir/ca/&#34;</span><span style="color:#960050;background-color:#1e0010">,</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;cert_file&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#e6db74">&#34;$config_dir/consul.crt&#34;</span><span style="color:#960050;background-color:#1e0010">,</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#34;key_file&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> <span style="color:#e6db74">&#34;$config_dir/consul.key&#34;</span><span style="color:#960050;background-color:#1e0010">,</span>
</span></span></code></pre></div><p>We will also disable the HTTP port, and enable the HTTPS port:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span><span style="color:#e6db74">&#34;ports&#34;</span><span style="color:#960050;background-color:#1e0010">:</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;http&#34;</span>: <span style="color:#ae81ff">-1</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;https&#34;</span>: <span style="color:#ae81ff">8501</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally, we need to add some security settings.  First is <code>encrypt</code>, which sets that the key that all Consul nodes will use to encrypt their communications.  It must match on all nodes.  The easiest way to generate this is just run <code>consul keygen</code> and use the value that produces.</p>
<ul>
<li>
<p><code>&quot;encrypt&quot;: &quot;oNMJiPZRlaP8RnQiQo9p8MMK5RSJ+dXA2u+GjFm1qx8=&quot;</code>:</p>
<p>The key the cluster will use to encrypt all it&rsquo;s traffic.  It must be the same on all nodes, and the easiest way to generate the value is to use the output of <code>consul keygen</code>.</p>
</li>
<li>
<p><code>&quot;verify_outgoing&quot;: true</code>:</p>
<p>All the traffic leaving this node will be encrypted with the TLS certificates.  However, the node will still accept non-TLS traffic.</p>
</li>
<li>
<p><code>&quot;verify_incoming_rpc&quot;: true</code>:</p>
<p>All the gossip traffic arriving at this node must be signed with an authority in the <code>ca_path</code>.</p>
</li>
<li>
<p><code>&quot;verify_incoming_https&quot;: false</code>:</p>
<p>We are going to use the Consul Web UI, so we want to allow traffic to hit the API without a client certificate.  If you are using the UI from a non-server node, you can set this to <code>true</code>.</p>
</li>
<li>
<p><code>&quot;verify_server_hostname&quot;: true</code>:</p>
<p>Set Consul to verify <strong>outgoing</strong> connections have a hostname in the format of <code>server.&lt;datacenter&gt;.&lt;domain&gt;</code>.  From the <a href="https://www.consul.io/docs/agent/options.html#verify_server_hostname">docs</a>: &ldquo;This setting is critical to prevent a compromised client from being restarted as a server and having all cluster state including all ACL tokens and Connect CA root keys replicated to it&rdquo;</p>
</li>
</ul>
<p>The complete config we will use is listed here:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#e6db74">&lt;&lt;-EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;bootstrap_expect&#34;: 3,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;client_addr&#34;: &#34;0.0.0.0&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;data_dir&#34;: &#34;/var/consul&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;leave_on_terminate&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;rejoin_after_leave&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;retry_join&#34;: [&#34;consul1&#34;, &#34;consul2&#34;, &#34;consul3&#34;],
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;server&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;ui&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;encrypt&#34;: &#34;oNMJiPZRlaP8RnQiQo9p8MMK5RSJ+dXA2u+GjFm1qx8=&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;verify_incoming_rpc&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;verify_incoming_https&#34;: false,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;verify_outgoing&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;verify_server_hostname&#34;: true,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;ca_path&#34;: &#34;$config_dir/ca/&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;cert_file&#34;: &#34;$config_dir/consul.crt&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;key_file&#34;: &#34;$config_dir/consul.key&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;ports&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;http&#34;: -1,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;https&#34;: 8501
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    }
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span> | sudo tee $config_dir/consul.json
</span></span></code></pre></div><p>Lastly, we&rsquo;ll make a systemd service unit to start consul:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#e6db74">&lt;&lt;-EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Unit]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Description=consul agent
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Requires=network-online.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">After=network-online.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Service]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Restart=on-failure
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">ExecStart=/usr/bin/consul agent -config-file=$config_dir/consul.json -bind &#39;{{ GetInterfaceIP &#34;eth0&#34; }}&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">ExecReload=/bin/kill -HUP $MAINPID
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">[Install]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">WantedBy=multi-user.target
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span> | sudo tee /etc/systemd/system/consul.service
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo systemctl daemon-reload
</span></span><span style="display:flex;"><span>sudo systemctl enable consul.service
</span></span><span style="display:flex;"><span>sudo systemctl start consul
</span></span></code></pre></div><p>As the machines we are starting also have docker networks (and potentially others), our startup line specifies to bind to the <code>eth0</code> network, using a Consul Template.</p>
<h2 id="running">Running</h2>
<p>First, we need to run our intermediate CA, then provision our three machines:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./run_int.sh
</span></span><span style="display:flex;"><span>vagrant up
</span></span></code></pre></div><p>After a few moments, you should be able to <code>curl</code> the consul ui (<code>curl https://consul1.tecra.xyz:8501</code>) or open <code>https://consul1.tecra.xyz:8501</code> in your browser.</p>
<p>Note, however, the if your root CA is self-signed, like mine is, some browsers (such as FireFox) won&rsquo;t trust it, as they won&rsquo;t use your machine&rsquo;s Trusted Certificate Store, but their own in built store.  You can either accept the warning or add your root certificate to the browser&rsquo;s store.</p>
<h2 id="testing">Testing</h2>
<p>Now that we have our cluster seemingly running with TLS, what happens if we try to connect a Consul client <em>without</em> TLS to it?  On the host machine, I just run a single node, and tell it to connect to one of the cluster nodes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>consul agent <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -join consul1.tecra.xyz <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -bind <span style="color:#e6db74">&#39;{{ GetInterfaceIP &#34;eth0&#34; }}&#39;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -data-dir /tmp/consul
</span></span></code></pre></div><p>The result of this is a refusal to connect, as the cluster has TLS configured, but this instance does not:</p>
<pre tabindex="0"><code>==&gt; Starting Consul agent...
==&gt; Log data will now stream in as it occurs:
==&gt; Joining cluster...
==&gt; 1 error occurred:
  * Failed to join 192.168.121.231: Remote state is encrypted and encryption is not configured
</code></pre><p>Success!</p>
<p>In the next post, I&rsquo;ll go through how we can set up a Vault cluster which stores its data in Consul, but also provision that same Consul cluster with certificates from the Vault instance!</p>
]]></content:encoded></item><item><title>Canary Routing with Traefik in Nomad</title><link>https://andydote.co.uk/2019/06/23/nomad-traefik-canary/</link><pubDate>Sun, 23 Jun 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/06/23/nomad-traefik-canary/</guid><description>I wanted to implement canary routing for some HTTP services deployed via Nomad the other day, but rather than having the traffic split by weighting to the containers, I wanted to direct the traffic based on a header.
My first choice of tech was to use Fabio, but it only supports routing by URL prefix, and additionally with a route weight. While I was at JustDevOps in Poland, I heard about another router/loadbalancer which worked in a similar way to Fabio: Traefik.</description><content:encoded><![CDATA[<p>I wanted to implement canary routing for some HTTP services deployed via <a href="https://www.nomadproject.io/">Nomad</a> the other day, but rather than having the traffic split by weighting to the containers, I wanted to direct the traffic based on a header.</p>
<p>My first choice of tech was to use <a href="https://fabiolb.net/">Fabio</a>, but it only supports routing by URL prefix, and additionally with a route weight.  While I was at <a href="https://justdevops.org/">JustDevOps</a> in Poland, I heard about another router/loadbalancer which worked in a similar way to Fabio: <a href="https://traefik.io/">Traefik</a>.</p>
<p>While Traefik also doesn&rsquo;t directly support canary routing, it is much more flexible than Fabio, also allowing request filtering based on HTTP headers.  Traefik integrates with a number of container schedulers directly, but Nomad is not one of them.  It does however also support using the Consul Service Catalog so that you can use it as an almost drop-in replacement for Fabio.</p>
<p>So let&rsquo;s get to the setup.  As usual, there is a complete repository on GitHub: <a href="https://github.com/Pondidum/nomad-traefik-canary-demo">Nomad Traefik Canary Routing</a>.</p>
<h2 id="nomad">Nomad</h2>
<p>As usual, I am using my <a href="https://github.com/Pondidum/hashibox">Hashibox</a> <a href="https://vagrantup.com/">Vagrant</a> base image, and provisioning it as a single Nomad server and client node, using <a href="https://github.com/Pondidum/nomad-traefik-canary-demo/blob/master/scripts/server.sh">this script</a>.  I won&rsquo;t dig into all the setup in that, as I&rsquo;ve written it a few times now.</p>
<h2 id="consul">Consul</h2>
<p>Consul is already running on the Hashibox base, so we have no further configuration to do.</p>
<h2 id="traefik">Traefik</h2>
<p>Traefik can be deployed as a Docker container, and either configured through a TOML file (yay, <a href="https://noyaml.com/">not yaml!</a>) or with command line switches.  As we only need a minimal configuration, I opted to use the command line.</p>
<p>The container exposes two ports we need to care about: <code>80</code> for incoming traffic to be routed, and <code>8080</code> for the UI, which are statically allocated to the host as <code>8000</code> and <code>8080</code> for this demo.</p>
<p>The command line configuration used is as follows:</p>
<ul>
<li><code>--api</code> - enable the UI.</li>
<li><code>--consulcatalog</code> - Traefik has two ways to use Consul - <code>--consul</code> uses the KV store for service definitions, and <code>--consulcatalog</code> makes use Consul&rsquo;s service catalogue.</li>
<li><code>--consulcatalog.endpoint=consul.service.consul:8500</code> as Consul is not running in the same container as Traefik, we need to tell it where Consul is listening, and as we have <a href="">DNS Forwarding for <code>*.consul</code> domains</a>, we use the address <code>consul.service.consul</code>.  If DNS forwarding was not available, you could use the Nomad variable <code>${attr.unique.network.ip-address}</code> to get the current task&rsquo;s host&rsquo;s IP.</li>
<li><code>--consulcatalog.frontEndRule</code> disable the default rule - each service needs to specify <code>traefik.frontend.rule</code>.</li>
<li><code>--consulcatalog.exposedByDefault=false</code> - lastly, we stop Traefik showing all services registered into consul, the will need to have the <code>traefik.enable=true</code> tag to be processed.</li>
</ul>
<p>The entire job file is listed below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>job <span style="color:#e6db74">&#34;traefik&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  datacenters <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;dc1&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;service&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  group <span style="color:#e6db74">&#34;loadbalancers&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    task <span style="color:#e6db74">&#34;traefik&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      driver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;docker&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      config <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        image <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;traefik:1.7.12&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        args <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--api&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--consulcatalog&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--consulcatalog.endpoint=consul.service.consul:8500&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--consulcatalog.frontEndRule=&#39;&#39;&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;--consulcatalog.exposedByDefault=false&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        port_map <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          http <span style="color:#f92672">=</span> <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>          ui <span style="color:#f92672">=</span> <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      resources <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        network <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;http&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">8000</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;ui&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">8080</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        memory <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>We register the job into Nomad, and then start on the backend services we will route to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nomad job run jobs/traefik.nomad
</span></span></code></pre></div><h2 id="the-backend-services">The Backend Services</h2>
<p>To demonstrate the services can be routed to correctly, we can use the <code>containersol/k8s-deployment-strategies</code> docker container.  This image exposes an HTTP service which responds with the container&rsquo;s hostname and the content of the <code>VERSION</code> environment variable, something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ curl http://echo.service.consul:8080
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Host: 23351e48dc98, Version: 1.0.0</span>
</span></span></code></pre></div><p>We&rsquo;ll start by making a standard nomad job for this container, and then update it to support canarying.  The entire job is listed below:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>job <span style="color:#e6db74">&#34;echo&#34;</span> {
</span></span><span style="display:flex;"><span>  datacenters <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;dc1&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;service&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  group <span style="color:#e6db74">&#34;apis&#34;</span> {
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    task <span style="color:#e6db74">&#34;echo&#34;</span> {
</span></span><span style="display:flex;"><span>      driver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;docker&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      config {
</span></span><span style="display:flex;"><span>        image <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;containersol/k8s-deployment-strategies&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        port_map {
</span></span><span style="display:flex;"><span>          http <span style="color:#f92672">=</span> <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      env {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">VERSION</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1.0.0&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      resources {
</span></span><span style="display:flex;"><span>        network {
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;http&#34;</span> { }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      service {
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;echo&#34;</span>
</span></span><span style="display:flex;"><span>        port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        tags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.enable=true&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.frontend.rule=Host:api.localhost&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        check {
</span></span><span style="display:flex;"><span>          type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>          path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>          interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>          timeout <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1s&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The only part of interest in this version of the job is the <code>service</code> stanza, which is registering our echo service into consul, with a few tags to control how it is routed by Traefik:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>service {
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;echo&#34;</span>
</span></span><span style="display:flex;"><span>  port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  tags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;traefik.enable=true&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;traefik.frontend.rule=Host:api.localhost&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  check {
</span></span><span style="display:flex;"><span>    type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>    interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>    timeout <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1s&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>traefik.enabled=true</code> tag allows this service to be handled by Traefik (as we set <code>exposedByDefault=false</code> in Traefik), and <code>traefik.frontend.rule=Host:api.localhost</code> the rule means that any traffic with the <code>Host</code> header set to <code>api.localhost</code> will be routed to the service.</p>
<p>Which we can now run the job in Nomad:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nomad job run jobs/echo.nomad
</span></span></code></pre></div><p>Once it is up and running, we&rsquo;ll get 3 instances of <code>echo</code> running which will be round-robin routed by Traefik:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: 1ac8a49cbaee, Version: 1.0.0</span>
</span></span><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: 23351e48dc98, Version: 1.0.0</span>
</span></span><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: c2f8a9dcab95, Version: 1.0.0</span>
</span></span></code></pre></div><p>Now that we have working routing for the Echo service let&rsquo;s make it canaryable.</p>
<h2 id="canaries">Canaries</h2>
<p>To show canary routing, we will create a second version of the service to respond to HTTP traffic with a <code>Canary</code> header.</p>
<p>The first change to make is to add in the <code>update</code> stanza, which controls how the containers get updated when Nomad pushes a new version.  The <code>canary</code> parameter controls how many instances of the task will be created for canary purposes (and must be less than the total number of containers).  Likewise, the <code>max_parallel</code> parameter controls how many containers will be replaced at a time when a deployment happens.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>group &#34;apis&#34; {
</span></span><span style="display:flex;"><span>  count = 3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  update {
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    max_parallel = 1
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    canary = 1
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  }
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>
</span></span><span style="display:flex;"><span>  task &#34;echo&#34; {
</span></span></code></pre></div><p>Next, we need to modify the <code>service</code> stanza to write different tags to Consul when a task is a canary instance so that it does not get included in the &ldquo;normal&rdquo; backend routing group.</p>
<p>If we don&rsquo;t specify at least 1 value in <code>canary_tags</code>, Nomad will use the <code>tags</code> even in the canary version - an empty <code>canary_tags = []</code> declaration is not enough!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>service {
</span></span><span style="display:flex;"><span>  name = &#34;echo&#34;
</span></span><span style="display:flex;"><span>  port = &#34;http&#34;
</span></span><span style="display:flex;"><span>  tags = [
</span></span><span style="display:flex;"><span>    &#34;traefik.enable=true&#34;,
</span></span><span style="display:flex;"><span>    &#34;traefik.frontend.rule=Host:api.localhost&#34;
</span></span><span style="display:flex;"><span>  ]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  canary_tags = [
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+    &#34;traefik.enable=false&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">+  ]
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>  check {
</span></span></code></pre></div><p>Finally, we need to add a separate <code>service</code> stanza to create a second backend group which will contain the canary versions.  Note how this group has a different name, and has no <code>tags</code>, but does have a set of <code>canary_tags</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>service {
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;echo-canary&#34;</span>
</span></span><span style="display:flex;"><span>  port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>  tags <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>
</span></span><span style="display:flex;"><span>  canary_tags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;traefik.enable=true&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;traefik.frontend.rule=Host:api.localhost;Headers: Canary,true&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  check {
</span></span><span style="display:flex;"><span>    type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>    interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>    timeout <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1s&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The reason we need two <code>service</code> stanzas is that Traefik can only create backends based on the name of the service registered to Consul and not from a tag in that registration.  If we just used one <code>service</code> stanza, then the canary version of the container would be added to both the canary backend and standard backend.  I was hoping for <code>traefik.backend=echo-canary</code> to work, but alas no.</p>
<p>The entire updated jobfile is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>job <span style="color:#e6db74">&#34;echo&#34;</span> {
</span></span><span style="display:flex;"><span>  datacenters <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;dc1&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;service&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  group <span style="color:#e6db74">&#34;apis&#34;</span> {
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    update {
</span></span><span style="display:flex;"><span>      max_parallel <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>      canary <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    task <span style="color:#e6db74">&#34;echo&#34;</span> {
</span></span><span style="display:flex;"><span>      driver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;docker&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      config {
</span></span><span style="display:flex;"><span>        image <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;containersol/k8s-deployment-strategies&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        port_map {
</span></span><span style="display:flex;"><span>          http <span style="color:#f92672">=</span> <span style="color:#ae81ff">8080</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      env {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">VERSION</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1.0.0&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      resources {
</span></span><span style="display:flex;"><span>        network {
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;http&#34;</span> { }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        memory <span style="color:#f92672">=</span> <span style="color:#ae81ff">50</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      service {
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;echo-canary&#34;</span>
</span></span><span style="display:flex;"><span>        port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        tags <span style="color:#f92672">=</span> <span style="color:#f92672">[]</span>
</span></span><span style="display:flex;"><span>        canary_tags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.enable=true&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.frontend.rule=Host:api.localhost;Headers: Canary,true&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        check {
</span></span><span style="display:flex;"><span>          type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>          path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>          interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>          timeout <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1s&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      service {
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;echo&#34;</span>
</span></span><span style="display:flex;"><span>        port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        tags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.enable=true&#34;</span>,
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.frontend.rule=Host:api.localhost&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>        canary_tags <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>          <span style="color:#e6db74">&#34;traefik.enable=false&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        check {
</span></span><span style="display:flex;"><span>          type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http&#34;</span>
</span></span><span style="display:flex;"><span>          path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>          interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>          timeout <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1s&#34;</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="testing">Testing</h2>
<p>First, we will change the <code>VERSION</code> environment variable so that Nomad sees the job as changed, and we get a different response from HTTP calls to the canary:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span>env {
</span></span><span style="display:flex;"><span><span style="color:#f92672">-  VERSION = &#34;1.0.0&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#f92672"></span><span style="color:#a6e22e">+  VERSION = &#34;2.0.0&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e"></span>}
</span></span></code></pre></div><p>Now we will update the job in Nomad:</p>
<pre tabindex="0"><code>nomad job run jobs/echo.nomad
</code></pre><p>If we run the status command, we can see that the deployment has started, and there is one canary instance running.  Nothing further will happen until we promote it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ nomad status echo
</span></span><span style="display:flex;"><span>ID            <span style="color:#f92672">=</span> echo
</span></span><span style="display:flex;"><span>Status        <span style="color:#f92672">=</span> running
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Latest Deployment
</span></span><span style="display:flex;"><span>ID          <span style="color:#f92672">=</span> 330216b9
</span></span><span style="display:flex;"><span>Status      <span style="color:#f92672">=</span> running
</span></span><span style="display:flex;"><span>Description <span style="color:#f92672">=</span> Deployment is running but requires promotion
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Deployed
</span></span><span style="display:flex;"><span>Task Group  Promoted  Desired  Canaries  Placed  Healthy  Unhealthy  Progress Deadline
</span></span><span style="display:flex;"><span>apis        false     <span style="color:#ae81ff">3</span>        <span style="color:#ae81ff">1</span>         <span style="color:#ae81ff">1</span>       <span style="color:#ae81ff">1</span>        <span style="color:#ae81ff">0</span>          2019-06-19T11:19:31Z
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Allocations
</span></span><span style="display:flex;"><span>ID        Node ID   Task Group  Version  Desired  Status   Created    Modified
</span></span><span style="display:flex;"><span>dcff2555  82f6ea8b  apis        <span style="color:#ae81ff">1</span>        run      running  18s ago    2s ago
</span></span><span style="display:flex;"><span>5b2710ed  82f6ea8b  apis        <span style="color:#ae81ff">0</span>        run      running  6m52s ago  6m26s ago
</span></span><span style="display:flex;"><span>698bd8a7  82f6ea8b  apis        <span style="color:#ae81ff">0</span>        run      running  6m52s ago  6m27s ago
</span></span><span style="display:flex;"><span>b315bcd3  82f6ea8b  apis        <span style="color:#ae81ff">0</span>        run      running  6m52s ago  6m25s ago
</span></span></code></pre></div><p>We can now test that the original containers still work, and that the canary version works:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: 1ac8a49cbaee, Version: 1.0.0</span>
</span></span><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: 23351e48dc98, Version: 1.0.0</span>
</span></span><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: c2f8a9dcab95, Version: 1.0.0</span>
</span></span><span style="display:flex;"><span>$ curl http://traefik.service.consul:8080 -H <span style="color:#e6db74">&#39;Host: api.localhost&#39;</span> -H <span style="color:#e6db74">&#39;Canary: true&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#Host: 496840b438f2, Version: 2.0.0</span>
</span></span></code></pre></div><p>Assuming we are happy with our new version, we can tell Nomad to promote the deployment, which will remove the canary and start a rolling update of the three tasks, one at a time:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nomad deployment promote 330216b9
</span></span></code></pre></div><h2 id="end">End</h2>
<p>My hope is that the next version of Traefik will have better support for canary by header, meaning I could simplify the Nomad jobs a little, but as it stands, this doesn&rsquo;t add much complexity to the jobs, and can be easily put into an Architecture Decision Record (or documented in a wiki page, never to be seen or read from again!)</p>
]]></content:encoded></item><item><title>Configuring Consul DNS Forwarding in Alpine Linux</title><link>https://andydote.co.uk/2019/05/31/consul-dns-forwarding-alpine/</link><pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/05/31/consul-dns-forwarding-alpine/</guid><description>DEPRECATED - This has a race condition! Please see this post for an updated version which works!
Following on from the post the other day on setting up DNS forwarding to Consul with SystemD, I wanted also to show how to get Consul up and running under Alpine Linux, as it&amp;rsquo;s a little more awkward in some respects.
To start with, I am going to setup Consul as a service - I didn&amp;rsquo;t do this in the Ubuntu version, as there are plenty of useful articles about that already, but that is not the case with Alpine.</description><content:encoded><![CDATA[<h1 id="deprecated---this-has-a-race-condition">DEPRECATED - This has a race condition!</h1>
<p><a href="/2019/12/30/consul-alpine-dns-revisited/">Please see this post for an updated version which works!</a></p>
<p>Following on from the post the other day on setting up <a href="/2019/05/29/consul-dns-forwarding/">DNS forwarding to Consul with SystemD</a>, I wanted also to show how to get Consul up and running under <a href="https://www.alpinelinux.org/">Alpine Linux</a>, as it&rsquo;s a little more awkward in some respects.</p>
<p>To start with, I am going to setup Consul as a service - I didn&rsquo;t do this in the Ubuntu version, as there are plenty of useful articles about that already, but that is not the case with Alpine.</p>
<h2 id="run-consul">Run Consul</h2>
<p>First, we need to get a version of Consul and install it into our system.  This script downloads <code>1.5.1</code> from Hashicorp&rsquo;s releases site, installs it to <code>/usr/bin/consul</code>, and creates a <code>consul</code> user and group to run the daemon with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>CONSUL_VERSION<span style="color:#f92672">=</span>1.5.1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>curl -sSL https://releases.hashicorp.com/consul/<span style="color:#e6db74">${</span>CONSUL_VERSION<span style="color:#e6db74">}</span>/consul_<span style="color:#e6db74">${</span>CONSUL_VERSION<span style="color:#e6db74">}</span>_linux_amd64.zip -o /tmp/consul.zip
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>unzip /tmp/consul.zip
</span></span><span style="display:flex;"><span>sudo install consul /usr/bin/consul
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo addgroup -S consul
</span></span><span style="display:flex;"><span>sudo adduser -S -D -h /var/consul -s /sbin/nologin -G consul -g consul consul
</span></span></code></pre></div><p>Next, we need to create the directories for the configuration and data to live in, and copy the init script and configuration file to those directories:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>consul_dir<span style="color:#f92672">=</span>/etc/consul
</span></span><span style="display:flex;"><span>data_dir<span style="color:#f92672">=</span>/srv/consul
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo mkdir $consul_dir
</span></span><span style="display:flex;"><span>sudo mkdir $data_dir
</span></span><span style="display:flex;"><span>sudo chown consul:consul $data_dir
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo mv /tmp/consul.sh /etc/init.d/consul
</span></span><span style="display:flex;"><span>sudo chmod +x /etc/init.d/consul
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo mv /tmp/consul.json $consul_dir/consul.json
</span></span></code></pre></div><p>The init script is pretty straight forward, but note that I am running the agent in this example in <code>dev</code> mode; <strong>don&rsquo;t do this in production</strong>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#!/sbin/openrc-run
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>CONSUL_LOG_FILE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/var/log/</span><span style="color:#e6db74">${</span>SVCNAME<span style="color:#e6db74">}</span><span style="color:#e6db74">.log&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>name<span style="color:#f92672">=</span>consul
</span></span><span style="display:flex;"><span>description<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;A tool for service discovery, monitoring and configuration&#34;</span>
</span></span><span style="display:flex;"><span>description_checkconfig<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Verify configuration file&#34;</span>
</span></span><span style="display:flex;"><span>daemon<span style="color:#f92672">=</span>/usr/bin/$name
</span></span><span style="display:flex;"><span>daemon_user<span style="color:#f92672">=</span>$name
</span></span><span style="display:flex;"><span>daemon_group<span style="color:#f92672">=</span>$name
</span></span><span style="display:flex;"><span>consul_dir<span style="color:#f92672">=</span>/etc/consul
</span></span><span style="display:flex;"><span>extra_commands<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;checkconfig&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start_pre<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    checkpath -f -m <span style="color:#ae81ff">0644</span> -o <span style="color:#e6db74">${</span>SVCNAME<span style="color:#e6db74">}</span>:<span style="color:#e6db74">${</span>SVCNAME<span style="color:#e6db74">}</span> <span style="color:#e6db74">&#34;</span>$CONSUL_LOG_FILE<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>depend<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    need net
</span></span><span style="display:flex;"><span>    after firewall
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>checkconfig<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    consul validate $consul_dir
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    checkconfig <span style="color:#f92672">||</span> <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ebegin <span style="color:#e6db74">&#34;Starting </span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        start-stop-daemon --start --quiet <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            -m --pidfile /var/run/<span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span>.pid <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            --user <span style="color:#e6db74">${</span>daemon_user<span style="color:#e6db74">}</span> --group <span style="color:#e6db74">${</span>daemon_group<span style="color:#e6db74">}</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            -b --stdout $CONSUL_LOG_FILE --stderr $CONSUL_LOG_FILE <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            -k <span style="color:#ae81ff">027</span> --exec <span style="color:#e6db74">${</span>daemon<span style="color:#e6db74">}</span> -- agent -dev -config-dir<span style="color:#f92672">=</span>$consul_dir
</span></span><span style="display:flex;"><span>    eend $?
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stop<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    ebegin <span style="color:#e6db74">&#34;Stopping </span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        start-stop-daemon --stop --quiet <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            --pidfile /var/run/<span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span>.pid <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>            --exec <span style="color:#e6db74">${</span>daemon<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span>    eend $?
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>Finally, a basic config file to launch consul is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;data_dir&#34;</span>: <span style="color:#e6db74">&#34;/srv/consul/data&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&#34;client_addr&#34;</span>: <span style="color:#e6db74">&#34;0.0.0.0&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now that all our scripts are in place, we can register Consul into the service manager, and start it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>sudo rc-update add consul
</span></span><span style="display:flex;"><span>sudo rc-service consul start
</span></span></code></pre></div><p>You can check consul is up and running by using <code>dig</code> to get the address of the consul service itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dig @localhost -p <span style="color:#ae81ff">8600</span> consul.service.consul
</span></span></code></pre></div><h2 id="setup-local-dns-with-unbound">Setup Local DNS with Unbound</h2>
<p>Now that Consul is running, we need to configure a local DNS resolver to forward requests for the <code>.consul</code> domain to Consul.  We will use <a href="https://nlnetlabs.nl/projects/unbound/about/">Unbound</a> as it works nicely on Alpine.  It also has the wonderful feature of being able to send queries to a specific port, so no <code>iptables</code> rules needed this time!</p>
<p>The config file (<code>/etc/unbound/unbound.conf</code>) is all default values, with the exception of the last 5 lines, which let us forward DNS requests to a custom, and insecure, location:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#! /bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>sudo apk add unbound
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#e6db74">&lt;&lt;-EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">server:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    verbosity: 1
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    root-hints: /etc/unbound/root.hints
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    trust-anchor-file: &#34;/usr/share/dnssec-root/trusted-key.key&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    do-not-query-localhost: no
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    domain-insecure: &#34;consul&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">stub-zone:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    name: &#34;consul&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    stub-addr: 127.0.0.1@8600
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span> | sudo tee /etc/unbound/unbound.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo rc-update add unbound
</span></span><span style="display:flex;"><span>sudo rc-service unbound start
</span></span></code></pre></div><p>We can validate this works again by using <code>dig</code>, but this time removing the port specification to hit <code>53</code> instead:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>dig @localhost consul.service.consul
</span></span></code></pre></div><h2 id="configure-dns-resolution">Configure DNS Resolution</h2>
<p>Finally, we need to update <code>/etc/resolv.conf</code> so that other system tools such as <code>ping</code> and <code>curl</code> can resolve <code>.consul</code> addresses.  This is a little more hassle on Alpine, as there are no <code>head</code> files we can push our nameserver entry into.  Instead, we use <code>dhclient</code> which will let us prepend a custom nameserver (or multiple) when the interface is brought up, even when using DHCP:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#! /bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>sudo apk add dhclient
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">(</span>
</span></span><span style="display:flex;"><span>cat <span style="color:#e6db74">&lt;&lt;-EOF
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">send host-name = gethostname();
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">request subnet-mask, broadcast-address, time-offset, routers,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        domain-name, domain-name-servers, domain-search, host-name,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        dhcp6.name-servers, dhcp6.domain-search, dhcp6.fqdn, dhcp6.sntp-servers,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        netbios-name-servers, netbios-scope, interface-mtu,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        rfc3442-classless-static-routes, ntp-servers;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">prepend domain-name-servers 127.0.0.1;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOF</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">)</span> | sudo tee /etc/dhcp/dhclient.conf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo rm /etc/resolv.conf <span style="color:#75715e"># hack due to it dhclient making an invalid `chown` call.</span>
</span></span><span style="display:flex;"><span>sudo rc-service networking restart
</span></span></code></pre></div><p>The only thing of interest here is the little hack: we delete the <code>/etc/resolv.conf</code> before restarting the networking service, as if you don&rsquo;t do this, you get errors about &ldquo;chmod invalid option resource=&hellip;&rdquo;.</p>
<p>We can varify everything works in the same way we did on Ubuntu; <code>curl</code> to both a <code>.consul</code> and a public address:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ curl -s -o /dev/null -w <span style="color:#e6db74">&#34;%{http_code}\n&#34;</span> http://consul.service.consul:8500/ui/
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ curl -s -o /dev/null -w <span style="color:#e6db74">&#34;%{http_code}\n&#34;</span> http://google.com
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">301</span>
</span></span></code></pre></div><h2 id="end">End</h2>
<p>This was a bit easier to get started with than the Ubuntu version as I knew what I was trying to accomplish this time - however making a good <code>init.d</code> script was a bit more hassle, and the error from <code>chmod</code> took some time to track down.</p>
]]></content:encoded></item><item><title>Configuring Consul DNS Forwarding in Ubuntu 16.04</title><link>https://andydote.co.uk/2019/05/29/consul-dns-forwarding/</link><pubDate>Wed, 29 May 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/05/29/consul-dns-forwarding/</guid><description>DEPRECATED - This doesn&amp;rsquo;t work properly Please see this post for an updated version which works!
One of the advantages of using Consul for service discovery is that besides an HTTP API, you can also query it by DNS.
The DNS server is listening on port 8600 by default, and you can query both A records or SRV records from it. SRV records are useful as they contain additional properties (priority, weight and port), and you can get multiple records back from a single query, letting you do load balancing client side:</description><content:encoded><![CDATA[<h1 id="deprecated---this-doesnt-work-properly">DEPRECATED - This doesn&rsquo;t work properly</h1>
<p><a href="/2019/09/24/consul-ubuntu-dns-revisited/">Please see this post for an updated version which works!</a></p>
<hr>
<p>One of the advantages of using <a href="https://www.consul.io/">Consul</a> for service discovery is that besides an HTTP API, you can also query it by DNS.</p>
<p>The DNS server is listening on port <code>8600</code> by default, and you can query both A records or SRV records from it.  <a href="https://en.wikipedia.org/wiki/SRV_record">SRV</a> records are useful as they contain additional properties (<code>priority</code>, <code>weight</code> and <code>port</code>), and you can get multiple records back from a single query, letting you do load balancing client side:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ dig @localhost -p <span style="color:#ae81ff">8600</span> consul.service.consul SRV +short
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">8300</span> vagrant1.node.dc1.consul.
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#ae81ff">14</span> <span style="color:#ae81ff">8300</span> vagrant2.node.dc1.consul.
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span> <span style="color:#ae81ff">100</span> <span style="color:#ae81ff">8300</span> vagrant3.node.dc1.consul.
</span></span></code></pre></div><p>A Records are also useful, as it means we should be able to treat services registered to Consul like any other domain - but it doesn&rsquo;t work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ curl http://consul.service.consul:8500
</span></span><span style="display:flex;"><span>curl: <span style="color:#f92672">(</span>6<span style="color:#f92672">)</span> Could not resolve host: consul.service.consul
</span></span></code></pre></div><p>The reason for this is that the system&rsquo;s built-in DNS resolver doesn&rsquo;t know how to query Consul.  We can, however, configure it to forward any <code>*.consul</code> requests to Consul.</p>
<h2 id="solution---forward-dns-queries-to-consul">Solution - Forward DNS queries to Consul</h2>
<p>As I usually target Ubuntu based machines, this means configuring <code>systemd-resolved</code> to forward to Consul.  However, we want to keep Consul listening on it&rsquo;s default port (<code>8600</code>), and <code>systemd-resolved</code> can only forward requests to port <code>53</code>, so we need also to configure <code>iptables</code> to redirect the requests.</p>
<p>The steps are as follows:</p>
<ol>
<li>Configure <code>systemd-resolved</code> to forward <code>.consul</code> TLD queries to the local consul agent</li>
<li>Configure <code>iptables</code> to redirect <code>53</code> to <code>8600</code></li>
</ol>
<p>So let&rsquo;s get to it!</p>
<h3 id="1-make-iptables-persistent">1. Make iptables persistent</h3>
<p>IPTables configuration changes don&rsquo;t persist through reboots, so the easiest way to solve this is with the <code>iptables-persistent</code> package.</p>
<p>Typically I am scripting machines (using [Packer] or [Vagrant]), so I configure the install to be non-interactive:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo iptables-persistent iptables-persistent/autosave_v4 boolean false | sudo debconf-set-selections
</span></span><span style="display:flex;"><span>echo iptables-persistent iptables-persistent/autosave_v6 boolean false | sudo debconf-set-selections
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo DEBIAN_FRONTEND<span style="color:#f92672">=</span>noninteractive apt install -yq iptables-persistent
</span></span></code></pre></div><h3 id="2-update-systemd-resolved">2. Update Systemd-Resolved</h3>
<p>The file to change is <code>/etc/systemd/resolved.conf</code>.  By default it looks like this:</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">[Resolve]
#DNS=
#FallbackDNS=8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844
#Domains=
#LLMNR=yes
#DNSSEC=no
</code></pre><p>We need to change the <code>DNS</code> and <code>Domains</code> lines - either editing the file by hand, or scripting a replacement with <code>sed</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo sed -i <span style="color:#e6db74">&#39;s/#DNS=/DNS=127.0.0.1/g; s/#Domains=/Domains=~consul/g&#39;</span> /etc/systemd/resolved.conf
</span></span></code></pre></div><p>The result of which is the file now reading like this:</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">[Resolve]
DNS=127.0.0.1
#FallbackDNS=8.8.8.8 8.8.4.4 2001:4860:4860::8888 2001:4860:4860::8844
Domains=~consul
#LLMNR=yes
#DNSSEC=no
</code></pre><p>By specifying the <code>Domains</code> as <code>~consul</code>, we are telling resolvd to forward requests for the <code>consul</code> TLD to the server specified in the <code>DNS</code> line.</p>
<h3 id="3-configure-resolvconf-too">3. Configure Resolvconf too</h3>
<p>For compatibility with some applications (e.g. <code>curl</code> and <code>ping</code>), we also need to update <code>/etc/resolv.conf</code> to specify our local nameserver.  You do this <strong>not</strong> by editing the file directly!</p>
<p>Instead, we need to add <code>nameserver 127.0.0.1</code> to <code>/etc/resolvconf/resolv.conf.d/head</code>.  Again, I will script this, and as we need <code>sudo</code> to write to the file, the easiest way is to use <code>tee</code> to append the line and then run <code>resolvconf -u</code> to apply the change:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>echo <span style="color:#e6db74">&#34;nameserver 127.0.0.1&#34;</span> | sudo tee --append /etc/resolvconf/resolv.conf.d/head
</span></span><span style="display:flex;"><span>sudo resolvconf -u
</span></span></code></pre></div><h3 id="configure-iptables">Configure iptables</h3>
<p>Finally, we need to configure iptables so that when <code>systemd-resolved</code> sends a DNS query to localhost on port <code>53</code>, it gets redirected to port <code>8600</code>.  We&rsquo;ll do this for both TCP and UDP requests, and then use <code>netfilter-persistent</code> to make the rules persistent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo iptables -t nat -A OUTPUT -d localhost -p udp -m udp --dport <span style="color:#ae81ff">53</span> -j REDIRECT --to-ports <span style="color:#ae81ff">8600</span>
</span></span><span style="display:flex;"><span>sudo iptables -t nat -A OUTPUT -d localhost -p tcp -m tcp --dport <span style="color:#ae81ff">53</span> -j REDIRECT --to-ports <span style="color:#ae81ff">8600</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo netfilter-persistent save
</span></span></code></pre></div><h2 id="verification">Verification</h2>
<p>First, we can test that both Consul and Systemd-Resolved return an address for a consul service:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ dig @localhost -p <span style="color:#ae81ff">8600</span> consul.service.consul +short
</span></span><span style="display:flex;"><span>10.0.2.15
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ dig @localhost consul.service.consul +short
</span></span><span style="display:flex;"><span>10.0.2.15
</span></span></code></pre></div><p>And now we can try using <code>curl</code> to verify that we can resolve consul domains and normal domains still:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ curl -s -o /dev/null -w <span style="color:#e6db74">&#34;%{http_code}\n&#34;</span> http://consul.service.consul:8500/ui/
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ curl -s -o /dev/null -w <span style="color:#e6db74">&#34;%{http_code}\n&#34;</span> http://google.com
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">301</span>
</span></span></code></pre></div><h2 id="end">End</h2>
<p>There are also guides available on how to do this on <a href="https://learn.hashicorp.com/consul/security-networking/forwarding">Hashicorp&rsquo;s website</a>, covering other DNS resolvers too (such as BIND, Dnsmasq, Unbound).</p>
]]></content:encoded></item><item><title>Running a Secure RabbitMQ Cluster in Nomad</title><link>https://andydote.co.uk/2019/04/06/nomad-rabbitmq-secure/</link><pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/04/06/nomad-rabbitmq-secure/</guid><description>Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.
The things I want to cover are:
Username and Password for the management UI Secure value for the Erlang Cookie SSL for Management and AMQP As usual, the demo repository with all the code is available if you&amp;rsquo;d rather just jump into that.</description><content:encoded><![CDATA[<p>Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.</p>
<p>The things I want to cover are:</p>
<ul>
<li>Username and Password for the management UI</li>
<li>Secure value for the Erlang Cookie</li>
<li>SSL for Management and AMQP</li>
</ul>
<p>As usual, the <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo">demo repository</a> with all the code is available if you&rsquo;d rather just jump into that.</p>
<h2 id="configure-nomad-to-integrate-with-vault">Configure Nomad To Integrate With Vault</h2>
<p>To manage the certificates and credentials I will use another Hashicorp tool called <a href="https://vaultproject.io/">Vault</a>, which provides Secrets As A Service.  It can be configured for High Availability, but for the demo, we will just use a single instance on one of our Nomad machines.</p>
<h3 id="vault">Vault</h3>
<p>We&rsquo;ll update the Vagrant script used in the <a href="/2019/01/28/nomad-rabbitmq-consul-cluster/">last post about Nomad Rabbitmq Clustering</a> to add in a single Vault node.  <strong>This is not suitable for using Vault in production;</strong> for that there should be a separate Vault cluster running somewhere, but as this post is focusing on how to integrate with Vault, a single node will suffice.</p>
<p>Once we have Vault installed (<a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/provision.sh#L50">see the <code>provision.sh</code> script</a>), we need to set up a few parts.  First is a PKI (public key infrastructure), better known as a Certificate Authority (CA).  We will generate a single root certificate and have our client machines (and optionally the host machine) trust that one certificate.</p>
<p>As this the machines are running in Hyper-V with the Default Switch, we can use the inbuilt domain name, <code>mshome.net</code>, and provide our own certificates.  This script is run as part of the Server (<code>nomad1</code>) provisioning script, but in a production environment would be outside of this scope.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>domain<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mshome.net&#34;</span>
</span></span><span style="display:flex;"><span>vault secrets enable pki
</span></span><span style="display:flex;"><span>vault secrets tune -max-lease-ttl<span style="color:#f92672">=</span>87600h pki
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vault write -field<span style="color:#f92672">=</span>certificate pki/root/generate/internal common_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$domain<span style="color:#e6db74">&#34;</span> ttl<span style="color:#f92672">=</span>87600h <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    &gt; /vagrant/vault/mshome.crt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vault write pki/config/urls <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    issuing_certificates<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$VAULT_ADDR<span style="color:#e6db74">/v1/pki/ca&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    crl_distribution_points<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$VAULT_ADDR<span style="color:#e6db74">/v1/pki/crl&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vault write pki/roles/rabbit <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    allowed_domains<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$domain<span style="color:#e6db74">&#34;</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    allow_subdomains<span style="color:#f92672">=</span>true <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    generate_lease<span style="color:#f92672">=</span>true <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    max_ttl<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;720h&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sudo cp /vagrant/vault/mshome.crt /usr/local/share/ca-certificates/mshome.crt
</span></span><span style="display:flex;"><span>sudo update-ca-certificates
</span></span></code></pre></div><p>If you don&rsquo;t want scary screens in FireFox and Chrome, you&rsquo;ll need to install the <code>mshome.crt</code> certificate into your trust store.</p>
<p>Next up, we have some policies we need in Vault.  The first deals with what the Nomad Server(s) are allowed to do - namely to handle tokens for itself, and anything in the <code>nomad-cluster</code> role.  <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/vault/nomad-server-policy.hcl">A full commented version of this policy is available here</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;auth/token/create/nomad-cluster&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;update&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;auth/token/roles/nomad-cluster&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;read&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;auth/token/lookup-self&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;read&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;auth/token/lookup&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;update&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;auth/token/revoke-accessor&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;update&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;sys/capabilities-self&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;update&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;auth/token/renew-self&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;update&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As this policy mentions the <code>nomad-cluster</code> role a few times, let&rsquo;s have a look at that also:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;disallowed_policies&#34;</span>: <span style="color:#e6db74">&#34;nomad-server&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;explicit_max_ttl&#34;</span>: <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;name&#34;</span>: <span style="color:#e6db74">&#34;nomad-cluster&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;orphan&#34;</span>: <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;period&#34;</span>: <span style="color:#ae81ff">259200</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;renewable&#34;</span>: <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This allows a fairly long-lived token to be created, which can be renewed.  It is also limiting what the tokens are allowed to do, which can be done as either a block list (<code>disallowed_policies</code>) or an allow list (<code>allowed_policies</code>).  In this case, I am letting the Clients access any policies except the <code>nomad-server</code> policy.</p>
<p>We can install both of these into Vault:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vault policy write nomad-server /vagrant/vault/nomad-server-policy.hcl
</span></span><span style="display:flex;"><span>vault write auth/token/roles/nomad-cluster @/vagrant/vault/nomad-cluster-role.json
</span></span></code></pre></div><h3 id="nomad">Nomad</h3>
<p>Now that Vault is up and running, we should configure Nomad to talk to it.  This is done in two places - the Server configuration, and the Client configuration.</p>
<p>To configure the <strong>Nomad Server</strong>, we update it&rsquo;s configuration file to include a <code>vault</code> block, which contains a role name it will use to generate tokens (for itself and for the Nomad Clients), and an initial token.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>vault {
</span></span><span style="display:flex;"><span>    enabled <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    address <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://localhost:8200&#34;</span>
</span></span><span style="display:flex;"><span>    task_token_ttl <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1h&#34;</span>
</span></span><span style="display:flex;"><span>    create_from_role <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;nomad-cluster&#34;</span>
</span></span><span style="display:flex;"><span>    token <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;some_token_here&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The initial token is generated by the <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/server.sh"><code>./server.sh</code></a> script - how you go about doing this in production will vary greatly depending on how you are managing your machines.</p>
<p>The <strong>Nomad Clients</strong> also need the Vault integration enabling, but in their case, it only needs the location of Vault, as the Server node(s) will provide tokens for the clients to use.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>vault {
</span></span><span style="display:flex;"><span>    enabled <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    address <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;http://nomad1.mshome.net:8200&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="job-requirements">Job Requirements</h2>
<p>Before we go about changing the job itself, we need to write some data into Vault for the job to use:</p>
<ul>
<li>Credentials: Username and password for the RabbitMQ Management UI, and the <code>RABBITMQ_ERLANG_COOKIE</code></li>
<li>A policy for the job allowing Certificate Generation and Credentials access</li>
</ul>
<h3 id="credentials">Credentials</h3>
<p>First off, we need to create a username and password to use with the Management UI.  This can be done via the Vault CLI:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vault kv put secret/rabbit/admin <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    username<span style="color:#f92672">=</span>administrator <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    password<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat /proc/sys/kernel/random/uuid<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><p>For the Erlang Cookie, we will also generate a Guid, but this time we will store it under a separate path in Vault so that it can be locked down separately to the admin username and password if needed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vault kv put secret/rabbit/cookie <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    cookie<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat /proc/sys/kernel/random/uuid<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><h3 id="job-policy">Job Policy</h3>
<p>Following the principle of <a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">Least Privilege</a>, we will create a policy for our <code>rabbit</code> job which only allows certificates to be generated, and rabbit credentials to be read.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;pki/issue/rabbit&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;create&#34;</span>, <span style="color:#e6db74">&#34;read&#34;</span>, <span style="color:#e6db74">&#34;update&#34;</span>, <span style="color:#e6db74">&#34;delete&#34;</span>, <span style="color:#e6db74">&#34;list&#34;</span> <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>path <span style="color:#e6db74">&#34;secret/data/rabbit/*&#34;</span> {
</span></span><span style="display:flex;"><span>  capabilities <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> <span style="color:#e6db74">&#34;read&#34;</span> <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is written into Vault in the same way as the other policies were:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vault policy write rabbit /vagrant/vault/rabbit-policy.hcl
</span></span></code></pre></div><h2 id="rabbit-job-configuration">Rabbit Job Configuration</h2>
<p>The first thing we need to do to the job is specify what policies we want to use with Vault, and what to do when a token or credential expires:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>task <span style="color:#e6db74">&#34;rabbit&#34;</span> {
</span></span><span style="display:flex;"><span>  driver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;docker&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  vault {
</span></span><span style="display:flex;"><span>    policies <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;default&#34;</span>, <span style="color:#e6db74">&#34;rabbit&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>    change_mode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;restart&#34;</span>
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="certificates">Certificates</h3>
<p>To configure RabbitMQ to use SSL, we need to provide it with values for 3 environment variables:</p>
<ul>
<li><code>RABBITMQ_SSL_CACERTFILE</code> - The CA certificate</li>
<li><code>RABBITMQ_SSL_CERTFILE</code> - The Certificate for RabbitMQ to use</li>
<li><code>RABBITMQ_SSL_KEYFILE</code> - the PrivateKey for the RabbitMQ certificate</li>
</ul>
<p>So let&rsquo;s add a <code>template</code> block to the job to generate and write out a certificate.  It&rsquo;s worth noting that <strong>line endings matter</strong>.  You either need your <code>.nomad</code> file to use LF line endings, or make the <code>template</code> a single line and use <code>\n</code> to add the correct line endings in.  I prefer to have the file with LF line endings.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>template <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  data <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;&lt;EOH
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{ $host := printf &#34;common_name=%s.mshome.net&#34; (env &#34;attr.unique.hostname&#34;) }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{ with secret &#34;pki/issue/rabbit&#34; $host &#34;format=pem&#34; }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{ .Data.certificate }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">{{ .Data.private_key }}{{ end }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOH</span>
</span></span><span style="display:flex;"><span>  destination <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;secrets/rabbit.pem&#34;</span>
</span></span><span style="display:flex;"><span>  change_mode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;restart&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>As we want to use the Nomad node&rsquo;s hostname within the <code>common_name</code> parameter of the secret, we need to use a variable to fetch and format the value:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>{{ $host :<span style="color:#f92672">=</span> printf <span style="color:#e6db74">&#34;common_name=%s.mshome.net&#34;</span> (env <span style="color:#e6db74">&#34;attr.unique.hostname&#34;</span>) }}
</span></span></code></pre></div><p>This can then be used by the <code>with secret</code> block to fetch a certificate for the current host:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>{{ with secret <span style="color:#e6db74">&#34;pki/issue/rabbit&#34;</span> $host <span style="color:#e6db74">&#34;format=pem&#34;</span> }}
</span></span></code></pre></div><p>Now that we have a certificate in the <code>./secrets/</code> directory, we can add a couple of volume mounts to the container, and set the environment variables with the container paths to the certificates.  Note how the root certificate is coming from the <code>/vagrant</code> directory, not from Vault itself.  Depending on how you are provisioning your machines to trust your CA, you will have a different path here!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span>config {
</span></span><span style="display:flex;"><span>  image <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pondidum/rabbitmq:consul&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># ...</span>
</span></span><span style="display:flex;"><span>  volumes <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;/vagrant/vault/mshome.crt:/etc/ssl/certs/mshome.crt&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;secrets/rabbit.pem:/etc/ssl/certs/rabbit.pem&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;secrets/rabbit.pem:/tmp/rabbitmq-ssl/combined.pem&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>env {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">RABBITMQ_SSL_CACERTFILE</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/etc/ssl/certs/mshome.crt&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">RABBITMQ_SSL_CERTFILE</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/etc/ssl/certs/rabbit.pem&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">RABBITMQ_SSL_KEYFILE</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/etc/ssl/certs/rabbit.pem&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You should also notice that we are writing the <code>secrets/rabbit.pem</code> file into the container twice:  The second write is to a file in <code>/tmp</code> as a workaround for the <code>docker-entrypoint.sh</code> script.  If we don&rsquo;t create this file ourselves, the container script will create it by combining the <code>RABBITMQ_SSL_CERTFILE</code> file and <code>RABBITMQ_SSL_KEYFILE</code> file, which will result in an invalid certificate, and a nightmare to figure out&hellip;</p>
<p>If the Vault integration in Nomad could write a single generated secret to two separate files, we wouldn&rsquo;t need this workaround.  Alternatively, you could make a custom container with a customised startup script to deal with this for you.</p>
<p>You can see the version of this file with <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/a588d7c2483c999b2fa0f47433403dfe1838fd50/rabbit/secure.nomad">only these changes here</a></p>
<h3 id="credentials-1">Credentials</h3>
<p>Now that we have things running with a certificate, it would be a great idea to start using the Erlang Cookie value and Management UI credentials we stored in Vault earlier.  This is a super easy change to support in the Nomad file - we need to add another <code>template</code> block, but this time set <code>env = true</code> which will instruct nomad that the key-values in the template should be loaded as environment variables:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>template <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    data <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;&lt;EOH
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {{ with secret &#34;secret/data/rabbit/cookie&#34; }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    RABBITMQ_ERLANG_COOKIE=&#34;{{ .Data.data.cookie }}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {{ end }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {{ with secret &#34;secret/data/rabbit/admin&#34; }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    RABBITMQ_DEFAULT_USER={{ .Data.data.username }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    RABBITMQ_DEFAULT_PASS={{ .Data.data.password }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    {{ end }}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">EOH</span>
</span></span><span style="display:flex;"><span>    destination <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;secrets/rabbit.env&#34;</span>
</span></span><span style="display:flex;"><span>    env <span style="color:#f92672">=</span> true
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The complete nomad file with <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/a78736cac3a93a43a96cbe84492089fca29d15e1/rabbit/secure.nomad">both certificates and credentials can be seen here</a>.</p>
<h2 id="running">Running!</h2>
<p>Now, all we need to do is start our new secure cluster:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nomad job run rabbit/secure.nomad
</span></span></code></pre></div><h2 id="client-libraries">Client Libraries</h2>
<p>Now that you have a secure version of RabbitMQ running, there are some interesting things which can be done with the client libraries.  While you can just use the secure port, RabbitMQ also supports <a href="https://www.rabbitmq.com/ssl.html#peer-verification">Peer Verification</a>, which means that the client has to present a certificate for itself, and RabbitMQ will validate that both certificates are signed by a common CA.</p>
<p>This process can be controlled with two environment variables:</p>
<ul>
<li><code>RABBITMQ_SSL_VERIFY</code> set to either <code>verify_peer</code> or <code>verify_none</code></li>
<li><code>RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT</code> set to <code>true</code> to require client certificates, <code>false</code> to make them optional</li>
</ul>
<p>In .net land, if you are using MassTransit, the configuration looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> bus = Bus.Factory.CreateUsingRabbitMq(c =&gt;
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    c.UseSerilog(logger);
</span></span><span style="display:flex;"><span>    c.Host(<span style="color:#e6db74">&#34;rabbitmq://nomad1.mshome.net:5671&#34;</span>, r =&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        r.Username(<span style="color:#e6db74">&#34;some_application&#34;</span>);
</span></span><span style="display:flex;"><span>        r.Password(<span style="color:#e6db74">&#34;some_password&#34;</span>);
</span></span><span style="display:flex;"><span>        r.UseSsl(ssl =&gt;
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            ssl.CertificatePath = <span style="color:#e6db74">@&#34;secrets/app.crt&#34;</span>;
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>There are also lots of other interesting things you can do with SSL and RabbitMQ, such as using the certificate as authentication rather than needing a username and password per app.  But you should be generating your app credentials dynamically with Vault too&hellip;</p>
<h1 id="wrapping-up">Wrapping Up</h1>
<p>Finding all the small parts to make this work was quite a challenge.  The <a href="https://gitter.im/hashicorp-nomad/Lobby">Nomad gitter</a> was useful when trying to figure out the certificates issue, and being able to read the <a href="https://github.com/docker-library/rabbitmq/blob/4b2b11c59ee65c2a09616b163d4572559a86bb7b/3.7/alpine/docker-entrypoint.sh#L363">source code</a> of the Docker image for RabbitMQ was invaluable to making the Certificate work.</p>
<p>If anyone sees anything I&rsquo;ve done wrong, or could be improved, I&rsquo;m happy to hear it!</p>
]]></content:encoded></item><item><title>RabbitMQ clustering with Consul in Nomad</title><link>https://andydote.co.uk/2019/01/28/nomad-rabbitmq-consul-cluster/</link><pubDate>Mon, 28 Jan 2019 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2019/01/28/nomad-rabbitmq-consul-cluster/</guid><description>Update If you want a secure version of this cluster, see Running a Secure RabbitMQ Cluster in Nomad.
RabbitMQ is the centre of a lot of micros service architectures, and while you can cluster it manually, it is a lot easier to use some of the auto clustering plugins, such as AWS (EC2), Consul, Etcd, or Kubernetes. As I like to use Nomad for container orchestration, I thought it would be a good idea to show how to cluster RabbitMQ when it is running in a Docker container, on an unknown host (i.</description><content:encoded><![CDATA[<p><strong>Update</strong> If you want a secure version of this cluster, see <a href="/2019/04/06/nomad-rabbitmq-secure/">Running a Secure RabbitMQ Cluster in Nomad</a>.</p>
<p>RabbitMQ is the centre of a lot of micros service architectures, and while you can cluster it manually, it is a lot easier to use some of the <a href="https://www.rabbitmq.com/clustering.html#cluster-formation-options">auto clustering plugins</a>, such as AWS (EC2), Consul, Etcd, or Kubernetes. As I like to use <a href="https://www.nomadproject.io/">Nomad</a> for container orchestration, I thought it would be a good idea to show how to cluster RabbitMQ when it is running in a Docker container, on an unknown host (i.e. one picked by Nomad.)</p>
<p>I ran into a few problems trying to get this working, but a lot of searching and some help from the <a href="https://groups.google.com/forum/#!forum/rabbitmq-users">RabbitMQ mailing list</a> (thanks Luke!) got me through all the issues, so hopefully, this will be easier next time and for other people too.</p>
<p>It is also worth noting that this is only going to be covering how to make a cluster work, not how to make it secure (setting up TLS etc.) for production usage.  There is a lot of <a href="https://www.rabbitmq.com/production-checklist.html#security-considerations">documentation on the RabbitMQ website</a> for further reading on this!</p>
<p>The full repository with all of the <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo">demo code is available on my Github</a>.</p>
<h2 id="nomad-cluster">Nomad Cluster</h2>
<p>As this post is mostly about running RabbitMQ on Nomad, and not setting up Nomad, I&rsquo;ll give the basics here - the full scripts are in the repository, and linked below too.</p>
<p>Vagrant is used to create us a three node cluster.  As I use Hyper-V for VMs, I can&rsquo;t set static IPs from the Vagrant file, so I have used another Vagrant feature: triggers.</p>
<p>Triggers let us specify scripts to run after Vagrant actions, so in this case, we run a script after machine1 comes up which writes out it&rsquo;s IP to the <code>/vagrant</code> share.  The other machines can then read this same file to join the cluster:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#66d9ef">Vagrant</span><span style="color:#f92672">.</span>configure(<span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>config<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>box <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bento/ubuntu-16.04&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>provision <span style="color:#e6db74">&#34;shell&#34;</span>, <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;./provision.sh&#34;</span>, <span style="color:#e6db74">privileged</span>: <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;n1&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>n1<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    n1<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>provision <span style="color:#e6db74">&#34;shell&#34;</span>, <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;./server.sh&#34;</span>, <span style="color:#e6db74">privileged</span>: <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    n1<span style="color:#f92672">.</span>trigger<span style="color:#f92672">.</span>after <span style="color:#e6db74">:up</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>trigger<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>      trigger<span style="color:#f92672">.</span>run_remote <span style="color:#f92672">=</span> { <span style="color:#e6db74">inline</span>: <span style="color:#e6db74">&#34;ip route get 1 | awk &#39;{print $NF;exit}&#39; &gt; /vagrant/server_ip&#34;</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>define <span style="color:#e6db74">&#34;n2&#34;</span> <span style="color:#66d9ef">do</span> <span style="color:#f92672">|</span>n2<span style="color:#f92672">|</span>
</span></span><span style="display:flex;"><span>    n2<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;nomad2&#34;</span>
</span></span><span style="display:flex;"><span>    n2<span style="color:#f92672">.</span>vm<span style="color:#f92672">.</span>provision <span style="color:#e6db74">&#34;shell&#34;</span>, <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;./client.sh&#34;</span>, <span style="color:#e6db74">privileged</span>: <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>The <code>provision.sh</code> script downloads and installs both Consul and Nomad, and then the respective <code>server.sh</code> and <code>client.sh</code> scripts set up both services in the right ways.  The server machine also acts as a Nomad client, so that we don&rsquo;t need 4 VMs running.</p>
<p><a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/vagrantfile">VagrantFile</a>, <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/provision.sh">provision.sh</a>, <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/server.sh">server.sh</a>, <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/client.sh">client.sh</a></p>
<p>All that remains to be done is <code>vagrant up</code>&hellip;and wait.  But while we&rsquo;re waiting for the machines to provision, let&rsquo;s have a look at RabbitMQ clustering, and how we&rsquo;ll define the job in Nomad.</p>
<h2 id="rabbitmq-cluster">RabbitMQ Cluster</h2>
<p>A few things to note about clustering RabbitMQ:</p>
<ul>
<li>All nodes must be listening on the same port for clustering (<code>4369</code> by default)</li>
<li>The <code>ERL_EPMD_PORT</code> variable doesn&rsquo;t work on <code>rabbitmq &lt; 3.7.9</code></li>
<li>The latest Docker image for rabbitmq is <code>3.7.8</code></li>
<li>The rabbit node names must be DNS resolvable</li>
<li>The <code>RABBITMQ_ERLANG_COOKIE</code> must have the same value</li>
</ul>
<p>The <code>rabbitmq_peer_discovery_consul</code> plugin we will use is shipped with RabbitMQ by default but is disabled.  The easiest way to get everything up and running is to create your own docker container, with the plugin enabled, and a small configuration file to set a few options:</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">FROM rabbitmq:management-alpine
COPY rabbitmq.conf /etc/rabbitmq
RUN rabbitmq-plugins enable --offline rabbitmq_peer_discovery_consul
</code></pre><p>The <code>rabbitmq.conf</code> only needs a few lines:</p>
<pre tabindex="0"><code class="language-conf" data-lang="conf">cluster_formation.peer_discovery_backend = rabbit_peer_discovery_consul
cluster_formation.consul.svc_addr_auto = true
</code></pre><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker build -t rabbitmq:consul .
</span></span></code></pre></div><p>An image built from this is also available on <a href="https://hub.docker.com/r/pondidum/rabbitmq">docker hub</a>.</p>
<p>Once we have a custom container built, it&rsquo;s a good idea to test that it actually works, before we start trying to get Nomad to run it.  We&rsquo;ll do this by creating a network in Docker so that all the containers can talk directly to each other on their pre-defined ports.  Don&rsquo;t forget to change <code>CONSUL_HOST</code> to your machine&rsquo;s IP address!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker network create rabbit
</span></span><span style="display:flex;"><span>docker run -d --rm --name consul -p 8500:8500 consul
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>docker run -d --rm --name rabbit1 -h rabbit1 --network rabbit -p 30001:15672 -e RABBITMQ_ERLANG_COOKIE<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rabbit&#39;</span> -e <span style="color:#e6db74">&#39;RABBITMQ_DEFAULT_USER=test&#39;</span> -e <span style="color:#e6db74">&#39;RABBITMQ_DEFAULT_PASS=test&#39;</span> -e CONSUL_HOST<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;10.0.75.1&#39;</span> rabbitmq:consul
</span></span><span style="display:flex;"><span>docker run -d --rm --name rabbit2 -h rabbit2 --network rabbit -p 30002:15672 -e RABBITMQ_ERLANG_COOKIE<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rabbit&#39;</span> -e <span style="color:#e6db74">&#39;RABBITMQ_DEFAULT_USER=test&#39;</span> -e <span style="color:#e6db74">&#39;RABBITMQ_DEFAULT_PASS=test&#39;</span> -e CONSUL_HOST<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;10.0.75.1&#39;</span> rabbitmq:consul
</span></span><span style="display:flex;"><span>docker run -d --rm --name rabbit3 -h rabbit3 --network rabbit -p 30003:15672 -e RABBITMQ_ERLANG_COOKIE<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;rabbit&#39;</span> -e <span style="color:#e6db74">&#39;RABBITMQ_DEFAULT_USER=test&#39;</span> -e <span style="color:#e6db74">&#39;RABBITMQ_DEFAULT_PASS=test&#39;</span> -e CONSUL_HOST<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;10.0.75.1&#39;</span> rabbitmq:consul
</span></span></code></pre></div><p>You can now visit <code>http://localhost:30001</code> (or <code>30002</code> or <code>30003</code>) and see that we have a successful cluster running.  Once you&rsquo;re happy with it, you can kill it all off (as we started the containers with the <code>--rm</code> flag, Docker will delete them for us when they stop):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker stop rabbit1 rabbit2 rabbit3 consul
</span></span><span style="display:flex;"><span>docker network rm rabbit
</span></span></code></pre></div><h2 id="nomad-rabbit-job">Nomad Rabbit Job</h2>
<p>Now that we know our container clusters successfully, we can create a Job definition to do the same thing in Nomad.  Nomad jobs are defined in HCL, a Json-like configuration language.</p>
<p>The jobs require a name, which datacentre it should run in, and what kind of job type it is.  In this case, our job is called <code>rabbit</code> (imaginative I know), we&rsquo;ll run it in <code>dc1</code> (the default value Nomad starts with), and we&rsquo;ll make this job be a <code>service</code>, as opposed to a <code>batch</code> or <code>system</code> job:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>job <span style="color:#e6db74">&#34;rabbit&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  datacenters <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;dc1&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;service&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  group <span style="color:#e6db74">&#34;cluster&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># tasks ...</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The <code>group</code> is used to hold a collection of <code>task</code>s, and when allocating a job, Nomad will make sure that all tasks belonging to an instance of a group are on the same node.</p>
<p>So for example, if you had a 2 node Nomad cluster, and 3 instances of a group which contained 3 tasks (e.g. API, varnish, and nginx containers), Nomad might distribute the groups like so:</p>
<p><img loading="lazy" src="nomad-allocation.png" alt="image of several nodes with groups of containers"  />
</p>
<p>Within the group, we can specify the number of instances we want with the <code>count</code> property, and we also specify that for both updates and migrations, only one group can be changed at a time.  This means that if you decide to upgrade the container used by the job, Nomad won&rsquo;t stop all instances at once, destroying your service&rsquo;s availability!</p>
<p>We also specify that we want to use the health checks (defined later on) rather than the state of the task itself to determine what is healthy, and how long the task must be healthy for before we decide it&rsquo;s actually healthy, and how long it has to achieve being healthy.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>group <span style="color:#e6db74">&#34;cluster&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  count <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  update <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    max_parallel <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  migrate <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    max_parallel <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    health_check <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;checks&#34;</span>
</span></span><span style="display:flex;"><span>    min_healthy_time <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>    healthy_deadline <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;30s&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The <code>task</code> is our unit of work in Nomad.  In this case, we are using the <code>docker</code> driver, but it also <a href="https://www.nomadproject.io/docs/drivers/index.html">supports many other drivers</a> including <code>exec</code>, <code>rkt</code> and <code>lxc</code>.  We configure which image to use, and importantly that the <code>hostname</code> is the name from Nomad!</p>
<p>The <code>port_map</code> tells nomad which ports of the container we want to expose, and labels them.  We can then refer to the ports by their labels in other parts of the configuration.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>task <span style="color:#e6db74">&#34;rabbit&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  driver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;docker&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  config <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    image <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pondidum/rabbitmq:consul&#34;</span>
</span></span><span style="display:flex;"><span>    hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>attr.unique.hostname<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    port_map <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      amqp <span style="color:#f92672">=</span> <span style="color:#ae81ff">5672</span>
</span></span><span style="display:flex;"><span>      ui <span style="color:#f92672">=</span> <span style="color:#ae81ff">15672</span>
</span></span><span style="display:flex;"><span>      epmd <span style="color:#f92672">=</span> <span style="color:#ae81ff">4369</span>
</span></span><span style="display:flex;"><span>      clustering <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The <code>env</code> section is pretty self-explanatory; they are environment variables to pass to the container.  As Consul is running on the Nomad host, we use the Nomad interpolation attribute to specify the IP of the current host, and we also set the <code>RABBITMQ_ERLANG_COOKIE</code> to a specific value.  In a production environment, you should be setting this value to something unguessable, possibly using the <a href="https://www.nomadproject.io/docs/job-specification/vault.html">Vault intergration</a> in Nomad to fetch a token.  We can also add other settings to pass to the container here, such as <code>RABBITMQ_DEFAULT_USER</code> and <code>RABBITMQ_DEFAULT_PASS</code>.  As with the cookie generation, in a production-like environment, you&rsquo;d probably want to use the Vault integration to pull the values for these variables.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>env <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  RABBITMQ_ERLANG_COOKIE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rabbitmq&#34;</span>
</span></span><span style="display:flex;"><span>  CONSUL_HOST <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>attr.unique.network.ip-address<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The <code>resources</code> section lets us constraints on things like CPU, Memory, IOPs, and Network.  In our case, we are only specifying a set of ports to expose on the network, and that we want them to be bound to specific ports on the host:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>resources <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  network <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    port <span style="color:#e6db74">&#34;amqp&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">5672</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    port <span style="color:#e6db74">&#34;ui&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">15672</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    port <span style="color:#e6db74">&#34;epmd&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">4369</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>    port <span style="color:#e6db74">&#34;clustering&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">25672</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>We could select different ports to bind the container ports to, or leave out the <code>static</code> pair entirely to have Nomad map the ports to random unused ports on the host.</p>
<p>Finally, the <code>service</code> block integrates with service discovery (so, Consul), and allows us to register ports and health checks for our service.  In the case of our RabbitMQ cluster, we already have service discovery integration via the RabbitMQ Consul plugin, so this registration is only used for the <code>check</code> feature, which is what will also be used by the <code>migrate</code> block to see if a task is healthy:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>service <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>  check <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    name     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;alive&#34;</span>
</span></span><span style="display:flex;"><span>    type     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;tcp&#34;</span>
</span></span><span style="display:flex;"><span>    port     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ui&#34;</span>
</span></span><span style="display:flex;"><span>    interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;10s&#34;</span>
</span></span><span style="display:flex;"><span>    timeout  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;2s&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p>The check is using the <code>ui</code> port defined earlier to check if the UI is alive.  We could also change the health check to use the <code>amqp</code> port instead, as that might be a better indication that the actual service can do useful things.  We can define multiple checks, and are not limited to TCP; <code>grpc</code>, <code>http</code>, and <code>script</code> are also supported.</p>
<p>The entire job definition is below, and is <a href="https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/rabbit/rabbit.nomad">also available in the repository</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>job <span style="color:#e6db74">&#34;rabbit&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  datacenters <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;dc1&#34;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>  type <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;service&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  group <span style="color:#e6db74">&#34;cluster&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    update <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      max_parallel <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    migrate <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      max_parallel <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>      health_check <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;checks&#34;</span>
</span></span><span style="display:flex;"><span>      min_healthy_time <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;5s&#34;</span>
</span></span><span style="display:flex;"><span>      healthy_deadline <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;30s&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    task <span style="color:#e6db74">&#34;rabbit&#34;</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>      driver <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;docker&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      config <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        image <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;pondidum/rabbitmq:consul&#34;</span>
</span></span><span style="display:flex;"><span>        hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>attr.unique.hostname<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        port_map <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          amqp <span style="color:#f92672">=</span> <span style="color:#ae81ff">5672</span>
</span></span><span style="display:flex;"><span>          ui <span style="color:#f92672">=</span> <span style="color:#ae81ff">15672</span>
</span></span><span style="display:flex;"><span>          epmd <span style="color:#f92672">=</span> <span style="color:#ae81ff">4369</span>
</span></span><span style="display:flex;"><span>          clustering <span style="color:#f92672">=</span> <span style="color:#ae81ff">25672</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      env <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        RABBITMQ_ERLANG_COOKIE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;generate_a_guid_-_or_something_for_this&#34;</span>
</span></span><span style="display:flex;"><span>        RABBITMQ_DEFAULT_USER <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>        RABBITMQ_DEFAULT_PASS <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;test&#34;</span>
</span></span><span style="display:flex;"><span>        CONSUL_HOST <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>attr.unique.network.ip-address<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      resources <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        network <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;amqp&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">5672</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;ui&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">15672</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;epmd&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">4369</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>          port <span style="color:#e6db74">&#34;clustering&#34;</span> <span style="color:#f92672">{</span> static <span style="color:#f92672">=</span> <span style="color:#ae81ff">25672</span> <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      service <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rabbitmq&#34;</span>
</span></span><span style="display:flex;"><span>        port <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ui&#34;</span>
</span></span><span style="display:flex;"><span>        check <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>          name     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;alive&#34;</span>
</span></span><span style="display:flex;"><span>          type     <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;tcp&#34;</span>
</span></span><span style="display:flex;"><span>          interval <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;10s&#34;</span>
</span></span><span style="display:flex;"><span>          timeout  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;2s&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h2 id="running-the-job">Running The Job</h2>
<p>First, make sure your console can talk to Nomad, which we can do by using the <code>server_ip</code> file again:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>export NOMAD_ADDR<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;http://</span><span style="color:#66d9ef">$(</span>cat server_ip<span style="color:#66d9ef">)</span><span style="color:#e6db74">:4646&#34;</span>
</span></span></code></pre></div><p>Now it should be possible to run the job:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>nomad job run rabbit/rabbit.nomad
</span></span></code></pre></div><p>After a few moments, we can visit any of the Nomad hosts, and log in to the RabbitMQ UI (<code>http://SOME_SERVER_IP:15672</code>) and you should be greeted with a running cluster with three nodes:</p>
<p><img loading="lazy" src="rabbitmq-cluster.png" alt="rabbitmq cluster dashboard"  />
</p>
<h2 id="homework">Homework</h2>
<ul>
<li>Kill a container on one of the nodes and see what happens (<code>vagrant ssh n2</code> then <code>docker stop &lt;SOME_CONTAINER_ID&gt;</code>)</li>
<li>Create an Application which you deploy to Nomad which uses service discovery to talk to RabbitMQ</li>
<li>Create some more Nomad clients, and try making a bigger RabbitMQ cluster</li>
</ul>
<p>If you have any questions, feel free to comment below or <a href="https://twitter.com/pondidum">send me a tweet</a>.</p>
]]></content:encoded></item><item><title>Feature Toggles with Consul</title><link>https://andydote.co.uk/2018/09/06/consul-feature-toggles/</link><pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2018/09/06/consul-feature-toggles/</guid><description>Feature Toggles are a great way of helping to deliver working software, although there are a few things which could go wrong. See my talk Feature Toggles: The Good, The Bad and The Ugly for some interesting stories and insights on it!
I was talking with a colleague the other day about how you could go about implementing Feature Toggles in a centralised manner into an existing system, preferably with a little overhead as possible.</description><content:encoded><![CDATA[<p>Feature Toggles are a great way of helping to deliver working software, although there are a few things which could go wrong.  See my talk <a href="https://www.youtube.com/watch?v=r7VI5x2XKXw">Feature Toggles: The Good, The Bad and The Ugly</a> for some interesting stories and insights on it!</p>
<p>I was talking with a colleague the other day about how you could go about implementing Feature Toggles in a centralised manner into an existing system, preferably with a little overhead as possible.  The most obvious answer is to use a SAAS solution such as <a href="https://launchdarkly.com/">LauchDarkly</a>, but what if you either don&rsquo;t want to or can&rsquo;t use a SAAS solution?</p>
<p>What if we already are using Consul for things such as service discovery, could we use the key-value store as a basic Feature Toggle service?  It has a few advantages:</p>
<ul>
<li>Consul is already in place, so there is no extra infrastructure required and no additional costs</li>
<li>Low stopping cost - If we decide we don&rsquo;t want to use Consul, or not to use Toggles at all, we can stop</li>
<li>Low learning curve - we know how to use Consul already</li>
<li>Security - we can make use of Consul&rsquo;s <a href="https://www.consul.io/docs/guides/acl.html#key-value-rules">ACL</a> to allow services to only read, and operators to write Feature Toggles.</li>
</ul>
<p>There are also some downsides to consider too:</p>
<ul>
<li>We&rsquo;d effectively be reinventing the wheel</li>
<li>There won&rsquo;t be any &ldquo;value protection&rdquo; on the settings (nothing stopping us putting an int into a field which will be parsed as a guid for example)</li>
<li>No statistics - we won&rsquo;t be able to tell if a value is used still</li>
<li>No fine-grained control - unless we build some extra hierarchies, everyone gets the same value for a given key</li>
</ul>
<p>So what would our system look like?</p>
<p><img loading="lazy" src="consul-feature-toggles.png" alt="write to consul kv store, results distributed to other consul instances"  />
</p>
<p>It&rsquo;s pretty straightforward.  We already have a Consul Cluster, and then there are several machines with Consul clients running on them, as well as a Container Host with Consul too.</p>
<p>Any configuration written to a Consul node is replicated to all other nodes, so our user can write values to any node to get it to the rest of the cluster.</p>
<p>As mentioned earlier, we can use the <a href="https://www.consul.io/docs/guides/acl.html#key-value-rules">ACL</a> system to lock things down.  Our services will have a read-only role, and our updating user will have a writeable role.</p>
<h2 id="what-next">What Next?</h2>
<p>Assuming this system covers enough of what we want to do, the next steps might be to make some incremental improvements in functionality, although again I would suggest looking into not reinventing the wheel&hellip;</p>
<h3 id="statistics">Statistics</h3>
<p>While we can&rsquo;t use Consul to collect statistics on what keys are being read, we could provide this functionality by making a small client library which would log the queries and send them somewhere for aggregation.</p>
<p>Most microservice environments have centralised logging or monitoring (and if they don&rsquo;t, they really should), so we can use this to record toggle usage.</p>
<p>This information would be useful to have in the same place you set the feature toggles, which brings us nicely onto the next enhancement.</p>
<h3 id="user-interface">User Interface</h3>
<p>A simple static website could be used to read all the Toggles and their relevant states and statistics and provide a way of setting them.  The UI could further be expanded to give some type safety, such as extra data indicating what type a given key&rsquo;s value should be.</p>
<h3 id="fine-grained-values">FIne Grained Values</h3>
<p>Currently, everyone has the same value for a given key, but the system could be expanded to be more fine-grained.  Rather than storing a feature toggle in the current form:</p>
<pre tabindex="0"><code>/kv/toggles/fast-rendering =&gt; true
</code></pre><p>We could add another level which would indicate a grouping:</p>
<pre tabindex="0"><code>/kv/toggles/fast-rendering/early-access =&gt; true
/kv/toggles/fast-rendering/others =&gt; false
</code></pre><p>At this point though, you are starting to add a lot of complexity.  Think about whether you are solving the right problem! Choose where you are spending your <a href="http://mcfunley.com/choose-boring-technology">Innovation Tokens</a>.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>Should you do this? Maybe. Probably not.  I don&rsquo;t know your system and what infrastructure you have available, so I don&rsquo;t want to give any blanket recommendations.</p>
<p>I will, however, suggest that if you are starting out with Feature Toggles, <strong>go for something simple first</strong>.  My current team&rsquo;s first use of a Feature Toggle was just a setting in the <code>web.config</code>, and we just changed the value of it when we wanted the new functionality to come on.</p>
<p>See what works for you, and if you start needing something more complicated than just simple key-value toggles, have a look into an existing system.</p>
]]></content:encoded></item><item><title>Managing AppSettings in Consul</title><link>https://andydote.co.uk/2018/08/07/managing-consul-appsettings/</link><pubDate>Tue, 07 Aug 2018 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2018/08/07/managing-consul-appsettings/</guid><description>Consul is a great utility to make running your microservice architecture very simple. Amongst other things, it provides Service Discovery, Health Checks, and Configuration. In this post, we are going to be looking at Configuration; not specifically how to read from Consul, but about how we put configuration data into Consul in the first place.
The usual flow for an application using Consul for configuration is as follows:
App Starts Fetches configuration from Consul Configures itself Registers in Consul for Service Discovery Ready Step 2 is very straightforward - you query the local instance of Consul&amp;rsquo;s HTTP API, and read the response into your configuration object (If you&amp;rsquo;re using Microsoft&amp;rsquo;s Configuration libraries on dotnet core, you can use the Consul.</description><content:encoded><![CDATA[<p><a href="https://www.consul.io/">Consul</a> is a great utility to make running your microservice architecture very simple.  Amongst other things, it provides Service Discovery, Health Checks, and Configuration.  In this post, we are going to be looking at Configuration; not specifically how to read from Consul, but about how we put configuration data into Consul in the first place.</p>
<p>The usual flow for an application using Consul for configuration is as follows:</p>
<ol>
<li>App Starts</li>
<li>Fetches configuration from Consul</li>
<li>Configures itself</li>
<li>Registers in Consul for Service Discovery</li>
<li>Ready</li>
</ol>
<p>Step 2 is very straightforward - you query the local instance of Consul&rsquo;s HTTP API, and read the response into your configuration object (If you&rsquo;re using Microsoft&rsquo;s Configuration libraries on dotnet core, you can use <a href="https://www.nuget.org/packages/Consul.Microsoft.Extensions.Configuration/">the Consul.Microsoft.Extensions.Configuration NuGet package</a>).</p>
<p>The question is though, how does the configuration get into Consul in the first place? Obviously, we don&rsquo;t want this to be a manual process, and as Consul&rsquo;s HTTP API supports writing too, it doesn&rsquo;t have to be!  But where is the master copy of the configuration data stored?  Where it should be! In the repository with your code for the application.</p>
<p><img loading="lazy" src="repository-with-config.png" alt="repository structure, config.json, config.test.json and config.prod.json in the root"  />
</p>
<p>By default, all your configuration values should be going into the base configuration (<code>config.json</code>), and only use the environment specific versions (e.g. <code>config.test.json</code> and <code>config.prod.json</code>) when a value needs to differ in some environments.</p>
<h2 id="why-store-config-in-the-repository">Why store config in the repository?</h2>
<p>There are many reasons for putting your configuration into a repository alongside the code it relates to, mostly around answering these questions:</p>
<ul>
<li>When did this key&rsquo;s value change?</li>
<li>Why did this key&rsquo;s value change?</li>
<li>Who changed this (do they have more context for why)?</li>
<li>What values has this key been over time?</li>
<li>How often is this key changing?</li>
</ul>
<p>If a value is changing often with reasons (commit messages) such as &ldquo;scale the thing due to increased traffic&rdquo; and &ldquo;scale the thing back down now it&rsquo;s quiet&rdquo; that starts to tell you that you should be implementing some kind of autoscaling.</p>
<p>If you find out a key is set incorrectly, you can find out how long it&rsquo;s been wrong, and maybe discover that the value is not &ldquo;wrong&rdquo; but &ldquo;not right anymore&rdquo;.</p>
<p>The final piece of this is that you know the value in production will match the value specified - there are no operators accidentally adding a 0 to the end of the number of threads to run etc.</p>
<h2 id="deployment">Deployment</h2>
<p>Now we just need to get the configuration from the file, and into Consul whenever it changes.  As I use <a href="https://terraform.io/">Terraform</a> for deploying changes, I just need to update it to write to Consul also.</p>
<p><img loading="lazy" src="deployment-pipeline-consul.png" alt="deployment pipeline - git to AppVeyor to Terraform.  Terraform writes to consul and updates ECS cluster"  />
</p>
<p>Terraform supports <a href="https://www.terraform.io/docs/providers/consul/r/key_prefix.html">writing to Consul</a> out of the box, however, Terraform can&rsquo;t directly read parse json files, but we can use the <a href="https://www.terraform.io/docs/providers/external/index.html"><code>external</code></a> provider to get around that limitation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">data</span> <span style="color:#960050;background-color:#1e0010">&#34;external&#34;</span> <span style="color:#960050;background-color:#1e0010">&#34;config_file&#34;</span> <span style="color:#960050;background-color:#1e0010">{
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">program</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">[&#34;cat&#34;,</span> <span style="color:#960050;background-color:#1e0010">&#34;config.json&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">resource</span> <span style="color:#960050;background-color:#1e0010">&#34;consul_key_prefix&#34;</span> <span style="color:#960050;background-color:#1e0010">&#34;appsettings&#34;</span> <span style="color:#960050;background-color:#1e0010">{
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">path_prefix</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">&#34;appsettings/testapp/&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">subkeys</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">&#34;${data.external.config_file.result}&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}
</span></span></span></code></pre></div><p>If we want to take things a step further, and use our environment specific overrides files, we just need to use the <a href="https://stedolan.github.io/jq/">JQ command line tool</a> to merge the two json files, which can be done like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>jq -s <span style="color:#e6db74">&#39;.[0] * .[1]&#39;</span> config.json config.test.json
</span></span></code></pre></div><p>Unfortunately, the <code>external</code> provider has a very specific syntax to how it is called, and we can&rsquo;t just specify the jq command directly.  So it needs to go into another file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#! /bin/bash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>jq -s <span style="color:#e6db74">&#39;.[0] * .[1]&#39;</span> <span style="color:#e6db74">&#34;</span>$@<span style="color:#e6db74">&#34;</span>
</span></span></code></pre></div><p>Finally, we can update the <code>external</code> block to use the new script.  You could replace the second file with a merged string containing the current environment (e.g. <code>&quot;config.${var.environment}.json&quot;</code>)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cmake" data-lang="cmake"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">data</span> <span style="color:#960050;background-color:#1e0010">&#34;external&#34;</span> <span style="color:#960050;background-color:#1e0010">&#34;config_file&#34;</span> <span style="color:#960050;background-color:#1e0010">{
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010"></span>  <span style="color:#960050;background-color:#1e0010">program</span> <span style="color:#960050;background-color:#1e0010">=</span> <span style="color:#960050;background-color:#1e0010">[&#34;bash&#34;,</span> <span style="color:#960050;background-color:#1e0010">&#34;mergeconfigs.sh&#34;,</span> <span style="color:#960050;background-color:#1e0010">&#34;config.json&#34;,</span> <span style="color:#960050;background-color:#1e0010">&#34;config.test.json&#34;]
</span></span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">}
</span></span></span></code></pre></div><p>The complete version of this is <a href="https://github.com/Pondidum/Terraform-Demos/tree/master/manage-consul-keys">here in my Terraform Demos repository</a> on GitHub.</p>
<h2 id="what-next">What next?</h2>
<p>Have a go managing your settings as part of your deployment pipeline!  Depending on what tools you are using, you might need to implement your own HTTP posts to the Consul API, but the advantages of automating this task far outweigh the cost of writing some <code>curl</code> commands in my opinion!</p>
]]></content:encoded></item><item><title>Preventing MicroService Boilerplate</title><link>https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/</link><pubDate>Sun, 17 Jul 2016 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/</guid><description>One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the Single Project Service and Console method.
What do we do in every service? Initialise Serilog. Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.) Hook/Unhook the AppDomain.</description><content:encoded><![CDATA[<p>One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service.  Not only that, but the project setup is repetitive, as all the services use the <a href="/2015/08/30/single-project-service-and-console/">Single Project Service and Console</a> method.</p>
<h1 id="what-do-we-do-in-every-service">What do we do in every service?</h1>
<ul>
<li>Initialise Serilog.</li>
<li>Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.)</li>
<li>Hook/Unhook the <code>AppDomain.Current.UnhandledException</code> handler.</li>
<li>Register/UnRegister with Consul.</li>
<li>Setup StructureMap, if using an IOC Container.</li>
<li>Run as a Console if the <code>Environment.UserInteractive</code> flag is true.</li>
<li>Run as a Service otherwise</li>
</ul>
<p>The only task with potential to have variance each time is the setting up of StructureMap, the rest are almost identical every time.</p>
<h1 id="how-to-solve-all-this-repetition">How to solve all this repetition?</h1>
<p>To rectify this, I created a nuget project which encapsulates all of this logic, and allows us to create a Console project with the following startup:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ServiceHost.Run&lt;Startup&gt;(<span style="color:#e6db74">&#34;TestService&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This requires one class implementing the <code>IStartup</code> interface, and there are some optional interfaces which can be implemented too:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Startup</span> : IStartup, IDisposable
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Startup()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Console.WriteLine(<span style="color:#e6db74">&#34;starting up&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Execute(ServiceArgs service)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		File.AppendAllLines(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span style="color:#e6db74">&#34;log.txt&#34;</span>), <span style="color:#66d9ef">new</span>[] { <span style="color:#e6db74">&#34;boot!&#34;</span> });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span> (service.CancelRequested == <span style="color:#66d9ef">false</span>)
</span></span><span style="display:flex;"><span>			Thread.Sleep(<span style="color:#ae81ff">500</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Dispose()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		Console.WriteLine(<span style="color:#e6db74">&#34;shutting down&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Optionally, the project can implement two interfaces to control Consul and ElasticSearch configuration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Config</span> : ILogConfig, IConsulRegistration
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> EnableKibana { <span style="color:#66d9ef">get</span>; }
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> Uri LoggingEndpoint { <span style="color:#66d9ef">get</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> CatalogRegistration CreateRegistration()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CatalogRegistration() { Service = <span style="color:#66d9ef">new</span> AgentService
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			Address = <span style="color:#e6db74">&#34;http://localhost&#34;</span>,
</span></span><span style="display:flex;"><span>			Port = <span style="color:#ae81ff">8005</span>,
</span></span><span style="display:flex;"><span>			Service = <span style="color:#e6db74">&#34;TestService&#34;</span>
</span></span><span style="display:flex;"><span>		}};
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> CatalogDeregistration CreateDeregistration()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> CatalogDeregistration { ServiceID = <span style="color:#e6db74">&#34;TestService&#34;</span> };
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>By implementing these interfaces, the <code>ServiceHost</code> class can use StructureMap to find the implementations (if any) at run time.</p>
<p>Talking of StructureMap, if we wish to configure the container in the host application, all we need to do is create a class which inherits <code>Registry</code>, and the ServiceHost&rsquo;s StructureMap configuration will find it.</p>
<h1 id="how-do-we-support-other-tools">How do we support other tools?</h1>
<p>Well we could implment some kind of stage configuration steps, so your startup might change to look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Main(<span style="color:#66d9ef">string</span>[] args)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	ServiceHost.Stages(<span style="color:#66d9ef">new</span> LoggingStage(), <span style="color:#66d9ef">new</span> ConsulStage(), <span style="color:#66d9ef">new</span> SuperAwesomeThingStage());
</span></span><span style="display:flex;"><span>	ServiceHost.Run&lt;Startup&gt;(<span style="color:#e6db74">&#34;TestService&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The reason I haven&rsquo;t done this is that on the whole, we tend to use the same tools for each job in every service; StructureMap for IOC, Serilog for logging, Consul for discovery.  So rather than having to write some boilerplate for every service (e.g. specifying all the stages), I just bake the options in to <code>ServiceHost</code> directly.</p>
<p>This means that if you want your own version of this library with different tooling support, you need to write it yourself.  As a starting point, I have the code for the <a href="https://github.com/pondidum/ServiceContainer"><code>ServiceContainer</code> project up on Github</a>.</p>
<p>It is not difficult to create new stages for the pipeline - all the different tasks the <code>ServiceHost</code> can perform are implemented in a pseudo Russian-Doll model - they inherit <code>Stage</code>, which looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Stage</span> : IDisposable
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> IContainer Container { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> Execute();
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> Dispose();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Anything you want to your stage to do before the <code>IStartup.Execute()</code> call is made is done in <code>Execute()</code>, similarly anything to be done afterwards is in <code>Dispose()</code>.  For example, the <code>ConsulStage</code> is implemented like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConsulStage</span> : Stage
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Execute()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> registration = Container.TryGetInstance&lt;IConsulRegistration&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (registration != <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> ConsulClient();
</span></span><span style="display:flex;"><span>			client.Catalog.Register(registration.CreateRegistration());
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Dispose()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">var</span> registration = Container.TryGetInstance&lt;IConsulRegistration&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> (registration != <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> ConsulClient();
</span></span><span style="display:flex;"><span>			client.Catalog.Deregister(registration.CreateDeregistration());
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Finally you just need to add the stage to the <code>ServiceWrapper</code> constructor:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c#" data-lang="c#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> ServiceWrapper(<span style="color:#66d9ef">string</span> name, Type entryPoint)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">// snip...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	_stages = <span style="color:#66d9ef">new</span> Stage[]
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">new</span> LoggingStage(name),
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">new</span> ConsulStage()
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="get-started">Get started!</h1>
<p>That&rsquo;s all there is to it!  Hopefully this gives you a good starting point for de-boilerplating your microservices :)</p>
]]></content:encoded></item></channel></rss>