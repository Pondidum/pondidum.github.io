<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>git on Andy Dote</title><link>https://andydote.co.uk/tags/git/</link><description>Recent content in git on Andy Dote</description><generator>Hugo -- gohugo.io</generator><language>en-gb</language><lastBuildDate>Fri, 10 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://andydote.co.uk/tags/git/rss.xml" rel="self" type="application/rss+xml"/><item><title>Branching and Red Builds</title><link>https://andydote.co.uk/2018/08/10/red-builds/</link><pubDate>Fri, 10 Aug 2018 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2018/08/10/red-builds/</guid><description>So this is a bit of a rant&amp;hellip;but hopefully with some solutions and workarounds too. So let&amp;rsquo;s kick things off with a nice statement:
I hate broken builds.
So everyone basically agrees on this point I think. The problem is that I mean all builds, including ones on shared feature branches.
Currently, I work on a number of projects which uses small(ish) feature branches. The way this works is that the team agrees on a new feature to work on creates a branch, and then each developer works on tasks, committing on their own branches, and Pull-Requesting to the feature branch.</description><content:encoded><![CDATA[<p>So this is a bit of a rant&hellip;but hopefully with some solutions and workarounds too. So let&rsquo;s kick things off with a nice statement:</p>
<p>I hate broken builds.</p>
<p>So everyone basically agrees on this point I think.  The problem is that I mean <em>all</em> builds, including ones on shared feature branches.</p>
<p>Currently, I work on a number of projects which uses small(ish) feature branches.  The way this works is that the team agrees on a new feature to work on creates a branch, and then each developer works on tasks, committing on their own branches, and Pull-Requesting to the feature branch.  Once the feature branch is completed, it&rsquo;s deployed and merged to master.  We&rsquo;ll ignore the fact that Trunk Based Development is just better for now.</p>
<p><img loading="lazy" src="branching-features.png" alt="branching, developers working on small tasks being merged into a feature branch"  />
</p>
<p>The problem occurs when one of the first tasks to be completed is writing behaviour (or acceptance) tests.  These are written in something like SpecFlow, and call out to stubbed methods which throw <code>NotImplementedException</code> s.  When this gets merged, the feature branch build goes red and stays red until all other tasks are done.  And probably for a little while afterwards too.  Nothing like &ldquo;red-green-refactor&rdquo; when your light can&rsquo;t change away from red!</p>
<h2 id="the-problems">The Problems</h2>
<ul>
<li>Local tests are failing, no matter how much you implement</li>
<li>PullRequests to the feature branch don&rsquo;t have passing build checks</li>
<li>The failing build is failing because:
<ul>
<li>Not everything is implemented yet</li>
<li>A developer has introduced an error, and no one has noticed yet</li>
<li>The build machine is playing up</li>
</ul>
</li>
</ul>
<p><img loading="lazy" src="branching-features-builds.png" alt="branching, developers working on small tasks being merged into a feature branch showing everything as failed builds"  />
</p>
<h2 id="bad-solutions">Bad Solutions</h2>
<p>The first thing we could do is to not run the acceptance tests on a Task branch&rsquo;s build, and only when a feature branch build runs.  This is a bad idea, as someone will have forgotten to check if their task&rsquo;s acceptance tests pass, and will require effort later to fix the broken acceptance tests.</p>
<p>We could also implement the acceptance file and not call any stubbed methods, making the file a text file and non-executable.  This is also a pretty bad idea - how much would you like to bet that it stays non-executable?</p>
<h2 id="the-solution">The Solution</h2>
<p>Don&rsquo;t have the acceptance tests as a separate task.  Instead, split the criteria among the implementation tasks.  This does mean that your other tasks should be Vertical Slices rather than Horizontal, which can be difficult to do depending on the application&rsquo;s architecture.</p>
<h2 id="an-example">An Example</h2>
<p>So let&rsquo;s dream up a super simple Acceptance Criteria:</p>
<ul>
<li>When a user signs up with a valid email which has not been used, they receive a welcome email with an activation link.</li>
<li>When a user signs up with an invalid email, they get a validation error.</li>
<li>When a user signs up with an in-use email, they get an error</li>
</ul>
<p>Note how this is already pretty close to being the tasks for the feature?  Our tasks are pretty much:</p>
<ul>
<li>implement the happy path</li>
<li>implement other scenarios</li>
</ul>
<p>Of course, this means that not everything can be done in parallel - I imagine you&rsquo;d want the happy path task to be done first, and then the other scenarios are probably parallelisable.</p>
<p>So our trade-off here is that we lose some parallelisation, but gain feedback. While this may seem insignificant, it has a significant impact on the overall delivery rate - everyone knows if their tasks are complete or not, and when the build goes red, you can be sure of what introduced the problem.</p>
<p>Not to mention that features are rarely this small - you probably have various separate acceptance criteria, such as being able to view an account page.</p>
<p>Oh, and once you can split your tasks correctly, there is only a small step to getting to do Trunk Based Development.  Which would make me happy.</p>
<p>And developer happiness is important.</p>
]]></content:encoded></item><item><title>Fixing Docker volume paths on Git Bash on Windows</title><link>https://andydote.co.uk/2018/06/18/git-bash-docker-volume-paths/</link><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2018/06/18/git-bash-docker-volume-paths/</guid><description>My normal development laptop runs Windows, but like a lot of developers, I make huge use of Docker, which I run under Hyper-V. I also heavily use the git bash terminal on windows to work.
Usually, everything works as expected, but I was recently trying to run an ELK (Elasticsearch, Logstash, Kibana) container, and needed to pass in an extra configuration file for Logstash. This caused me a lot of trouble, as nothing was working as expected.</description><content:encoded><![CDATA[<p>My normal development laptop runs Windows, but like a lot of developers, I make huge use of Docker, which I run under Hyper-V.  I also heavily use the git bash terminal on windows to work.</p>
<p>Usually, everything works as expected, but I was recently trying to run an ELK (Elasticsearch, Logstash, Kibana) container, and needed to pass in an extra configuration file for Logstash.  This caused me a lot of trouble, as nothing was working as expected.</p>
<p>The command I was running is as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -d --rm <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --name elk_temp <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -p 5044:5044 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -p 5601:5601 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -p 9200:9200 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -v logstash/app.conf:/etc/logstash/conf.d/app.conf <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    sebp/elk
</span></span></code></pre></div><p>But this has the interesting effect of mounting the <code>app.conf</code> in the container as a directory (which is empty), rather than doing the useful thing of mounting it as a file. Hmm.  I realised it was git bash doing path transformations to the windows style causing the issue, but all the work arounds I tried failed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># single quotes</span>
</span></span><span style="display:flex;"><span>docker run ... -v <span style="color:#e6db74">&#39;logstash/app.conf:/etc/logstash/conf.d/app.conf&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># absolute path</span>
</span></span><span style="display:flex;"><span>docker run ... -v /d/dev/temp/logstash/app.conf:/etc/logstash/conf.d/app.conf
</span></span><span style="display:flex;"><span><span style="color:#75715e"># absolute path with // prefix</span>
</span></span><span style="display:flex;"><span>docker run ... -v //d/dev/temp/logstash/app.conf:/etc/logstash/conf.d/app.conf
</span></span></code></pre></div><p>In the end, I found a way to switch off MSYS&rsquo;s (what git bash is based on) path conversion:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>MSYS_NO_PATHCONV<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> docker run <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -d --rm <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    --name elk_temp <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -p 5044:5044 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -p 5601:5601 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -p 9200:9200 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    -v logstash/app.conf:/etc/logstash/conf.d/app.conf <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>    sebp/elk
</span></span></code></pre></div><p>And Voila, the paths get passed through correctly, and I can go back to hacking away at Logstash!</p>
]]></content:encoded></item><item><title>Update all Docker images</title><link>https://andydote.co.uk/2017/01/16/update-all-docker-images/</link><pubDate>Mon, 16 Jan 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/01/16/update-all-docker-images/</guid><description>My work&amp;rsquo;s wifi is much faster than my 4G connection, so periodically I want to update all my docker images on my personal laptop while at work.
As I want to just set it going and then forget about it, I use the following one liner to do a docker pull against each image on my local machine:
docker images | grep -v REPOSITORY | awk &amp;#39;{print $1}&amp;#39;| xargs -L1 docker pull If you only want to fetch the versions you have the tags for:</description><content:encoded><![CDATA[<p>My work&rsquo;s wifi is <em>much</em> faster than my 4G connection, so periodically I want to update all my docker images on my personal laptop while at work.</p>
<p>As I want to just set it going and then forget about it, I use the following one liner to do a <code>docker pull</code> against each image on my local machine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker images | grep -v REPOSITORY | awk <span style="color:#e6db74">&#39;{print $1}&#39;</span>| xargs -L1 docker pull
</span></span></code></pre></div><p>If you only want to fetch the versions you have the tags for:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker images | grep -v REPOSITORY | awk <span style="color:#e6db74">&#39;{ if ($2 != &#34;&lt;none&gt;&#34;) { print $1&#34;:&#34;$2 } else { print $1 } }&#39;</span> | xargs -L1 docker pull
</span></span></code></pre></div><p>Now if only I could get git bash to do TTY properly so I get the pretty download indicators too :(</p>
]]></content:encoded></item><item><title>Git Aliases</title><link>https://andydote.co.uk/2017/01/06/git-aliases/</link><pubDate>Fri, 06 Jan 2017 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2017/01/06/git-aliases/</guid><description>Git is great, but creating some git aliases is a great way to make your usages even more efficient.
To add any of these you can either copy and paste into the [alias] section of your .gitconfig file or run git config --global alias.NAME 'COMMAND' replacing NAME with the alias to use, and COMMAND with what to run.
So without further ado, here are the ones I have created and use on a very regular basis.</description><content:encoded><![CDATA[<p>Git is great, but creating some git aliases is a great way to make your usages even more efficient.</p>
<p>To add any of these you can either copy and paste into the <code>[alias]</code> section of your <code>.gitconfig</code> file or run <code>git config --global alias.NAME 'COMMAND'</code> replacing <code>NAME</code> with the alias to use, and <code>COMMAND</code> with what to run.</p>
<p>So without further ado, here are the ones I have created and use on a very regular basis.</p>
<h1 id="constant-usage">Constant usage</h1>
<ul>
<li>
<p><code>git s</code> - an alias for <code>git status</code>.  Have to save those 5 keypresses!</p>
<pre tabindex="0"><code>s = status
</code></pre></li>
<li>
<p><code>git cm &quot;some commit message&quot;</code> - shorthand for commit with a message</p>
<pre tabindex="0"><code>cm = commit -m
</code></pre></li>
<li>
<p><code>git dc</code> - diff files staged for commit</p>
<pre tabindex="0"><code>dc = diff --cached
</code></pre></li>
<li>
<p><code>git scrub</code> - deletes everything not tracked by git (<code>git clean -dxf</code>) except the <code>packages</code> and <code>node_modules</code> directories</p>
<pre tabindex="0"><code>scrub = clean -dxf --exclude=packages --exclude=node_modules
</code></pre></li>
</ul>
<h1 id="context-switching-rebasing-on-dirty-head">Context switching, rebasing on dirty HEAD</h1>
<p>I rebase my changes onto the current branches often, but rebasing requires a clean repository to work on.  The following two aliases are used something like this: <code>git save &amp;&amp; git pull --rebase &amp;&amp; git undo</code></p>
<ul>
<li>
<p><code>git save</code> - adds and commits everything in the repository, with the commit message <code>SAVEPOINT</code></p>
<pre tabindex="0"><code>save = !git add -A &amp;&amp; git commit -m &#39;SAVEPOINT&#39;
</code></pre></li>
<li>
<p><code>git undo</code> - undoes the last commit, leaving everything as it was before committing.  Mostly used to undo a <code>git save</code> call</p>
<pre tabindex="0"><code>undo = reset HEAD~1 --mixed
</code></pre></li>
</ul>
<p>I also use these if I need to save my work to work on a bug fix on a different branch.</p>
<h1 id="what-have-i-done">What have I done?</h1>
<p>Often I want commits I have pending, either to the local master, or a remote tracking branch.  These both give an output like this:</p>
<p><img loading="lazy" src="git-pending.png" alt="Git Pending"  />
</p>
<ul>
<li>
<p><code>git pending</code> - shows the commits on the current branch compared to the <code>origin/master</code> branch</p>
<pre tabindex="0"><code>pending = log origin/master..HEAD --pretty=oneline --abbrev-commit --format=&#39;%Cgreen%cr:%Creset %C(auto)%h%Creset %s&#39;
</code></pre></li>
<li>
<p><code>git pendingup</code> - shows the commits on the current branch compared to its tracking branch</p>
<pre tabindex="0"><code>pendingup = &#34;!git log origin/\&#34;$(git rev-parse --abbrev-ref HEAD)\&#34;..HEAD --pretty=oneline --abbrev-commit --format=&#39;%Cgreen%cr:%Creset %C(auto)%h%Creset %s&#39;&#34;
</code></pre></li>
</ul>
<h1 id="more">More?</h1>
<p>I have some others not documented here, but are in my <a href="https://github.com/Pondidum/config/blob/master/configs/.gitconfig">config repo</a> on Github.</p>
]]></content:encoded></item><item><title>Adding MSpec to your Git Bash</title><link>https://andydote.co.uk/2010/11/13/adding-mspec-to-your-git-bash/</link><pubDate>Sat, 13 Nov 2010 00:00:00 +0000</pubDate><guid>https://andydote.co.uk/2010/11/13/adding-mspec-to-your-git-bash/</guid><description>My workflow involves Visual Studio, Notepad++ and Git Bash. I don&amp;rsquo;t use much Visual Studio integration, and prefer to run most things from the command line.
Now when it comes to testing projects, my tool of choice is MSpec (Machine.Specifications), which I decided would be nice if I could run from my Git Bash.
$ mspec bin/project.specs.dll To do this, you need to write a Shell Script with the following contents:</description><content:encoded><![CDATA[<p>My workflow involves Visual Studio, Notepad++ and Git Bash.  I don&rsquo;t use much Visual Studio integration, and prefer to run most things from the command line.</p>
<p>Now when it comes to testing projects, my tool of choice is MSpec (Machine.Specifications), which I decided would be nice if I could run from my Git Bash.</p>
<pre><code>$ mspec bin/project.specs.dll
</code></pre>
<p>To do this, you need to write a Shell Script with the following contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>    <span style="color:#75715e">#!/bin/sh</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;D:\dev\downloaded-src\machine.specifications\Build\Release\mspec.exe&#34;</span> <span style="color:#e6db74">&#34;</span>$*<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">#obviously change this to your mspec path...</span>
</span></span></code></pre></div><p>Save it as <code>mspec</code> (no extension), and you can place it in one of two places:</p>
<ul>
<li>Your Home Directory: <code>C:\Users\&lt;name&gt;\</code>, useful if it&rsquo;s just for you</li>
<li>The Git Bin Directory: <code>C:\Program Files\Git\bin</code>, for if you want all users to be able to run the script</li>
</ul>
<p>Restart your git bash, and you can now use the command <code>mspec</code> to run all your specifications.</p>
]]></content:encoded></item></channel></rss>