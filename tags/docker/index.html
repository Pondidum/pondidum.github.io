<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>docker | Andy Dote</title><meta name=keywords content><meta name=description content><meta name=author content><link rel=canonical href=https://andydote.co.uk/tags/docker/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://andydote.co.uk/tags/docker/rss.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="docker"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://andydote.co.uk/tags/docker/"><meta name=twitter:card content="summary"><meta name=twitter:title content="docker"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>docker</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>How do you tag docker images?</h2></header><div class=entry-content><p>An interesting question came up at work today: how do you tag your Docker images? In previous projects, I’ve always used a short git sha, or sometimes a semver, but with no great consistency.
As luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn’t make a lot of sense and, worst of all, it was a manual process....</p></div><footer class=entry-footer><span title='2021-11-10 00:00:00 +0000 UTC'>November 10, 2021</span>&nbsp;·&nbsp;6 min</footer><a class=entry-link aria-label="post link to How do you tag docker images?" href=https://andydote.co.uk/2021/11/10/docker-tagging/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Forking Multi Container Docker Builds</h2></header><div class=entry-content><p>Following on from my last post on Isolated Multistage Docker Builds, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.
The Problem When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.
For example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving....</p></div><footer class=entry-footer><span title='2020-11-03 00:00:00 +0000 UTC'>November 3, 2020</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Forking Multi Container Docker Builds" href=https://andydote.co.uk/2020/11/03/docker-multi-output/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Isolated Docker Multistage Images</h2></header><div class=entry-content><p>Often when building applications, I will use a multistage docker build for output container size and efficiency, but will run the build in two halves, to make use of the extra assets in the builder container, something like this:
docker build \ --target builder \ -t builder:$GIT_COMMIT \ . docker run --rm \ -v "$PWD/artefacts/tests:/artefacts/tests" \ builder:$GIT_COMMIT \ yarn ci:test docker run --rm \ -v "$PWD/artefacts/lint:/artefacts/lint" \ builder:$GIT_COMMIT \ yarn ci:lint docker build \ --cache-from builder:$GIT_COMMIT \ --target output \ -t app:$GIT_COMMIT \ ....</p></div><footer class=entry-footer><span title='2020-11-01 00:00:00 +0000 UTC'>November 1, 2020</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Isolated Docker Multistage Images" href=https://andydote.co.uk/2020/11/01/docker-multistage-containers/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Sharing Docker Layers Between Build Agents</h2></header><div class=entry-content><p>Recently, I noticed that when we pull a new version of our application’s docker container, it fetches all layers, not just the ones that change.
The problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn’t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build....</p></div><footer class=entry-footer><span title='2020-05-14 00:00:00 +0000 UTC'>May 14, 2020</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Sharing Docker Layers Between Build Agents" href=https://andydote.co.uk/2020/05/14/docker-layer-sharing/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Nomad Isolated Exec</h2></header><div class=entry-content><p>One of the many features of Nomad that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt “Task Drivers” there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.
The one I want to talk about today, however, is called exec. This Task Driver runs any given executable, so if you have an application which you don’t want (or can’t) put into a container, you can still schedule it with Nomad....</p></div><footer class=entry-footer><span title='2020-02-29 00:00:00 +0000 UTC'>February 29, 2020</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Nomad Isolated Exec" href=https://andydote.co.uk/2020/02/29/nomad-isolated-exec/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Hyper-V, Docker, and Networking Drama</h2></header><div class=entry-content><p>I had a major problem a few hours before giving my Nomad: Kubernetes Without the Complexity talk this morning: the demo stopped working.
Now, the first thing to note is the entire setup of the demo is scripted, and the scripts hadn’t changed. The only thing I had done was restart the machine, and now things were breaking.
The Symptoms A docker container started inside the guest VMs with a port mapped to the machine’s public IP wasn’t resolvable outside the host....</p></div><footer class=entry-footer><span title='2019-03-22 00:00:00 +0000 UTC'>March 22, 2019</span>&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Hyper-V, Docker, and Networking Drama" href=https://andydote.co.uk/2019/03/22/hyperv-networking/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Fixing Docker volume paths on Git Bash on Windows</h2></header><div class=entry-content><p>My normal development laptop runs Windows, but like a lot of developers, I make huge use of Docker, which I run under Hyper-V. I also heavily use the git bash terminal on windows to work.
Usually, everything works as expected, but I was recently trying to run an ELK (Elasticsearch, Logstash, Kibana) container, and needed to pass in an extra configuration file for Logstash. This caused me a lot of trouble, as nothing was working as expected....</p></div><footer class=entry-footer><span title='2018-06-18 00:00:00 +0000 UTC'>June 18, 2018</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Fixing Docker volume paths on Git Bash on Windows" href=https://andydote.co.uk/2018/06/18/git-bash-docker-volume-paths/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Vagrant in the world of Docker</h2></header><div class=entry-content><p>I gave a little talk at work recently on my use of Vagrant, what it is, and why it is still useful in a world full of Docker containers.
So, What is Vagrant? Vagrant is a product by Hashicorp, and is for scripting the creation of (temporary) virtual machines. It’s pretty fast to create a virtual machine with too, as it creates them from a base image (known as a “box”....</p></div><footer class=entry-footer><span title='2017-10-22 00:00:00 +0000 UTC'>October 22, 2017</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Vagrant in the world of Docker" href=https://andydote.co.uk/2017/10/22/vagrant-in-a-world-of-docker/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Integration Testing with Dotnet Core, Docker and RabbitMQ</h2></header><div class=entry-content><p>When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.
For one of my libraries (RabbitHarness) I have a set of tests which check it behaves as expected against a real instance of RabbitMQ. Ideally these tests will always be run, but sometimes RabbitMQ just isn’t available such as when running on AppVeyor builds, or if I haven’t started my local RabbitMQ Docker container....</p></div><footer class=entry-footer><span title='2017-10-02 00:00:00 +0000 UTC'>October 2, 2017</span>&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to Integration Testing with Dotnet Core, Docker and RabbitMQ" href=https://andydote.co.uk/2017/10/02/dotnet-core-docker-integration-tests/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>Update all Docker images</h2></header><div class=entry-content><p>My work’s wifi is much faster than my 4G connection, so periodically I want to update all my docker images on my personal laptop while at work.
As I want to just set it going and then forget about it, I use the following one liner to do a docker pull against each image on my local machine:
docker images | grep -v REPOSITORY | awk '{print $1}'| xargs -L1 docker pull If you only want to fetch the versions you have the tags for:...</p></div><footer class=entry-footer><span title='2017-01-16 00:00:00 +0000 UTC'>January 16, 2017</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Update all Docker images" href=https://andydote.co.uk/2017/01/16/update-all-docker-images/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://andydote.co.uk/tags/docker/page/2/>Next Page »</a></nav></footer></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>