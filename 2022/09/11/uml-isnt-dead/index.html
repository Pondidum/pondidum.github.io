<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The reports of UML's death are greatly exaggerated | Andy Dote</title><meta name=keywords content="uml,design"><meta name=description content="This is in response to the recent posts about the death of UML; while I think some parts of UML have fallen ill, the remaining parts are still alive, and useful to this day.
TLDR Out of 14 types of diagram there are 3 that I use on a regular basis: Activity Diagram, State Machine Diagram, and Sequence Diagram. I think the Timing Diagram is borderline, but I can only think of a couple of occasions when it has been useful."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2022/09/11/uml-isnt-dead/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="The reports of UML's death are greatly exaggerated"><meta property="og:description" content="This is in response to the recent posts about the death of UML; while I think some parts of UML have fallen ill, the remaining parts are still alive, and useful to this day.
TLDR Out of 14 types of diagram there are 3 that I use on a regular basis: Activity Diagram, State Machine Diagram, and Sequence Diagram. I think the Timing Diagram is borderline, but I can only think of a couple of occasions when it has been useful."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2022/09/11/uml-isnt-dead/"><meta property="article:section" content="post"><meta name=twitter:card content="summary"><meta name=twitter:title content="The reports of UML's death are greatly exaggerated"><meta name=twitter:description content="This is in response to the recent posts about the death of UML; while I think some parts of UML have fallen ill, the remaining parts are still alive, and useful to this day.
TLDR Out of 14 types of diagram there are 3 that I use on a regular basis: Activity Diagram, State Machine Diagram, and Sequence Diagram. I think the Timing Diagram is borderline, but I can only think of a couple of occasions when it has been useful."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"The reports of UML's death are greatly exaggerated","item":"https://andydote.co.uk/2022/09/11/uml-isnt-dead/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The reports of UML's death are greatly exaggerated","name":"The reports of UML\u0027s death are greatly exaggerated","description":"This is in response to the recent posts about the death of UML; while I think some parts of UML have fallen ill, the remaining parts are still alive, and useful to this day.\nTLDR Out of 14 types of diagram there are 3 that I use on a regular basis: Activity Diagram, State Machine Diagram, and Sequence Diagram. I think the Timing Diagram is borderline, but I can only think of a couple of occasions when it has been useful.","keywords":["uml","design"],"articleBody":"This is in response to the recent posts about the death of UML; while I think some parts of UML have fallen ill, the remaining parts are still alive, and useful to this day.\nTLDR Out of 14 types of diagram there are 3 that I use on a regular basis: Activity Diagram, State Machine Diagram, and Sequence Diagram. I think the Timing Diagram is borderline, but I can only think of a couple of occasions when it has been useful.\nWriting the diagrams in text and rendering them with Mermaid makes including them in documentation and websites painless, and the project is under active development.\nWhat I use often The diagram I use the most is the Sequence Diagram; It’s a great way to document how multiple systems (or micro services) will interact with each other. This diagram type has worked really well on both physical whiteboards, and in documentation. For example, part of a diagram I used to help design a system recently:\nsequenceDiagram participant api participant cas participant storage api -\u003e\u003e+cas: dependencies alt exists cas -\u003e\u003e+storage: get key storage -\u003e\u003e-cas: key, date else doesn't exist cas -\u003e\u003e+storage: get key storage -\u003e\u003e-cas: [not found] cas -\u003e\u003e+storage: write key, now() storage -\u003e\u003e-cas: [ok] end cas -\u003e\u003e-api: key path Next most used is the Activity Diagram, also more commonly known as a Flow Chart. This is mostly used when discribing an algorithm or process without needing to indicate different participants in the algorithm.\ngraph LR deps[key Dependencies] in_store{key in Storage?} write_to_store[key + current date to storage] update_date[Update store date from file] return[return key path] deps --\u003e in_store in_store --\u003e|Yes| update_date --\u003e return in_store --\u003e|No| write_to_store --\u003e return The last type that I use often is the State Machine Diagram; I think that State Machines themselves are an under utilised design pattern, and that a lot of complex problems can be rendered into the state pattern quite easily.\nIn a previous job there was a state machine with around 34 different states; being able to render this in a diagram made understanding the process much more approachable; even our support staff used the diagram to answer user questions.\nFor example, a line processor could be represented as follows, where depending on the kind of error the process will either terminate, or skip the line and wait for the next:\nstateDiagram state \"Wait for Line\" as wait state \"Process Line\" as process [*] --\u003e wait wait --\u003e process process --\u003e wait process --\u003e Error Error --\u003e wait Error --\u003e [*] Who else is using UML? The Mermaid library to render these kind of diagrams is being integrated all over the place: Github uses it to handle any ```mermaid blocks in your markdown files.\nLikewise, Hugo uses it when rendering your markdown content too (which is what has drawn these nice diagrams here.)\nThere are extensions for vscode to render them too.\nWhy should I care? Because explaining concepts is hard; and pictures often help. The old phrase of a picture being worth a thousand words is applicable here; its far easier to glance over a diagram than read a few paragraphs of prose.\nThis being the case, it is a good idea to have some common formats, standards or symbols to use, making the diagrams even clearer to people who already know the symbols (and don’t forget to explain them if they don’t know, and perhaps include a legend in your diagram.)\nWhen creating these diagrams was done in tools like Visio, and then screenshots embedded in documents (usually buried in a wiki where no one will find them), the barrier to making a useful diagram was high. Being able to embed them in the markdown in your repo, so they can be read from code even if they aren’t rendered lowers that barrier to making useful diagrams considerably.\nSo do your co-workers, contributors, and your future-self a favour, and add some simple diagrams to your docs.\n","wordCount":"655","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2022/09/11/uml-isnt-dead/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The reports of UML's death are greatly exaggerated</h1><div class=post-meta><span title='2022-09-11 00:00:00 +0000 UTC'>September 11, 2022</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>This is in response to the <a href=https://buttondown.email/hillelwayne/archive/why-uml-really-died/>recent</a> <a href=https://garba.org/posts/2021/uml/>posts</a> about the death of UML; while I think some parts of UML have fallen ill, the remaining parts are still alive, and useful to this day.</p><h2 id=tldr>TLDR<a hidden class=anchor aria-hidden=true href=#tldr>#</a></h2><p>Out of <a href=https://creately.com/blog/diagrams/uml-diagram-types-examples/>14 types of diagram</a> there are 3 that I use on a regular basis: <strong>Activity Diagram</strong>, <strong>State Machine Diagram</strong>, and <strong>Sequence Diagram</strong>. I think the Timing Diagram is borderline, but I can only think of a couple of occasions when it has been useful.</p><p>Writing the diagrams in text and rendering them with <a href=https://mermaid-js.github.io/mermaid/#/>Mermaid</a> makes including them in documentation and websites painless, and the project is under active development.</p><h2 id=what-i-use-often>What I use often<a hidden class=anchor aria-hidden=true href=#what-i-use-often>#</a></h2><p>The diagram I use the most is the <strong>Sequence Diagram</strong>; It&rsquo;s a great way to document how multiple systems (or micro services) will interact with each other. This diagram type has worked really well on both physical whiteboards, and in documentation. For example, part of a diagram I used to help design a system recently:</p><div class=mermaid align=left>sequenceDiagram
participant api
participant cas
participant storage
api ->>+cas: dependencies
alt exists
cas ->>+storage: get key
storage ->>-cas: key, date
else doesn't exist
cas ->>+storage: get key
storage ->>-cas: [not found]
cas ->>+storage: write key, now()
storage ->>-cas: [ok]
end
cas ->>-api: key path</div><p>Next most used is the <strong>Activity Diagram</strong>, also more commonly known as a <strong>Flow Chart</strong>. This is mostly used when discribing an algorithm or process without needing to indicate different participants in the algorithm.</p><div class=mermaid align=left>graph LR
deps[key Dependencies]
in_store{key in Storage?}
write_to_store[key + current date to storage]
update_date[Update store date from file]
return[return key path]
deps --> in_store
in_store -->|Yes| update_date --> return
in_store -->|No| write_to_store --> return</div><p>The last type that I use often is the <strong>State Machine Diagram</strong>; I think that State Machines themselves are an under utilised design pattern, and that a lot of complex problems can be rendered into the state pattern quite easily.</p><p>In a previous job there was a state machine with around 34 different states; being able to render this in a diagram made understanding the process much more approachable; even our support staff used the diagram to answer user questions.</p><p>For example, a line processor could be represented as follows, where depending on the kind of error the process will either terminate, or skip the line and wait for the next:</p><div class=mermaid align=left>stateDiagram
state "Wait for Line" as wait
state "Process Line" as process
[*] --> wait
wait --> process
process --> wait
process --> Error
Error --> wait
Error --> [*]</div><h2 id=who-else-is-using-uml>Who else is using UML?<a hidden class=anchor aria-hidden=true href=#who-else-is-using-uml>#</a></h2><p>The <a href=https://mermaid-js.github.io/mermaid/#/>Mermaid</a> library to render these kind of diagrams is being integrated all over the place: Github uses it to handle any <code>```mermaid</code> blocks in your markdown files.</p><p>Likewise, <a href=https://gohugo.io/>Hugo</a> uses it when rendering your markdown content too (which is what has drawn these nice diagrams here.)</p><p>There are <a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid">extensions for vscode</a> to render them too.</p><h2 id=why-should-i-care>Why should I care?<a hidden class=anchor aria-hidden=true href=#why-should-i-care>#</a></h2><p>Because explaining concepts is hard; and pictures often help. The old phrase of a picture being worth a thousand words is applicable here; its far easier to glance over a diagram than read a few paragraphs of prose.</p><p>This being the case, it is a good idea to have some common formats, standards or symbols to use, making the diagrams even clearer to people who already know the symbols (and don&rsquo;t forget to explain them if they don&rsquo;t know, and perhaps include a legend in your diagram.)</p><p>When creating these diagrams was done in tools like Visio, and then screenshots embedded in documents (usually buried in a wiki where no one will find them), the barrier to making a useful diagram was high. Being able to embed them in the markdown in your repo, <em>so they can be read from code even if they aren&rsquo;t rendered</em> lowers that barrier to making useful diagrams considerably.</p><p>So do your co-workers, contributors, and your future-self a favour, and add some simple diagrams to your docs.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/uml/>uml</a></li><li><a href=https://andydote.co.uk/tags/design/>design</a></li></ul><nav class=paginav><a class=next href=https://andydote.co.uk/2022/07/17/pulumi-faster-processes/><span class=title>Next Page »</span><br><span>Pulumi Conditional Infrastructure for Speed</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>