<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Database Column Prefixes | Andy Dote</title><meta name=keywords content="dotnet,story,database"><meta name=description content="Back in a previous company (the same place as where Debugging GDI Handle Leaks happened), there was an interesting convention in the database: all tables had a unique 3-letter prefix assigned to them, and all columns in that table must start with the prefix, which I&rsquo;ve written about before.
For example, a person table would have the prefix PEO, and the columns would be PEO_PersonID, PEO_FirstName, PEO_DateOfBirth, etc. When you wanted to create a new table, you opened the shared Excel sheet, added your table to the bottom, and made up a prefix that wasn&rsquo;t already in the sheet."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2025/01/26/database-column-prefixes/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Database Column Prefixes"><meta property="og:description" content="Back in a previous company (the same place as where Debugging GDI Handle Leaks happened), there was an interesting convention in the database: all tables had a unique 3-letter prefix assigned to them, and all columns in that table must start with the prefix, which I&rsquo;ve written about before.
For example, a person table would have the prefix PEO, and the columns would be PEO_PersonID, PEO_FirstName, PEO_DateOfBirth, etc. When you wanted to create a new table, you opened the shared Excel sheet, added your table to the bottom, and made up a prefix that wasn&rsquo;t already in the sheet."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2025/01/26/database-column-prefixes/"><meta property="article:section" content="post"><meta name=twitter:card content="summary"><meta name=twitter:title content="Database Column Prefixes"><meta name=twitter:description content="Back in a previous company (the same place as where Debugging GDI Handle Leaks happened), there was an interesting convention in the database: all tables had a unique 3-letter prefix assigned to them, and all columns in that table must start with the prefix, which I&rsquo;ve written about before.
For example, a person table would have the prefix PEO, and the columns would be PEO_PersonID, PEO_FirstName, PEO_DateOfBirth, etc. When you wanted to create a new table, you opened the shared Excel sheet, added your table to the bottom, and made up a prefix that wasn&rsquo;t already in the sheet."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Database Column Prefixes","item":"https://andydote.co.uk/2025/01/26/database-column-prefixes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Database Column Prefixes","name":"Database Column Prefixes","description":"Back in a previous company (the same place as where Debugging GDI Handle Leaks happened), there was an interesting convention in the database: all tables had a unique 3-letter prefix assigned to them, and all columns in that table must start with the prefix, which I\u0026rsquo;ve written about before.\nFor example, a person table would have the prefix PEO, and the columns would be PEO_PersonID, PEO_FirstName, PEO_DateOfBirth, etc. When you wanted to create a new table, you opened the shared Excel sheet, added your table to the bottom, and made up a prefix that wasn\u0026rsquo;t already in the sheet.","keywords":["dotnet","story","database"],"articleBody":"Back in a previous company (the same place as where Debugging GDI Handle Leaks happened), there was an interesting convention in the database: all tables had a unique 3-letter prefix assigned to them, and all columns in that table must start with the prefix, which I’ve written about before.\nFor example, a person table would have the prefix PEO, and the columns would be PEO_PersonID, PEO_FirstName, PEO_DateOfBirth, etc. When you wanted to create a new table, you opened the shared Excel sheet, added your table to the bottom, and made up a prefix that wasn’t already in the sheet. Even link tables (for many-to-many relationships) were not immune to this rule.\nWith over 100 tables in the database, finding a prefix which was vaguely related to the table’s purpose became harder and harder, especially for common letters, such as C which off the top of my head had tables like Companies, Candidates, Contacts, Categories,Contracts, ContractAttachments, ContractExceptions, and a bunch of link tables to go with them all.\nWhen asked, the DBA said that the reason the convention existed was to prevent column name conflicts when joining tables; all columns would be globally unique! This made some level of sense for simple queries:\nselect CAN_CandidateID, PEO_FirstName, PEO_LastName from candidates join people on CAN_PersonID = PEO_PersonID where CAN_CandidateID = @candidateID The problem was that this didn’t really solve the issue of columns not being ambiguous; queries often needed to join to the person table mulitple times, often via another table:\nselect CAN_CandidateID, peo.PEO_FirstName + ' ' + peo.PEO_LastName as 'name', creatorperson.PEO_FirstName + ' ' + creatorperson.PEO_LastName as 'creator', modifierperson.PEO_FirstName + ' ' + modifierperson.PEO_LastName as 'modifier' from candidates join people peo on CAN_PersonID = peo.PEO_PersonID join users creator on creator.USR_UserID = CAN_CreatedBy join people creatorperson on creatorperson.PEO_PersonID = creator.USR_PersonID join users modifier on modifier.USR_UserID = CAN_ModifiedBy join people modifierperson on modifierperson.PEO_PersonID = creator.USR_PersonID where CAN_CandidateID = @candidateID A thing of pure beauty, as you can see. Not only were all the sql statements far longer than they needed to be, and you often needed to figure out some obscure prefixes, you end up “stuttering” with things like person.PEO_PersonID - how many times do I need to know this is a PersonID in a single sentence?\nThe primary key of each table had to include the table name too. I’m not actually convinced this is a bad idea; having a bunch of columns called id doesn’t really make things clear when joining 6 tables.\nThe interesting part of this is that it’s all useless; the database server we used supported table aliases (as seen above), so we could use those and drop the prefixes entirely:\nselect CandidateID, p.FirstName + ' ' + p.LastName as 'name', creatorperson.FirstName + ' ' + creatorperson.LastName as 'creator', modifierperson.FirstName + ' ' + modifierperson.LastName as 'modifier' from candidates c join people p on c.PersonID = p.PersonID join users creator on creator.UserID = c.CreatedBy join people creatorperson on creatorperson.PersonID = creator.PersonID join users modifier on modifier.UserID = c.ModifiedBy join people modifierperson on modifierperson.PersonID = creator.PersonID where CandidateID = @candidateID Shorter, at least.\nThe table relationships didn’t always help matters either; the idea of the Person table was that a person could exist as multiple entities in our system; they could be a user, a candidate, and a contact. Not that this actually happened; they had unique person records for each of their entities.\nThe table prefixes also meant that when we wanted to use a microORM (Dapper, which only maps queries into objects), we had to make every query alias every column, otherwise our property names would have to also include the prefixes, and we really didn’t want the column prefixes polluting the rest of the domain!\nWe never got rid of this scheme in the primary database; the change wasn’t worth doing. If we had started making new tables without prefixes, we would still have had 100+ old tables with the prefixes, and no chance of fixing them as usually it involved dropping and recreating the tables. Definitely not worth the hassle.\nHowever, when we started creating separate databases for services which didn’t rely on any data in the main database, the column prefix was not used. In those services, everything felt a little smoother and a little less noisy.\n","wordCount":"712","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2025/01/26/database-column-prefixes/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Database Column Prefixes</h1><div class=post-meta><span title='2025-01-26 00:00:00 +0000 UTC'>January 26, 2025</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>Back in a previous company (the same place as where <a href=/2025/01/11/debugging-gdi-handles/>Debugging GDI Handle Leaks</a> happened), there was an interesting convention in the database: all tables had a unique 3-letter prefix assigned to them, and all columns in that table <strong>must</strong> start with the prefix, which I&rsquo;ve written about <a href=/2014/03/29/using-a-micro-orm-to-decouple-your-db-access/>before</a>.</p><p>For example, a <code>person</code> table would have the prefix <code>PEO</code>, and the columns would be <code>PEO_PersonID</code>, <code>PEO_FirstName</code>, <code>PEO_DateOfBirth</code>, etc. When you wanted to create a new table, you opened the shared Excel sheet, added your table to the bottom, and made up a prefix that wasn&rsquo;t already in the sheet. Even link tables (for many-to-many relationships) were not immune to this rule.</p><p>With over 100 tables in the database, finding a prefix which was vaguely related to the table&rsquo;s purpose became harder and harder, especially for common letters, such as <code>C</code> which off the top of my head had tables like <code>Companies</code>, <code>Candidates</code>, <code>Contacts</code>, <code>Categories</code>,<code>Contracts</code>, <code>ContractAttachments</code>, <code>ContractExceptions</code>, and a bunch of link tables to go with them all.</p><p>When asked, the DBA said that the reason the convention existed was to prevent column name conflicts when joining tables; all columns would be globally unique! This made some level of sense for simple queries:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>  CAN_CandidateID,
</span></span><span style=display:flex><span>        PEO_FirstName,
</span></span><span style=display:flex><span>        PEO_LastName
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>    candidates
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people <span style=color:#66d9ef>on</span> CAN_PersonID <span style=color:#f92672>=</span> PEO_PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>   CAN_CandidateID <span style=color:#f92672>=</span> <span style=color:#f92672>@</span>candidateID
</span></span></code></pre></div><p>The problem was that this didn&rsquo;t really solve the issue of columns not being ambiguous; queries often needed to join to the person table mulitple times, often via another table:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>  CAN_CandidateID,
</span></span><span style=display:flex><span>        peo.PEO_FirstName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> peo.PEO_LastName <span style=color:#66d9ef>as</span> <span style=color:#e6db74>&#39;name&#39;</span>,
</span></span><span style=display:flex><span>        creatorperson.PEO_FirstName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> creatorperson.PEO_LastName <span style=color:#66d9ef>as</span> <span style=color:#e6db74>&#39;creator&#39;</span>,
</span></span><span style=display:flex><span>        modifierperson.PEO_FirstName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> modifierperson.PEO_LastName <span style=color:#66d9ef>as</span> <span style=color:#e6db74>&#39;modifier&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>    candidates
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people peo             <span style=color:#66d9ef>on</span> CAN_PersonID <span style=color:#f92672>=</span> peo.PEO_PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    users creator          <span style=color:#66d9ef>on</span> creator.USR_UserID <span style=color:#f92672>=</span> CAN_CreatedBy
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people creatorperson   <span style=color:#66d9ef>on</span> creatorperson.PEO_PersonID <span style=color:#f92672>=</span> creator.USR_PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    users modifier         <span style=color:#66d9ef>on</span> modifier.USR_UserID <span style=color:#f92672>=</span> CAN_ModifiedBy
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people modifierperson  <span style=color:#66d9ef>on</span> modifierperson.PEO_PersonID <span style=color:#f92672>=</span> creator.USR_PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>   CAN_CandidateID <span style=color:#f92672>=</span> <span style=color:#f92672>@</span>candidateID
</span></span></code></pre></div><p>A thing of pure beauty, as you can see. Not only were all the sql statements far longer than they needed to be, and you often needed to figure out some obscure prefixes, you end up &ldquo;stuttering&rdquo; with things like <code>person.PEO_PersonID</code> - how many times do I need to know this is a PersonID in a single sentence?</p><p>The primary key of each table had to include the table name too. I&rsquo;m not actually convinced this is a bad idea; having a bunch of columns called <code>id</code> doesn&rsquo;t really make things clear when joining 6 tables.</p><p>The interesting part of this is that it&rsquo;s all useless; the database server we used supported table aliases (as seen above), so we could use those and drop the prefixes entirely:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span>  CandidateID,
</span></span><span style=display:flex><span>        p.FirstName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> p.LastName <span style=color:#66d9ef>as</span> <span style=color:#e6db74>&#39;name&#39;</span>,
</span></span><span style=display:flex><span>        creatorperson.FirstName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> creatorperson.LastName <span style=color:#66d9ef>as</span> <span style=color:#e6db74>&#39;creator&#39;</span>,
</span></span><span style=display:flex><span>        modifierperson.FirstName <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#f92672>+</span> modifierperson.LastName <span style=color:#66d9ef>as</span> <span style=color:#e6db74>&#39;modifier&#39;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span>    candidates <span style=color:#66d9ef>c</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people p               <span style=color:#66d9ef>on</span> <span style=color:#66d9ef>c</span>.PersonID <span style=color:#f92672>=</span> p.PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    users creator          <span style=color:#66d9ef>on</span> creator.UserID <span style=color:#f92672>=</span> <span style=color:#66d9ef>c</span>.CreatedBy
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people creatorperson   <span style=color:#66d9ef>on</span> creatorperson.PersonID <span style=color:#f92672>=</span> creator.PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    users modifier         <span style=color:#66d9ef>on</span> modifier.UserID <span style=color:#f92672>=</span> <span style=color:#66d9ef>c</span>.ModifiedBy
</span></span><span style=display:flex><span><span style=color:#66d9ef>join</span>    people modifierperson  <span style=color:#66d9ef>on</span> modifierperson.PersonID <span style=color:#f92672>=</span> creator.PersonID
</span></span><span style=display:flex><span><span style=color:#66d9ef>where</span>   CandidateID <span style=color:#f92672>=</span> <span style=color:#f92672>@</span>candidateID
</span></span></code></pre></div><p>Shorter, at least.</p><p>The table relationships didn&rsquo;t always help matters either; the idea of the <code>Person</code> table was that a person could exist as multiple entities in our system; they could be a user, a candidate, and a contact. Not that this actually happened; they had unique person records for each of their entities.</p><p>The table prefixes also meant that when we wanted to use a microORM (<a href=https://www.learndapper.com/>Dapper</a>, which <strong>only</strong> maps queries into objects), we had to make every query alias every column, otherwise our property names would have to also include the prefixes, and we really didn&rsquo;t want the column prefixes polluting the rest of the domain!</p><p>We never got rid of this scheme in the primary database; the change wasn&rsquo;t worth doing. If we had started making new tables without prefixes, we would still have had 100+ old tables with the prefixes, and no chance of fixing them as usually it involved dropping and recreating the tables. Definitely not worth the hassle.</p><p>However, when we started creating separate databases for services which didn&rsquo;t rely on any data in the main database, the column prefix was not used. In those services, everything felt a little smoother and a little less noisy.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/dotnet/>dotnet</a></li><li><a href=https://andydote.co.uk/tags/story/>story</a></li><li><a href=https://andydote.co.uk/tags/database/>database</a></li></ul><nav class=paginav><a class=next href=https://andydote.co.uk/2025/01/19/explicit-vs-implicit-code/><span class=title>Next Page »</span><br><span>Explicit vs Implicit code</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>