<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Outside In Design | Andy Dote</title><meta name=keywords content="configuration,architecture,design"><meta name=description content="Following on from my previous post about not having too much configuration, I want to talk about how I design software.
I try and follow what I call &ldquo;outside in design&rdquo;; I try and make something that requires the bare minimum amount of configuration to cover the most common of use-cases. Once this functionality is working, further configuration can be added to cover the next most common use cases.
API Reduction As A Feature The first example I want to go through is how I removed options from an HTTP rate limiter we use."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2024/12/12/system-design-outside-in/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Outside In Design"><meta property="og:description" content="Following on from my previous post about not having too much configuration, I want to talk about how I design software.
I try and follow what I call &ldquo;outside in design&rdquo;; I try and make something that requires the bare minimum amount of configuration to cover the most common of use-cases. Once this functionality is working, further configuration can be added to cover the next most common use cases.
API Reduction As A Feature The first example I want to go through is how I removed options from an HTTP rate limiter we use."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2024/12/12/system-design-outside-in/"><meta property="article:section" content="post"><meta name=twitter:card content="summary"><meta name=twitter:title content="Outside In Design"><meta name=twitter:description content="Following on from my previous post about not having too much configuration, I want to talk about how I design software.
I try and follow what I call &ldquo;outside in design&rdquo;; I try and make something that requires the bare minimum amount of configuration to cover the most common of use-cases. Once this functionality is working, further configuration can be added to cover the next most common use cases.
API Reduction As A Feature The first example I want to go through is how I removed options from an HTTP rate limiter we use."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Outside In Design","item":"https://andydote.co.uk/2024/12/12/system-design-outside-in/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Outside In Design","name":"Outside In Design","description":"Following on from my previous post about not having too much configuration, I want to talk about how I design software.\nI try and follow what I call \u0026ldquo;outside in design\u0026rdquo;; I try and make something that requires the bare minimum amount of configuration to cover the most common of use-cases. Once this functionality is working, further configuration can be added to cover the next most common use cases.\nAPI Reduction As A Feature The first example I want to go through is how I removed options from an HTTP rate limiter we use.","keywords":["configuration","architecture","design"],"articleBody":"Following on from my previous post about not having too much configuration, I want to talk about how I design software.\nI try and follow what I call “outside in design”; I try and make something that requires the bare minimum amount of configuration to cover the most common of use-cases. Once this functionality is working, further configuration can be added to cover the next most common use cases.\nAPI Reduction As A Feature The first example I want to go through is how I removed options from an HTTP rate limiter we use. There are many teams using rate limiters, and we have noticed that there are often similar mistakes made in how they work and duplication of domain-specific functionality.\nIn order to make life easier for most users, a new rate limiter was made which reduced the API surface area, only exposing the bare minimum options.\nAlgorithm. Instead of offering many different types of algorithm (for example Token Bucket, Leaky Bucket, Fixed Window Counter, and Sliding Window), the rate limiter only uses Sliding Window.\nSizes.: By forcing the use of a specific algorithm, we eliminate a lot of algorithm specific options, such as bucket capacity, refill/drain rate, and window overlap. We expose a single option of WindowSeconds with a default vault of 60.\nPenalties. We also decided to not expose how long a ban is, and instead make it a multiple of the WindowSeconds option, in our case WindowSeconds * 3.\nSelection Criteria. Rate limiters we observed could filter by many different properties, such as IP Address, Headers, Cookies, Path, Query, Status Code, etc. Our rate limiter has the following rules:\nAccount and Path Account and (bad) Status IP Address and Path IP Address and (bad) Status Anonymous IP The way the account is detected is the same for all services in our domain, so we can centralise the checking code to be identical in all instances.\nTriggering. For triggering, we went with the simplest thing possible: if any counter’s value goes over a threshold, then a ban is issued for the Account or IP address triggering the ban. The threshold value is exposed as MaxRequests with a default value of 100\nFinally, we expose one additional configuration: Storage. This is an optional field which you can set to a Valkey or Redis-compatible client so that if you have many instances of your application, the rate-limiting is shared amongst all instances.\nFor most of our teams, using a rate limiter is now this:\nlimiter := \u0026org.NewRateLimiter( org.WithStorage(valkey), org.WithMaxRequests(80), ) mux := http.NewServeMux() mux.Handle(\"/\", limiter(apiRootHandler)) For teams that need more customisation, we recommend they reach out to us to see what their needs are; the outcome would usually be embedding and customising the rate-limiter, forking the library, or using an off-the-shelf library directly. So far very few teams have needed extra customisation.\nThe downside to this approach is if we want to change some detail about how the rate limiter works; we now have to find all the teams using it to make sure we don’t break their workflow. For Go projects, we typically bump the major version of the library, and have explicit messaging about the differences in the readme.\nOrganisation Conventions The next example is trying to show off what we can achive when using conventions; some of these conventions were in place before we wrote this code, and some have become conventions since.\nWhen it comes to building docker containers, there are a few things that people, in general, want:\nthe container to be built tests to be run, preventing publishing broken containers the (working) container to be published somewhere so it can be used extra artifacts from the build to be collected (test reports, coverage, etc.) it to be fast The problem with all these things is in the details; building itself is fairly straightforward, but publishing requires knowing where to publish, any credentials required, and how to name and version the container. Likewise, artifact collection requires knowing where the artifacts are to be collected from, and where to publish them to (along with authentication etc.)\nThe even bigger issue is “to be fast”; people don’t care about how its fast, they just want fast. This means not only making a cacheable dockerfile but doing that caching somehow; with ephemeral build agents, that caching becomes harder.\nWe can go through our requirements and see what ones we know the answers to already and what we need to get from users:\nDocker Registry. The internal Secret Management Service (SMS) has a convention for where your docker registry is, and what the credentials are: read from /teams/$team_name/docker/registry.\nContainer Path. We always publish to $registry/$team_name/$repo_name/$container_name.\nContainer Name. A repository can have multiple containers, or the name of the container can differ from the repository. So for this property, we need the users to supply something.\nContainer Version. We decided that a short git SHA is enough for versioning.\nCaching. The registry has a second path convention for storing cache contents: $registry/cache/$team_name/$repo_name/$container_name.\nArtifacts. Artifacts are published to the Github Actions artifacts, so no extra authentication or settings are needed. We decided that if the .artifacts folder exists and has contents, that is what will get stored.\nGiven the above analysis, we decided on 4 configuration options:\nteam_name: no default. We will use this value to find the registry information and build container and cache paths. container_name: no default. You need to tell us what the name of your container should be. build_args: default empty. Supply extra arguments to the docker build command. Some teams need to inject extra information from the host. dockerfile: default ./Dockerfile. Some teams have multiple dockerfiles in their repository, or keep the files in subfolders. By relying on the team_name parameter, so many other options can be eliminated, and it turns out most people don’t care what exact path their containers are uploaded to, as long as they are accessible when it comes to being used in a deployment environment. This is foreshadowing!\nFor most teams, their build workflow becomes just two steps: checkout sourcecode, and build the container:\nsteps: - uses: actions/checkout@v4 - uses: org/docker-build@v1 with: team_name: \"team-one\" container_name: api Organisation Conventions Two Now that we have a shared way to build docker containers with low configuration, the next logical step was figuring out if we could do the same for deployment. It turns out a lot of the conventions used to build the container can be applied to deployment: docker registry, container path, container name, and container version are all the same between the two. In addition, we need to add a few more: the name of the environment being deployed to and the path to your deployment definition file (for example, a Nomad job).\nsteps: - uses: org/nomad-docker@v1 with: team_name: \"team-one\" container_name: api environment: live The Pit of Success We also like to leverage The Pit of Success, which seems to originate from Rico Mariani; we want to make doing the easiest thing to be the correct thing.\nTo that end, we provide a library to populate an app’s secrets. This library handles multiple forms of authentication for different runtime locations (developer machine, nomad cluster, lambda, etc.), and handles where the secrets themselves are located.\nThe library’s usage boils down to two things. A single struct to represent their secrets:\ntype Secrets struct { ClientID string ClientSecret string ApiToken string // etc } And a single function call to populate it:\nerr := org.ReadSecrets(ctx, \"management-api\", secrets) This function call does a lot behind the scenes:\nAuthentication. This varies based on where the app is running: on a developer machine, it uses the local cached secret manager credentials and triggers authentication flows if needed. When deployed, it uses the relevant secret authentication system for that environment (e.g. Nomad’s Vault integration or AWS Secret Manager in Lambda).\nSecret Location. It reads all the secrets for from a conventional path: /teams/$team_name/apps/$app_name/$env/*, where the values come from different places:\nteam_name comes from a common environment variable, and ReadSecrets errors if its not populated env comes from either an environment variable when the app is deployed somewhere or is set to local on a developer’s machine. app_name is supplied in code (management-api in this case) While teams can roll their own secret management integration, our library is so easy to use that almost no teams choose to do anything different.\nThe Golden Path Our tools form what we call our Golden Path, a term which seems to originate from spotify. We use it to define a way to develop and deploy software in a tried and tested manner. Teams are always free to choose their own path by changing what parts of the system they see fit.\nThe trade off teams are making is between maintenance burden and configuration; choose our tools, and you don’t need to worry about them working, but you need to follow our conventions and opinions.\nHow Do You Design Software? While this is working really well for me and my teams, there has to be other opinions too; I’d be interested in hearing how people do this for their teams and projects.\n","wordCount":"1520","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2024/12/12/system-design-outside-in/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Outside In Design</h1><div class=post-meta><span title='2024-12-12 00:00:00 +0000 UTC'>December 12, 2024</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><p>Following on from my previous post about not having <a href=/2024/10/31/too-much-configuration/>too much configuration</a>, I want to talk about how I design software.</p><p>I try and follow what I call &ldquo;outside in design&rdquo;; I try and make something that requires the bare minimum amount of configuration to cover the most common of use-cases. Once this functionality is working, further configuration can be added to cover the next most common use cases.</p><h2 id=api-reduction-as-a-feature>API Reduction As A Feature<a hidden class=anchor aria-hidden=true href=#api-reduction-as-a-feature>#</a></h2><p>The first example I want to go through is how I removed options from an HTTP rate limiter we use. There are many teams using rate limiters, and we have noticed that there are often similar mistakes made in how they work and duplication of domain-specific functionality.</p><p>In order to make life easier for <em>most</em> users, a new rate limiter was made which reduced the API surface area, only exposing the bare minimum options.</p><p><strong>Algorithm.</strong> Instead of offering many different types of algorithm (for example <code>Token Bucket</code>, <code>Leaky Bucket</code>, <code>Fixed Window Counter</code>, and <code>Sliding Window</code>), the rate limiter only uses <code>Sliding Window</code>.</p><p><strong>Sizes.</strong>: By forcing the use of a specific algorithm, we eliminate a lot of algorithm specific options, such as bucket capacity, refill/drain rate, and window overlap. We expose a single option of <code>WindowSeconds</code> with a default vault of <code>60</code>.</p><p><strong>Penalties.</strong> We also decided to not expose how long a ban is, and instead make it a multiple of the <code>WindowSeconds</code> option, in our case <code>WindowSeconds * 3</code>.</p><p><strong>Selection Criteria.</strong> Rate limiters we observed could filter by many different properties, such as IP Address, Headers, Cookies, Path, Query, Status Code, etc. Our rate limiter has the following rules:</p><ul><li>Account and Path</li><li>Account and (bad) Status</li><li>IP Address and Path</li><li>IP Address and (bad) Status</li><li>Anonymous IP</li></ul><p>The way the account is detected is the same for all services in our domain, so we can centralise the checking code to be identical in all instances.</p><p><strong>Triggering.</strong> For triggering, we went with the simplest thing possible: if any counter&rsquo;s value goes over a threshold, then a ban is issued for the Account or IP address triggering the ban. The threshold value is exposed as <code>MaxRequests</code> with a default value of <code>100</code></p><p>Finally, we expose one additional configuration: <code>Storage</code>. This is an optional field which you can set to a Valkey or Redis-compatible client so that if you have many instances of your application, the rate-limiting is shared amongst all instances.</p><p>For most of our teams, using a rate limiter is now this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>limiter</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>org</span>.<span style=color:#a6e22e>NewRateLimiter</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>org</span>.<span style=color:#a6e22e>WithStorage</span>(<span style=color:#a6e22e>valkey</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>org</span>.<span style=color:#a6e22e>WithMaxRequests</span>(<span style=color:#ae81ff>80</span>),
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>NewServeMux</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>mux</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/&#34;</span>, <span style=color:#a6e22e>limiter</span>(<span style=color:#a6e22e>apiRootHandler</span>))
</span></span></code></pre></div><p>For teams that need more customisation, we recommend they reach out to us to see what their needs are; the outcome would usually be embedding and customising the rate-limiter, forking the library, or using an off-the-shelf library directly. So far very few teams have needed extra customisation.</p><p>The downside to this approach is if we want to change some detail about how the rate limiter works; we now have to find all the teams using it to make sure we don&rsquo;t break their workflow. For Go projects, we typically bump the major version of the library, and have explicit messaging about the differences in the readme.</p><h2 id=organisation-conventions>Organisation Conventions<a hidden class=anchor aria-hidden=true href=#organisation-conventions>#</a></h2><p>The next example is trying to show off what we can achive when using conventions; some of these conventions were in place before we wrote this code, and some have become conventions since.</p><p>When it comes to building docker containers, there are a few things that people, in general, want:</p><ul><li>the container to be built</li><li>tests to be run, preventing publishing broken containers</li><li>the (working) container to be published somewhere so it can be used</li><li>extra artifacts from the build to be collected (test reports, coverage, etc.)</li><li>it to be fast</li></ul><p>The problem with all these things is in the details; building itself is fairly straightforward, but publishing requires knowing where to publish, any credentials required, and how to name and version the container. Likewise, artifact collection requires knowing where the artifacts are to be collected from, and where to publish them to (along with authentication etc.)</p><p>The even bigger issue is &ldquo;to be fast&rdquo;; people don&rsquo;t care about how its fast, they just want fast. This means not only making a cacheable dockerfile but doing that caching somehow; with ephemeral build agents, that caching becomes harder.</p><p>We can go through our requirements and see what ones we know the answers to already and what we need to get from users:</p><p><strong>Docker Registry.</strong> The internal Secret Management Service (SMS) has a convention for where your docker registry is, and what the credentials are: read from <code>/teams/$team_name/docker/registry</code>.</p><p><strong>Container Path.</strong> We always publish to <code>$registry/$team_name/$repo_name/$container_name</code>.</p><p><strong>Container Name.</strong> A repository can have multiple containers, or the name of the container can differ from the repository. So for this property, we need the users to supply something.</p><p><strong>Container Version.</strong> We decided that a short git SHA is enough for versioning.</p><p><strong>Caching.</strong> The registry has a second path convention for storing cache contents: <code>$registry/cache/$team_name/$repo_name/$container_name</code>.</p><p><strong>Artifacts.</strong> Artifacts are published to the Github Actions artifacts, so no extra authentication or settings are needed. We decided that if the <code>.artifacts</code> folder exists and has contents, that is what will get stored.</p><p>Given the above analysis, we decided on 4 configuration options:</p><ol><li><code>team_name</code>: no default. We will use this value to find the registry information and build container and cache paths.</li><li><code>container_name</code>: no default. You need to tell us what the name of your container should be.</li><li><code>build_args</code>: default empty. Supply extra arguments to the <code>docker build</code> command. Some teams need to inject extra information from the host.</li><li><code>dockerfile</code>: default <code>./Dockerfile</code>. Some teams have multiple dockerfiles in their repository, or keep the files in subfolders.</li></ol><p>By relying on the <code>team_name</code> parameter, so many other options can be eliminated, and it turns out most people don&rsquo;t care what exact path their containers are uploaded to, as long as they are accessible when it comes to being used in a deployment environment. This is foreshadowing!</p><p>For most teams, their build workflow becomes just two steps: checkout sourcecode, and build the container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@v4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>org/docker-build@v1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>team_name</span>: <span style=color:#e6db74>&#34;team-one&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>api</span>
</span></span></code></pre></div><h2 id=organisation-conventions-two>Organisation Conventions Two<a hidden class=anchor aria-hidden=true href=#organisation-conventions-two>#</a></h2><p>Now that we have a shared way to build docker containers with low configuration, the next logical step was figuring out if we could do the same for deployment. It turns out a lot of the conventions used to build the container can be applied to deployment: docker registry, container path, container name, and container version are all the same between the two. In addition, we need to add a few more: the name of the environment being deployed to and the path to your deployment definition file (for example, a Nomad job).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>steps</span>:
</span></span><span style=display:flex><span>- <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>org/nomad-docker@v1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>with</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>team_name</span>: <span style=color:#e6db74>&#34;team-one&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>container_name</span>: <span style=color:#ae81ff>api</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>: <span style=color:#ae81ff>live</span>
</span></span></code></pre></div><h2 id=the-pit-of-success>The Pit of Success<a hidden class=anchor aria-hidden=true href=#the-pit-of-success>#</a></h2><p>We also like to leverage The Pit of Success, which seems to originate from <a href=https://learn.microsoft.com/en-us/archive/blogs/brada/the-pit-of-success>Rico Mariani</a>; we want to make doing the easiest thing to be the correct thing.</p><p>To that end, we provide a library to populate an app&rsquo;s secrets. This library handles multiple forms of authentication for different runtime locations (developer machine, nomad cluster, lambda, etc.), and handles where the secrets themselves are located.</p><p>The library&rsquo;s usage boils down to two things. A single <code>struct</code> to represent their secrets:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Secrets</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ClientID</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ClientSecret</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ApiToken</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// etc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>And a single function call to populate it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>org</span>.<span style=color:#a6e22e>ReadSecrets</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;management-api&#34;</span>, <span style=color:#a6e22e>secrets</span>)
</span></span></code></pre></div><p>This function call does a lot behind the scenes:</p><p><strong>Authentication.</strong> This varies based on where the app is running: on a developer machine, it uses the local cached secret manager credentials and triggers authentication flows if needed. When deployed, it uses the relevant secret authentication system for that environment (e.g. Nomad&rsquo;s Vault integration or AWS Secret Manager in Lambda).</p><p><strong>Secret Location.</strong> It reads all the secrets for from a conventional path: <code>/teams/$team_name/apps/$app_name/$env/*</code>, where the values come from different places:</p><ul><li><code>team_name</code> comes from a common environment variable, and <code>ReadSecrets</code> errors if its not populated</li><li><code>env</code> comes from either an environment variable when the app is deployed somewhere or is set to <code>local</code> on a developer&rsquo;s machine.</li><li><code>app_name</code> is supplied in code (<code>management-api</code> in this case)</li></ul><p>While teams can roll their own secret management integration, our library is so easy to use that almost no teams choose to do anything different.</p><h2 id=the-golden-path>The Golden Path<a hidden class=anchor aria-hidden=true href=#the-golden-path>#</a></h2><p>Our tools form what we call our Golden Path, a term which seems to originate from <a href="https://engineering.atspotify.com/2020/08/how-we-use-golden-paths-to-solve-fragmentation-in-our-software-ecosystem/#:~:text=The%20Golden%20Path%20%E2%80%94%20as%20we,this%20opinionated%20and%20supported%20path.">spotify</a>. We use it to define a way to develop and deploy software in a tried and tested manner. Teams are always free to choose their own path by changing what parts of the system they see fit.</p><p>The trade off teams are making is between maintenance burden and configuration; choose our tools, and you don&rsquo;t need to worry about them working, but you need to follow our conventions and opinions.</p><h2 id=how-do-you-design-software>How Do You Design Software?<a hidden class=anchor aria-hidden=true href=#how-do-you-design-software>#</a></h2><p>While this is working really well for me and my teams, there has to be other opinions too; I&rsquo;d be interested in hearing how people do this for their teams and projects.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/configuration/>configuration</a></li><li><a href=https://andydote.co.uk/tags/architecture/>architecture</a></li><li><a href=https://andydote.co.uk/tags/design/>design</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2024/12/26/opentelemetry-cancelled-contexts/><span class=title>« Prev Page</span><br><span>Telemetry and Cancelled Contexts</span></a>
<a class=next href=https://andydote.co.uk/2024/11/24/print-debugging-tracing/><span class=title>Next Page »</span><br><span>Print debugging: a tool among other tools</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>