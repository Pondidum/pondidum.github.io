<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Feature Toggles: Reducing Coupling | Andy Dote</title><meta name=keywords content="feature flags,c#,di,microservices"><meta name=description content="One of the points I make in my Feature Toggles talk is that you shouldn&rsquo;t be querying a toggle&rsquo;s status all over your codebase. Ideally, each toggle gets checked in as few places as possible - preferably only one place. The advantage of doing this is that very little of your codebase needs to be coupled to the toggles (either the toggle itself or the library/system for managing toggles itself)."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2019/06/11/feature-toggles-reducing-coupling/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2b33c247bf6959372dd097f2cfdcd9f4d5019027cd9b1e28ae3d14c17c37ac00.css integrity="sha256-KzPCR79pWTct0Jfyz9zZ9NUBkCfNmx4orj0UwXw3rAA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Feature Toggles: Reducing Coupling"><meta property="og:description" content="One of the points I make in my Feature Toggles talk is that you shouldn&rsquo;t be querying a toggle&rsquo;s status all over your codebase. Ideally, each toggle gets checked in as few places as possible - preferably only one place. The advantage of doing this is that very little of your codebase needs to be coupled to the toggles (either the toggle itself or the library/system for managing toggles itself)."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2019/06/11/feature-toggles-reducing-coupling/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-06-11T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Feature Toggles: Reducing Coupling"><meta name=twitter:description content="One of the points I make in my Feature Toggles talk is that you shouldn&rsquo;t be querying a toggle&rsquo;s status all over your codebase. Ideally, each toggle gets checked in as few places as possible - preferably only one place. The advantage of doing this is that very little of your codebase needs to be coupled to the toggles (either the toggle itself or the library/system for managing toggles itself)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Feature Toggles: Reducing Coupling","item":"https://andydote.co.uk/2019/06/11/feature-toggles-reducing-coupling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Feature Toggles: Reducing Coupling","name":"Feature Toggles: Reducing Coupling","description":"One of the points I make in my Feature Toggles talk is that you shouldn\u0026rsquo;t be querying a toggle\u0026rsquo;s status all over your codebase. Ideally, each toggle gets checked in as few places as possible - preferably only one place. The advantage of doing this is that very little of your codebase needs to be coupled to the toggles (either the toggle itself or the library/system for managing toggles itself).","keywords":["feature flags","c#","di","microservices"],"articleBody":"One of the points I make in my Feature Toggles talk is that you shouldn’t be querying a toggle’s status all over your codebase. Ideally, each toggle gets checked in as few places as possible - preferably only one place. The advantage of doing this is that very little of your codebase needs to be coupled to the toggles (either the toggle itself or the library/system for managing toggles itself).\nThis post will go over several situations when that seems hard to do, namely: multiple services, multiple distinct areas of a codebase, and multiple times in a complex class or method. As in the previous post on this, we will be using Branch By Abstraction to do most of the heavy lifting.\nMultiple Services Multiple services interacting with the same feature toggle is a problematic situation to deal with, especially if multiple teams own the different services.\nOne of the main issues with this is trying to coordinate the two (or more) services. For example, if one team needs to switch off their implementation due to a problem, should the other services also get turned off too? To compound on this problem, what happens if one system can react to the toggle change faster than the other?\nServices changing configuration at different speeds can also cause issues with handling in-flight requests too: if the message format is different when the toggle is on, will the receiving system be able to process a message produced when the toggle was in one state but consumed in the other state?\nWe can solve some of this by using separate toggles for each service (and they are not allowed to query the other service’s toggle state), and by writing the services so that they can handle both old format and new format requests at the same time.\nFor example, if we had a sending system which when the toggle is off will send this DTO:\npublic class PurchaseOptions { public Address Address { get; set; } } And when the toggle is enabled, it will send the following DTO instead:\npublic class PurchaseOptions { public BillingAddress Address { get; set; } public DeliveryAddress Address { get; set; } } To make the receiving system handle this, we deserialize the request into a DTO which contains all possible versions of the address, and then use the best version based on our own toggle state:\npublic class PurchaseOptionsRequest { public Address Address { get; set; } public BillingAddress Address { get; set; } public DeliveryAddress Address { get; set; } } public class PurchaseController { public async Task Post(PurchaseOptionsRequest request) { if (separateAddresses.Enabled) { var deliveryAddress = request.DeliveryAddress ?? request.Address; var billingAddress = request.BillingAddress ?? request.Address; ConfigureDelivery(deliveryAddress); CreateInvoice(billingAddress, deliveryAddress); } else { var address = request.Address ?? request.DeliveryAddress ?? request.BillingAddress; ConfigureDelivery(address) CreateInvoice(address, address); } } } Note how both sides of the toggle check read all three possible address fields, but try to use different fields first. This means that no matter whether the sending service has it’s toggle on or not, we will use the correct address.\nMultiple Areas of the Codebase To continue using the address example, we might have a UI, Controller and Handler, which all need to act differently based on the same toggle:\nThe UI needs to display either one or two address editors The controller needs to have different validation logic for multiple addresses The Command Handler will need to dispatch different values We can solve this all by utilising Branch By Abstraction and Dependency Injection to make most of the codebase unaware that a feature toggle exists. Even the implementations won’t need to know about the toggles.\npublic class Startup { public void ConfigureContainer(ServiceRegistry services) { if (separateAddresses.Enabled) { services.Add(); services.Add(); services.Add(); } else { services.Add(); services.Add(); services.Add(); } } } Let’s look at how one of these might work. The IRequestValidator has a definition like so:\npublic interface IRequestValidator { public IEnumerable\u003cstring\u003e Validate(TRequest request); } There is a middleware in the API request pipeline which will pick the right validator out of the container, based on the request type being processed. We implement two validators, once for the single address, and one for multiaddress:\npublic class SingleAddressValidator : IRequestValidator { public IEnumerable\u003cstring\u003e Validate(SingleAddressRequest request) { //complex validation logic.. if (request.Address == null) yield return \"No Address specified\"; if (PostCode.Validate(request.Address.PostCode) == false) yield return \"Invalid Postcode\"; } } public class MultiAddressValidator : IRequestValidator { public IEnumerable\u003cstring\u003e Validate(MultiAddressRequest request) { var billingMessages = ValidateAddress(request.BillingAddress); if (billingMessages.Any()) return billingMessages; if (request.DifferentDeliveryAddress) return ValidateAddress(request.DeliveryAddress); } } The implementations themselves don’t need to know about the state of the toggle, as the container and middleware take care of picking the right implementation to use.\nMultiple Places in a Class/Method If you have a single method (or class) which needs to check the toggle state in multiple places, you can also use the same Branch by Abstraction technique as above, by creating a custom interface and pair of implementations, which contain all the functionality which changes.\nFor example, if we have a method for finding an offer for a customer’s basket, which has a few separate checks that the toggle is enabled in it:\npublic SuggestedBasket CreateOffer(CreateOfferCommand command) { if (newFeature.Enabled) { ExtraPreValidation(command).Throw(); } else { StandardPreValidation(command).Throw(); } var offer = SelectBestOffer(command.Items); if (offer == null \u0026\u0026 newFeature.Enabled) { offer = FindAlternativeOffer(command.Customer, command.Items); } return SuggestedBasket .From(command) .With(offer); } We can extract an interface for this, and replace the toggle specific parts with calls to the interface instead:\npublic interface ICreateOfferStrategy { IThrowable PreValidate(CreateOfferCommand command); Offer AlternativeOffer(CreateOfferCommand command, Offer existingOffer); } public class DefaultOfferStrategy : ICreateOfferStrategy { public IThrowable PreValidate(CreateOfferCommand command) { return StandardPreValidation(command); } public Offer AlternativeOffer(CreateOfferCommand command, Offer existingOffer) { return existingOffer; } } public class DefaultOfferStrategy : ICreateOfferStrategy { public IThrowable PreValidate(CreateOfferCommand command) { return ExtraPreValidation(command); } public Offer AlternativeOffer(CreateOfferCommand command, Offer existingOffer) { if (existingOffer != null) return existingOffer; return TryFindAlternativeOffer(command.Customer, command.Items, offer); } } public class OfferBuilder { private readonly ICreateOfferStrategy _strategy; public OfferBuilder(ICreateOfferStrategy strategy) { _strategy = strategy; } public SuggestedBasket CreateOffer(CreateOfferCommand command) { _strategy.PreValidation(command).Throw(); var offer = SelectBestOffer(command.Items); offer = _strategy.AlternativeOffer(command, offer); return SuggestedBasket .From(command) .With(offer); } } Now that we have done this, our CreateOffer method has shrunk dramatically and no longer needs to know about the toggle state, as like the rest of our DI examples, the toggle can be queried once in the startup of the service and the correct ICreateOfferStrategy implementation registered into the container.\nEnd Hopefully, this post will give a few insights into different ways of reducing the number of calls to your feature toggling library, and prevent you scattering lots of if statements around the codebase!\n","wordCount":"1112","inLanguage":"en","datePublished":"2019-06-11T00:00:00Z","dateModified":"2019-06-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2019/06/11/feature-toggles-reducing-coupling/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Feature Toggles: Reducing Coupling</h1><div class=post-meta><span title='2019-06-11 00:00:00 +0000 UTC'>June 11, 2019</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>One of the points I make in my <a href="https://www.youtube.com/watch?v=r7VI5x2XKXw">Feature Toggles talk</a> is that you shouldn&rsquo;t be querying a toggle&rsquo;s status all over your codebase. Ideally, each toggle gets checked in as few places as possible - preferably only one place. The advantage of doing this is that very little of your codebase needs to be coupled to the toggles (either the toggle itself or the library/system for managing toggles itself).</p><p>This post will go over several situations when that seems hard to do, namely: multiple services, multiple distinct areas of a codebase, and multiple times in a complex class or method. As in the <a href=/2019/06/03/feature-toggles-branch-by-abstraction/>previous post</a> on this, we will be using <a href=https://www.martinfowler.com/bliki/BranchByAbstraction.html>Branch By Abstraction</a> to do most of the heavy lifting.</p><h2 id=multiple-services>Multiple Services<a hidden class=anchor aria-hidden=true href=#multiple-services>#</a></h2><p>Multiple services interacting with the same feature toggle is a problematic situation to deal with, especially if multiple teams own the different services.</p><p>One of the main issues with this is trying to coordinate the two (or more) services. For example, if one team needs to switch off their implementation due to a problem, should the other services also get turned off too? To compound on this problem, what happens if one system can react to the toggle change faster than the other?</p><p>Services changing configuration at different speeds can also cause issues with handling in-flight requests too: if the message format is different when the toggle is on, will the receiving system be able to process a message produced when the toggle was in one state but consumed in the other state?</p><p>We can solve some of this by using separate toggles for each service (and they are not allowed to query the other service&rsquo;s toggle state), and by writing the services so that they can handle both old format and new format requests at the same time.</p><p>For example, if we had a sending system which when the toggle is off will send this DTO:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PurchaseOptions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Address Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And when the toggle is enabled, it will send the following DTO instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PurchaseOptions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BillingAddress Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DeliveryAddress Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To make the receiving system handle this, we deserialize the request into a DTO which contains all possible versions of the address, and then use the best version based on our own toggle state:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PurchaseOptionsRequest</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Address Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BillingAddress Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> DeliveryAddress Address { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PurchaseController</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;PurchaseOptionsResponse&gt; Post(PurchaseOptionsRequest request)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (separateAddresses.Enabled)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> deliveryAddress = request.DeliveryAddress ?? request.Address;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> billingAddress = request.BillingAddress ?? request.Address;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ConfigureDelivery(deliveryAddress);
</span></span><span style=display:flex><span>            CreateInvoice(billingAddress, deliveryAddress);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> address = request.Address ?? request.DeliveryAddress ?? request.BillingAddress;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ConfigureDelivery(address)
</span></span><span style=display:flex><span>            CreateInvoice(address, address);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note how both sides of the toggle check read all three possible address fields, but try to use different fields first. This means that no matter whether the sending service has it&rsquo;s toggle on or not, we will use the correct address.</p><h2 id=multiple-areas-of-the-codebase>Multiple Areas of the Codebase<a hidden class=anchor aria-hidden=true href=#multiple-areas-of-the-codebase>#</a></h2><p>To continue using the address example, we might have a UI, Controller and Handler, which all need to act differently based on the same toggle:</p><ul><li>The UI needs to display either one or two address editors</li><li>The controller needs to have different validation logic for multiple addresses</li><li>The Command Handler will need to dispatch different values</li></ul><p>We can solve this all by utilising <a href=https://www.martinfowler.com/bliki/BranchByAbstraction.html>Branch By Abstraction</a> and Dependency Injection to make most of the codebase unaware that a feature toggle exists. Even the implementations won&rsquo;t need to know about the toggles.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Startup</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureContainer(ServiceRegistry services)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (separateAddresses.Enabled) {
</span></span><span style=display:flex><span>            services.Add&lt;IAddressEditor, MultiAddressEditor&gt;();
</span></span><span style=display:flex><span>            services.Add&lt;IRequestValidator, MultiAddressValidator&gt;();
</span></span><span style=display:flex><span>            services.Add&lt;IDeliveryHandler, MultiAddressDeliveryHandler&gt;();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            services.Add&lt;IAddressEditor, SingleAddressEditor&gt;();
</span></span><span style=display:flex><span>            services.Add&lt;IRequestValidator, SingleAddressValidator&gt;();
</span></span><span style=display:flex><span>            services.Add&lt;IDeliveryHandler, SingleAddressDeliveryHandler&gt;();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s look at how one of these might work. The <code>IRequestValidator</code> has a definition like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IRequestValidator</span>&lt;TRequest&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IEnumerable&lt;<span style=color:#66d9ef>string</span>&gt; Validate(TRequest request);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There is a middleware in the API request pipeline which will pick the right validator out of the container, based on the request type being processed. We implement two validators, once for the single address, and one for multiaddress:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SingleAddressValidator</span> : IRequestValidator&lt;SingleAddressRequest&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IEnumerable&lt;<span style=color:#66d9ef>string</span>&gt; Validate(SingleAddressRequest request)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>//complex validation logic..</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (request.Address == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;No Address specified&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (PostCode.Validate(request.Address.PostCode) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Invalid Postcode&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MultiAddressValidator</span> : IRequestValidator&lt;MultiAddressRequest&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IEnumerable&lt;<span style=color:#66d9ef>string</span>&gt; Validate(MultiAddressRequest request)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> billingMessages = ValidateAddress(request.BillingAddress);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (billingMessages.Any())
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> billingMessages;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (request.DifferentDeliveryAddress)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ValidateAddress(request.DeliveryAddress);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The implementations themselves don&rsquo;t need to know about the state of the toggle, as the container and middleware take care of picking the right implementation to use.</p><h2 id=multiple-places-in-a-classmethod>Multiple Places in a Class/Method<a hidden class=anchor aria-hidden=true href=#multiple-places-in-a-classmethod>#</a></h2><p>If you have a single method (or class) which needs to check the toggle state in multiple places, you can also use the same Branch by Abstraction technique as above, by creating a custom interface and pair of implementations, which contain all the functionality which changes.</p><p>For example, if we have a method for finding an offer for a customer&rsquo;s basket, which has a few separate checks that the toggle is enabled in it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> SuggestedBasket CreateOffer(CreateOfferCommand command)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newFeature.Enabled) {
</span></span><span style=display:flex><span>        ExtraPreValidation(command).Throw();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        StandardPreValidation(command).Throw();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> offer = SelectBestOffer(command.Items);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offer == <span style=color:#66d9ef>null</span> &amp;&amp; newFeature.Enabled) {
</span></span><span style=display:flex><span>        offer = FindAlternativeOffer(command.Customer, command.Items);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> SuggestedBasket
</span></span><span style=display:flex><span>        .From(command)
</span></span><span style=display:flex><span>        .With(offer);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can extract an interface for this, and replace the toggle specific parts with calls to the interface instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ICreateOfferStrategy</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    IThrowable PreValidate(CreateOfferCommand command);
</span></span><span style=display:flex><span>    Offer AlternativeOffer(CreateOfferCommand command, Offer existingOffer);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DefaultOfferStrategy</span> : ICreateOfferStrategy
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IThrowable PreValidate(CreateOfferCommand command)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> StandardPreValidation(command);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Offer AlternativeOffer(CreateOfferCommand command, Offer existingOffer)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> existingOffer;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DefaultOfferStrategy</span> : ICreateOfferStrategy
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> IThrowable PreValidate(CreateOfferCommand command)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ExtraPreValidation(command);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Offer AlternativeOffer(CreateOfferCommand command, Offer existingOffer)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (existingOffer != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> existingOffer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> TryFindAlternativeOffer(command.Customer, command.Items, offer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>OfferBuilder</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ICreateOfferStrategy _strategy;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> OfferBuilder(ICreateOfferStrategy strategy)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _strategy = strategy;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> SuggestedBasket CreateOffer(CreateOfferCommand command)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _strategy.PreValidation(command).Throw();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> offer = SelectBestOffer(command.Items);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        offer = _strategy.AlternativeOffer(command, offer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> SuggestedBasket
</span></span><span style=display:flex><span>            .From(command)
</span></span><span style=display:flex><span>            .With(offer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now that we have done this, our <code>CreateOffer</code> method has shrunk dramatically and no longer needs to know about the toggle state, as like the rest of our DI examples, the toggle can be queried once in the startup of the service and the correct <code>ICreateOfferStrategy</code> implementation registered into the container.</p><h2 id=end>End<a hidden class=anchor aria-hidden=true href=#end>#</a></h2><p>Hopefully, this post will give a few insights into different ways of reducing the number of calls to your feature toggling library, and prevent you scattering lots of if statements around the codebase!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/feature-flags/>feature flags</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/di/>di</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2019/06/23/nomad-traefik-canary/><span class=title>« Prev Page</span><br><span>Canary Routing with Traefik in Nomad</span></a>
<a class=next href=https://andydote.co.uk/2019/06/03/feature-toggles-branch-by-abstraction/><span class=title>Next Page »</span><br><span>Feature Toggles: Branch by Abstraction</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>