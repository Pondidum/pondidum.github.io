<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Architecture Decision Records | Andy Dote</title><meta name=keywords content="architecture,process,design,adr"><meta name=description content="This is a text version of a short talk (affectionately known as a &ldquo;Coffee Bag&rdquo;) I gave at work this week, on Architecture Design Records. You can see the slides here, but there isn&rsquo;t a recording available, unfortunately.
It should be noted; these are not to replace full architecture diagrams; you should definitely still write C4 Models to cover the overall architecture. ADRs are for the details, such as serializer formats, convention-over-configuration details, number precisions for timings, or which metrics library is used and why."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2019/06/29/architecture-decision-records/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Architecture Decision Records"><meta property="og:description" content="This is a text version of a short talk (affectionately known as a &ldquo;Coffee Bag&rdquo;) I gave at work this week, on Architecture Design Records. You can see the slides here, but there isn&rsquo;t a recording available, unfortunately.
It should be noted; these are not to replace full architecture diagrams; you should definitely still write C4 Models to cover the overall architecture. ADRs are for the details, such as serializer formats, convention-over-configuration details, number precisions for timings, or which metrics library is used and why."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2019/06/29/architecture-decision-records/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-06-29T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Architecture Decision Records"><meta name=twitter:description content="This is a text version of a short talk (affectionately known as a &ldquo;Coffee Bag&rdquo;) I gave at work this week, on Architecture Design Records. You can see the slides here, but there isn&rsquo;t a recording available, unfortunately.
It should be noted; these are not to replace full architecture diagrams; you should definitely still write C4 Models to cover the overall architecture. ADRs are for the details, such as serializer formats, convention-over-configuration details, number precisions for timings, or which metrics library is used and why."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Architecture Decision Records","item":"https://andydote.co.uk/2019/06/29/architecture-decision-records/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Architecture Decision Records","name":"Architecture Decision Records","description":"This is a text version of a short talk (affectionately known as a \u0026ldquo;Coffee Bag\u0026rdquo;) I gave at work this week, on Architecture Design Records. You can see the slides here, but there isn\u0026rsquo;t a recording available, unfortunately.\nIt should be noted; these are not to replace full architecture diagrams; you should definitely still write C4 Models to cover the overall architecture. ADRs are for the details, such as serializer formats, convention-over-configuration details, number precisions for timings, or which metrics library is used and why.","keywords":["architecture","process","design","adr"],"articleBody":"This is a text version of a short talk (affectionately known as a “Coffee Bag”) I gave at work this week, on Architecture Design Records. You can see the slides here, but there isn’t a recording available, unfortunately.\nIt should be noted; these are not to replace full architecture diagrams; you should definitely still write C4 Models to cover the overall architecture. ADRs are for the details, such as serializer formats, convention-over-configuration details, number precisions for timings, or which metrics library is used and why.\nWhat? Architecture Design Records are there to solve the main question people repeatedly ask when they view a new codebase or look at an older part of their current codebase:\nWhy on earth was it done like this?!\nGenerally speaking, architectural decisions have been made in good faith at the time, but as time marches on, things change, and the reasoning gets lost. The reasoning might be discoverable through the commit history, or some comments in a type somewhere, and every once in a while, people remember the Wiki exists, and hope that someone else remembered and put some docs there. They didn’t by the way.\nArchitecture Design Records are aiming to solve all of this, with three straightforward attributes: Easy to Write, Easy to Read, and Easy to Find. Let’s look at these on their own, and then have a look at an example.\nEasy to Find As I alluded to earlier, “easy to find” doesn’t mean “hidden in confluence” (or any other wiki, for that matter.) The best place to put records of architecture decisions is in the repository. If you want them elsewhere, that’s fine, but the copy in the repository should be the source of truth.\nAs long as the location is consistent (and somewhat reasonable), it doesn’t matter too much where they go. I like to put them in the docs/arch path, but a common option is docs/adr too:\n$ tree ~/dev/projects/awesome-api |-- docs | `-- arch | |-- api-error-codes.md | |-- controller-convention.md | `-- serialization-format.md |-- src |-- test `-- readme.md The file names for each architecture decision are imperative - e.g. “serialization format”, rather than “figure out what format to use”, much like your commit messages are (right?) You might also note that the files are Markdown. Because what else would they be really?\nEasy to Write As just mentioned, I usually use Markdown for writing all documents, but as long as you are consistent (notice a pattern here?) and that it is plain-text viewable (i.e. in a terminal), it doesn’t matter too much. Try and pick a format that doesn’t add much mental overhead to writing the documents, and if it can be processed by tools easily, that’s a bonus, as we will look into later.\nEasy to Read There are two components to this: Rendering and Format.\nRendering is covering how we actually read it - plain text in a terminal, syntax highlighting in an editor, or rendered into a web page. Good ADRs can handle all three, and Markdown is a good fit for all of them! By using Markdown, not only can we render to HTML, we can even use Confluences’s questionable “Insert Markdown Markup” support to write them into a wiki location if desired.\nFormat is covering what the content of the document is. There are many different templates you can use, which have different levels of detail, and are aimed at different levels of decisions. I like to use a template based off Michael Nygard’s, which I modified a little bit to have the following sections:\nTitle Status Context Considered Options Chosen Decision Consequences Let’s have a look at these in an example.\nExample We have a new API we are developing, and we need to figure out which serialization format we should use for all the requests and responses it will handle.\nWe’ll start off with our empty document and add in the Title, and Status:\n# Serialization Format ## Status In Progress The Title is usually the same as the file name, but not necessarily. The Status indicates where the document is in its lifespan. What statuses you choose is up to you, but I usually have:\nIn Progress Accepted Rejected Superseded Deprecated Once an ADR is Accepted (or Rejected), the content won’t change again. Any subsequent changes will be a new ADR, and the previous one will be marked as either Deprecated or Superseded, along with a link to the ADR which replaces it, for example:\n## Status Superseded by [Api Transport Mechanisms](api-transport-mechanisms.md) Next, we need to add some context for the decision being made. In our serialization example, this will cover what area of the codebase we are covering (the API, rather than storage), and any key points, such as message volume, compatibilities etc.\n## Context We need to have a consistent serialization scheme for the API. It needs to be backwards and forwards compatible, as we don't control all of the clients. Messages will be fairly high volume and don't *need* to be human readable. {: .wrap }\nNow that we have some context, we need to explain what choices we have available. This will help when reading past decisions, as it will let us answer the question “was xxxx or yyyy considered?”. In our example, we consider JSON, Apache Avro, the inbuilt binary serializer, and a custom built serializer (and others, such as Thrift, ProtoBufs, etc.)\n## Considered Options 1. **Json**: Very portable, and with serializers available for all languages. We need to agree on a date format, and numeric precision, however. The serialization should not include white space to save payload size. Forwards and Backwards compatibility exists but is the developer's responsibility. 2. **Apache Avro**: Binary format which includes the schema with the data, meaning no need for schema distribution. No code generator to run, and libraries are available for most languages. 3. **Inbuilt Binary**: The API is awkward to use, and its output is not portable to other programming languages, so wouldn't be easy to consume for other teams, as well as some of our internal services. 4. **Custom Built**: A lot of overhead for little to no benefit over Avro/gRPC etc. 5. **Thrift**: ... {: .wrap }\nThe second to last section is our Chosen Decision, which will not only list which one we picked (Avro, in this case) but also why it was chosen over other options. All this helps reading older decisions, as it lets you know what was known at the time the decision was made - and you will always know less at the time of the decision than you do now.\n## Chosen Decision **2. Apache Avro** Avro was chosen because it has the best combination of message size and schema definition. No need to have a central schema repository set up is also a huge benefit. {: .wrap }\nIn this example, we have selected Avro and listed that our main reasons were message size, and the fact that Avro includes the schema with each message, meaning we don’t need a central (or distributed) schema repository to be able to read messages.\nThe final section is for Consequences of the decision. This is not to list reasons that we could have picked other decisions, but to explain things that we need to start doing or stop doing because of this decision. Let’s see what our example has:\n## Consequences As the messages are binary format, we cannot directly view them on the wire. However, a small CLI will be built to take a message and pretty print it to aid debugging. {: .wrap }\nAs we have selected a binary message format, the messages can’t be easily viewed any more, so we will build a small CLI which when given a message (which as noted, contains the schema), renders a human-readable version of the message.\nDates You might notice that the record doesn’t contain any dates so far. That is because it’s tracked in source control, which means we can pull all the relevant information from the commit history. For example, a full list of changes to any ADR could be fetched from Git with this command:\ngit log --format='%ci %s' -- docs/arch/ Likewise, when you’re running your build process, you could extract the commit history which effects a single ADR:\ngit log --reverse --format='%ci %s' -- docs/arch/serialization-format.md And then take that list and insert it into the rendered output so people can see what changed, and when:\n\u003cdiv style=\"float: right\"\u003e \u003ch2\u003eHistory\u003c/h2\u003e \u003cul\u003e \u003cli\u003e\u003cstrong\u003e2018-09-26\u003c/strong\u003e start serialization format docs\u003c/li\u003e \u003cli\u003e\u003cstrong\u003e2018-09-26\u003c/strong\u003e consider json\u003c/li\u003e \u003cli\u003e\u003cstrong\u003e2018-09-26\u003c/strong\u003e consider avro, inbuilt binary and custom binary\u003c/li\u003e \u003cli\u003e\u003cstrong\u003e2018-09-27\u003c/strong\u003e should consider thrift too\u003c/li\u003e \u003cli\u003e\u003cstrong\u003e2018-09-28\u003c/strong\u003e select Avro\u003c/li\u003e \u003cli\u003e\u003cstrong\u003e2018-09-28\u003c/strong\u003e accepted :)\u003c/li\u003e \u003cli\u003e\u003cstrong\u003e2019-03-12\u003c/strong\u003e accept api transport mechanisms\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e Note how that last log entry is the deprecation of this ADR. You can, of course, expand your log parsing only to detect Status changes etc.\nEnd Hopefully, this gives you a taste of how easily useful documentation can be written, read and found. I’m interested to hear anyone else’s thoughts on whether they find this useful, or any other alternatives.\n","wordCount":"1511","inLanguage":"en","datePublished":"2019-06-29T00:00:00Z","dateModified":"2019-06-29T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2019/06/29/architecture-decision-records/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Architecture Decision Records</h1><div class=post-meta><span title='2019-06-29 00:00:00 +0000 UTC'>June 29, 2019</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><p>This is a text version of a short talk (affectionately known as a &ldquo;Coffee Bag&rdquo;) I gave at work this week, on Architecture Design Records. You can see the <a href=/presentations/index.html?adr>slides here</a>, but there isn&rsquo;t a recording available, unfortunately.</p><p>It should be noted; these are not to replace full architecture diagrams; you should definitely still write <a href=https://c4model.com>C4 Models</a> to cover the overall architecture. ADRs are for the details, such as serializer formats, convention-over-configuration details, number precisions for timings, or which metrics library is used and why.</p><h2 id=what>What?<a hidden class=anchor aria-hidden=true href=#what>#</a></h2><p>Architecture Design Records are there to solve the main question people repeatedly ask when they view a new codebase or look at an older part of their current codebase:</p><blockquote><p>Why on earth was it done like this?!</p></blockquote><p>Generally speaking, architectural decisions have been made in good faith at the time, but as time marches on, things change, and the reasoning gets lost. The reasoning might be discoverable through the commit history, or some comments in a type somewhere, and every once in a while, people remember the Wiki exists, and hope that someone else remembered and put some docs there. They didn&rsquo;t by the way.</p><p>Architecture Design Records are aiming to solve all of this, with three straightforward attributes: Easy to Write, Easy to Read, and Easy to Find. Let&rsquo;s look at these on their own, and then have a look at an example.</p><h2 id=easy-to-find>Easy to Find<a hidden class=anchor aria-hidden=true href=#easy-to-find>#</a></h2><p>As I alluded to earlier, &ldquo;easy to find&rdquo; doesn&rsquo;t mean &ldquo;hidden in confluence&rdquo; (or any other wiki, for that matter.) The best place to put records of architecture decisions is in the repository. If you want them elsewhere, that&rsquo;s fine, but the copy in the repository should be the source of truth.</p><p>As long as the location is consistent (and somewhat reasonable), it doesn&rsquo;t matter too much where they go. I like to put them in the <code>docs/arch</code> path, but a common option is <code>docs/adr</code> too:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ tree ~/dev/projects/awesome-api
</span></span><span style=display:flex><span>|-- docs
</span></span><span style=display:flex><span>|   <span style=color:#e6db74>`</span>-- arch
</span></span><span style=display:flex><span>|       |-- api-error-codes.md
</span></span><span style=display:flex><span>|       |-- controller-convention.md
</span></span><span style=display:flex><span>|       <span style=color:#e6db74>`</span>-- serialization-format.md
</span></span><span style=display:flex><span>|-- src
</span></span><span style=display:flex><span>|-- test
</span></span><span style=display:flex><span><span style=color:#e6db74>`</span>-- readme.md
</span></span></code></pre></div><p>The file names for each architecture decision are imperative - e.g. &ldquo;serialization format&rdquo;, rather than &ldquo;figure out what format to use&rdquo;, much like your commit messages are (right?) You might also note that the files are Markdown. Because what else would they be really?</p><h2 id=easy-to-write>Easy to Write<a hidden class=anchor aria-hidden=true href=#easy-to-write>#</a></h2><p>As just mentioned, I usually use Markdown for writing all documents, but as long as you are consistent (notice a pattern here?) and that it is plain-text viewable (i.e. in a terminal), it doesn&rsquo;t matter too much. Try and pick a format that doesn&rsquo;t add much mental overhead to writing the documents, and if it can be processed by tools easily, that&rsquo;s a bonus, as we will look into later.</p><h2 id=easy-to-read>Easy to Read<a hidden class=anchor aria-hidden=true href=#easy-to-read>#</a></h2><p>There are two components to this: Rendering and Format.</p><p>Rendering is covering how we actually read it - plain text in a terminal, syntax highlighting in an editor, or rendered into a web page. Good ADRs can handle all three, and Markdown is a good fit for all of them! By using Markdown, not only can we render to HTML, we can even use Confluences&rsquo;s questionable &ldquo;Insert Markdown Markup&rdquo; support to write them into a wiki location if desired.</p><p>Format is covering what the content of the document is. There are <a href=https://github.com/joelparkerhenderson/architecture_decision_record>many different templates you can use</a>, which have different levels of detail, and are aimed at different levels of decisions. I like to use a template based off <a href=https://github.com/joelparkerhenderson/architecture_decision_record/blob/master/adr_template_by_michael_nygard.md>Michael Nygard&rsquo;s</a>, which I modified a little bit to have the following sections:</p><ul><li>Title</li><li>Status</li><li>Context</li><li>Considered Options</li><li>Chosen Decision</li><li>Consequences</li></ul><p>Let&rsquo;s have a look at these in an example.</p><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>We have a new API we are developing, and we need to figure out which serialization format we should use for all the requests and responses it will handle.</p><p>We&rsquo;ll start off with our empty document and add in the Title, and Status:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span># Serialization Format
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>## Status
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>In Progress
</span></span></code></pre></div><p>The Title is <em>usually</em> the same as the file name, but not necessarily. The Status indicates where the document is in its lifespan. What statuses you choose is up to you, but I usually have:</p><ul><li>In Progress</li><li>Accepted</li><li>Rejected</li><li>Superseded</li><li>Deprecated</li></ul><p>Once an ADR is Accepted (or Rejected), the content won&rsquo;t change again. Any subsequent changes will be a new ADR, and the previous one will be marked as either Deprecated or Superseded, along with a link to the ADR which replaces it, for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span><span style=color:#75715e>## Status
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>Superseded by [<span style=color:#f92672>Api Transport Mechanisms</span>](<span style=color:#a6e22e>api-transport-mechanisms.md</span>)
</span></span></code></pre></div><p>Next, we need to add some context for the decision being made. In our serialization example, this will cover what area of the codebase we are covering (the API, rather than storage), and any key points, such as message volume, compatibilities etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span><span style=color:#75715e>## Context
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>We need to have a consistent serialization scheme for the API.  It needs to be backwards and forwards compatible, as we don&#39;t control all of the clients.  Messages will be fairly high volume and don&#39;t <span style=font-style:italic>*need*</span> to be human readable.
</span></span></code></pre></div><p>{: .wrap }</p><p>Now that we have some context, we need to explain what choices we have available. This will help when reading past decisions, as it will let us answer the question &ldquo;was xxxx or yyyy considered?&rdquo;. In our example, we consider JSON, Apache Avro, the inbuilt binary serializer, and a custom built serializer (and others, such as Thrift, ProtoBufs, etc.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span><span style=color:#75715e>## Considered Options
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>1.</span> <span style=font-weight:700>**Json**</span>: Very portable, and with serializers available for all languages.  We need to agree on a date format, and numeric precision, however.  The serialization should not include white space to save payload size.  Forwards and Backwards compatibility exists but is the developer&#39;s responsibility.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>2.</span> <span style=font-weight:700>**Apache Avro**</span>: Binary format which includes the schema with the data, meaning no need for schema distribution.  No code generator to run, and libraries are available for most languages.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>3.</span> <span style=font-weight:700>**Inbuilt Binary**</span>: The API is awkward to use, and its output is not portable to other programming languages, so wouldn&#39;t be easy to consume for other teams, as well as some of our internal services.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>4.</span> <span style=font-weight:700>**Custom Built**</span>: A lot of overhead for little to no benefit over Avro/gRPC etc.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>5.</span> <span style=font-weight:700>**Thrift**</span>: ...
</span></span></code></pre></div><p>{: .wrap }</p><p>The second to last section is our Chosen Decision, which will not only list which one we picked (Avro, in this case) but also why it was chosen over other options. All this helps reading older decisions, as it lets you know what was known at the time the decision was made - and you will always know less at the time of the decision than you do now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span><span style=color:#75715e>## Chosen Decision
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=font-weight:700>**2. Apache Avro**</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Avro was chosen because it has the best combination of message size and schema definition.  No need to have a central schema repository set up is also a huge benefit.
</span></span></code></pre></div><p>{: .wrap }</p><p>In this example, we have selected Avro and listed that our main reasons were message size, and the fact that Avro includes the schema with each message, meaning we don&rsquo;t need a central (or distributed) schema repository to be able to read messages.</p><p>The final section is for Consequences of the decision. This is <strong>not</strong> to list reasons that we could have picked other decisions, but to explain things that we need to start doing or stop doing because of this decision. Let&rsquo;s see what our example has:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span><span style=color:#75715e>## Consequences
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>As the messages are binary format, we cannot directly view them on the wire.  However, a small CLI will be built to take a message and pretty print it to aid debugging.
</span></span></code></pre></div><p>{: .wrap }</p><p>As we have selected a binary message format, the messages can&rsquo;t be easily viewed any more, so we will build a small CLI which when given a message (which as noted, contains the schema), renders a human-readable version of the message.</p><h2 id=dates>Dates<a hidden class=anchor aria-hidden=true href=#dates>#</a></h2><p>You might notice that the record doesn&rsquo;t contain any dates so far. That is because it&rsquo;s tracked in source control, which means we can pull all the relevant information from the commit history. For example, a full list of changes to any ADR could be fetched from Git with this command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git log --format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;%ci %s&#39;</span> -- docs/arch/
</span></span></code></pre></div><p>Likewise, when you&rsquo;re running your build process, you could extract the commit history which effects a single ADR:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git log --reverse --format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;%ci %s&#39;</span> -- docs/arch/serialization-format.md
</span></span></code></pre></div><p>And then take that list and insert it into the rendered output so people can see what changed, and when:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>div</span> <span style=color:#a6e22e>style</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;float: right&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#f92672>h2</span>&gt;History&lt;/<span style=color:#f92672>h2</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2018-09-26&lt;/<span style=color:#f92672>strong</span>&gt; start serialization format docs&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2018-09-26&lt;/<span style=color:#f92672>strong</span>&gt; consider json&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2018-09-26&lt;/<span style=color:#f92672>strong</span>&gt; consider avro, inbuilt binary and custom binary&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2018-09-27&lt;/<span style=color:#f92672>strong</span>&gt; should consider thrift too&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2018-09-28&lt;/<span style=color:#f92672>strong</span>&gt; select Avro&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2018-09-28&lt;/<span style=color:#f92672>strong</span>&gt; accepted :)&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>        &lt;<span style=color:#f92672>li</span>&gt;&lt;<span style=color:#f92672>strong</span>&gt;2019-03-12&lt;/<span style=color:#f92672>strong</span>&gt; accept api transport mechanisms&lt;/<span style=color:#f92672>li</span>&gt;
</span></span><span style=display:flex><span>    &lt;/<span style=color:#f92672>ul</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>div</span>&gt;
</span></span></code></pre></div><p>Note how that last log entry is the deprecation of this ADR. You can, of course, expand your log parsing only to detect Status changes etc.</p><h2 id=end>End<a hidden class=anchor aria-hidden=true href=#end>#</a></h2><p>Hopefully, this gives you a taste of how easily useful documentation can be written, read and found. I&rsquo;m interested to hear anyone else&rsquo;s thoughts on whether they find this useful, or any other alternatives.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/architecture/>architecture</a></li><li><a href=https://andydote.co.uk/tags/process/>process</a></li><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/adr/>adr</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2019/08/25/vault-development-ca/><span class=title>« Prev Page</span><br><span>Using Vault as a Development CA</span></a>
<a class=next href=https://andydote.co.uk/2019/06/23/nomad-traefik-canary/><span class=title>Next Page »</span><br><span>Canary Routing with Traefik in Nomad</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>