<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Feature Toggles: Branch by Abstraction | Andy Dote</title><meta name=keywords content="feature flags,c#,di,microservices"><meta name=description content="Recently, I was asked if I could provide an example of Branch By Abstraction when dealing with feature toggles. As this has come up a few times, I thought a blog post would be a good idea so I can refer others to it later too.
The Context As usual, this is some kind of backend (micro)service, and it will send email messages somehow. We will start with two implementations of message sending: the &ldquo;current&rdquo; version; which is synchronous, and a &ldquo;new&rdquo; version; which is async."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2019/06/03/feature-toggles-branch-by-abstraction/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2b33c247bf6959372dd097f2cfdcd9f4d5019027cd9b1e28ae3d14c17c37ac00.css integrity="sha256-KzPCR79pWTct0Jfyz9zZ9NUBkCfNmx4orj0UwXw3rAA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Feature Toggles: Branch by Abstraction"><meta property="og:description" content="Recently, I was asked if I could provide an example of Branch By Abstraction when dealing with feature toggles. As this has come up a few times, I thought a blog post would be a good idea so I can refer others to it later too.
The Context As usual, this is some kind of backend (micro)service, and it will send email messages somehow. We will start with two implementations of message sending: the &ldquo;current&rdquo; version; which is synchronous, and a &ldquo;new&rdquo; version; which is async."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2019/06/03/feature-toggles-branch-by-abstraction/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-06-03T00:00:00+00:00"><meta property="article:modified_time" content="2019-06-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Feature Toggles: Branch by Abstraction"><meta name=twitter:description content="Recently, I was asked if I could provide an example of Branch By Abstraction when dealing with feature toggles. As this has come up a few times, I thought a blog post would be a good idea so I can refer others to it later too.
The Context As usual, this is some kind of backend (micro)service, and it will send email messages somehow. We will start with two implementations of message sending: the &ldquo;current&rdquo; version; which is synchronous, and a &ldquo;new&rdquo; version; which is async."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Feature Toggles: Branch by Abstraction","item":"https://andydote.co.uk/2019/06/03/feature-toggles-branch-by-abstraction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Feature Toggles: Branch by Abstraction","name":"Feature Toggles: Branch by Abstraction","description":"Recently, I was asked if I could provide an example of Branch By Abstraction when dealing with feature toggles. As this has come up a few times, I thought a blog post would be a good idea so I can refer others to it later too.\nThe Context As usual, this is some kind of backend (micro)service, and it will send email messages somehow. We will start with two implementations of message sending: the \u0026ldquo;current\u0026rdquo; version; which is synchronous, and a \u0026ldquo;new\u0026rdquo; version; which is async.","keywords":["feature flags","c#","di","microservices"],"articleBody":"Recently, I was asked if I could provide an example of Branch By Abstraction when dealing with feature toggles. As this has come up a few times, I thought a blog post would be a good idea so I can refer others to it later too.\nThe Context As usual, this is some kind of backend (micro)service, and it will send email messages somehow. We will start with two implementations of message sending: the “current” version; which is synchronous, and a “new” version; which is async.\nWe’ll do a bit of setup to show how feature toggling can be done in three ways for this feature:\nStatic: Configured on startup Dynamic: Check the toggle state on each send Dynamic: Check the toggle for a given message Abstractions and Implementations We have an interface called IMessageDispatcher which defines a single Send method, which returns a Task (or Promise, Future, etc. depending on your language.)\npublic interface IMessageDispatcher { Task Send(Message message); } The two message sending implementations don’t matter, but we need the types to show the other code examples. Fill in the blanks if you want!\npublic class HttpMessageDispatcher : IMessageDispatcher { // ... } public class QueueMessageDispatcher : IMessageDispatcher { // ... } 1. Static Configuration The word static in this context means that we check the feature toggle’s state once on startup and pick an implementation. We don’t recheck the toggle state unless the service is restarted.\nFor instance, in an ASP.Net core application, you could change which service is registered into the container at startup like so:\npublic void ConfigureServices(IServiceCollection services) { var toggleSource = new ToggleSource(/* ... */); if (toggleSource.IsActive(Toggles.AsyncMessageDispatch)) services.AddTransient(); else services.AddTransient(); } Which means any class which takes in an instance of IMessageDispatcher doesn’t need to check the toggle state or worry about which implementation to use.\n2. Dynamic Configuration We can build on this abstraction to enable more flexibility, if we want to be able to change the toggle state while the service is running, without needing to restart it. To do this, we can implement another version of the IMessageDispatcher interface which will check the toggle state on each invocation of Send():\npublic class ToggleDispatcher : IMessageDispatcher { private readonly Func\u003cbool\u003e _isToggleActive; private readonly IMessageDispatcher _queueSender; private readonly IMessageDispatcher _httpSender; public ToggleDispatcher(Func\u003cbool\u003e isToggleActive, IMessageDispatcher queueSender, IMessageDispatcher httpSender) { _isToggleActive = isToggleActive; _queueSender = queueSender; _httpSender = httpSender; } public Task Send(Message message) { var chosen = _isToggleActive() ? _queueSender : _httpSender; return chosen.Send(message); } } And in our startup class, we can change the service registration to use the new version. Note how we are now registering the two concrete versions into the container so that they can be resolved later by the ToggleDispatcher registration:\npublic void ConfigureServices(IServiceCollection services) { var toggleSource = new ToggleSource(/* ... */); services.AddTransient(); services.AddTransient(); services.AddTransient(context =\u003e new ToggleDispatcher( () =\u003e toggleSource.IsActive(Toggles.AsyncMessageDispatch), context.GetService(), context.GetService()) ); } 3. Dynamic(er) Configuration We can take this another step further too, if we want to be able to have a phased rollout of this new QueueMessageDispatcher, for example, based on the sender address. In this case, we can create another decorator which uses the individual message to make the decision. The only difference to the original ToggleDispatcher is that the first argument now also provides a Message object:\npublic class MessageBasedToggleDispatcher : IMessageDispatcher { private readonly Func","wordCount":"767","inLanguage":"en","datePublished":"2019-06-03T00:00:00Z","dateModified":"2019-06-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2019/06/03/feature-toggles-branch-by-abstraction/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Feature Toggles: Branch by Abstraction</h1><div class=post-meta><span title='2019-06-03 00:00:00 +0000 UTC'>June 3, 2019</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>Recently, I was asked if I could provide an example of Branch By Abstraction when dealing with feature toggles. As this has come up a few times, I thought a blog post would be a good idea so I can refer others to it later too.</p><h2 id=the-context>The Context<a hidden class=anchor aria-hidden=true href=#the-context>#</a></h2><p>As usual, this is some kind of backend (micro)service, and it will send email messages somehow. We will start with two implementations of message sending: the &ldquo;current&rdquo; version; which is synchronous, and a &ldquo;new&rdquo; version; which is async.</p><p>We&rsquo;ll do a bit of setup to show how feature toggling can be done in three ways for this feature:</p><ol><li>Static: Configured on startup</li><li>Dynamic: Check the toggle state on each send</li><li>Dynamic: Check the toggle for a given message</li></ol><h2 id=abstractions-and-implementations>Abstractions and Implementations<a hidden class=anchor aria-hidden=true href=#abstractions-and-implementations>#</a></h2><p>We have an interface called <code>IMessageDispatcher</code> which defines a single <code>Send</code> method, which returns a <code>Task</code> (or <code>Promise</code>, <code>Future</code>, etc. depending on your language.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IMessageDispatcher</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Task&lt;SendResult&gt; Send(Message message);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The two message sending implementations don&rsquo;t matter, but we need the types to show the other code examples. Fill in the blanks if you want!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>HttpMessageDispatcher</span> : IMessageDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>QueueMessageDispatcher</span> : IMessageDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=1-static-configuration>1. Static Configuration<a hidden class=anchor aria-hidden=true href=#1-static-configuration>#</a></h2><p>The word static in this context means that we check the feature toggle&rsquo;s state once on startup and pick an implementation. We don&rsquo;t recheck the toggle state unless the service is restarted.</p><p>For instance, in an ASP.Net core application, you could change which service is registered into the container at startup like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureServices(IServiceCollection services)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> toggleSource = <span style=color:#66d9ef>new</span> ToggleSource(<span style=color:#75715e>/* ... */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (toggleSource.IsActive(Toggles.AsyncMessageDispatch))
</span></span><span style=display:flex><span>        services.AddTransient&lt;IMessageDispatcher, QueueMessageDispatcher&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        services.AddTransient&lt;IMessageDispatcher, HttpMessageDispatcher&gt;();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which means any class which takes in an instance of <code>IMessageDispatcher</code> doesn&rsquo;t need to check the toggle state or worry about which implementation to use.</p><h2 id=2-dynamic-configuration>2. Dynamic Configuration<a hidden class=anchor aria-hidden=true href=#2-dynamic-configuration>#</a></h2><p>We can build on this abstraction to enable more flexibility, if we want to be able to change the toggle state while the service is running, without needing to restart it. To do this, we can implement another version of the <code>IMessageDispatcher</code> interface which will check the toggle state on each invocation of <code>Send()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleDispatcher</span> : IMessageDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Func&lt;<span style=color:#66d9ef>bool</span>&gt; _isToggleActive;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IMessageDispatcher _queueSender;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IMessageDispatcher _httpSender;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ToggleDispatcher(Func&lt;<span style=color:#66d9ef>bool</span>&gt; isToggleActive, IMessageDispatcher queueSender, IMessageDispatcher httpSender)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _isToggleActive = isToggleActive;
</span></span><span style=display:flex><span>        _queueSender = queueSender;
</span></span><span style=display:flex><span>        _httpSender = httpSender;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Task&lt;SendResult&gt; Send(Message message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> chosen = _isToggleActive()
</span></span><span style=display:flex><span>            ? _queueSender
</span></span><span style=display:flex><span>            : _httpSender;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> chosen.Send(message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And in our startup class, we can change the service registration to use the new version. Note how we are now registering the two concrete versions into the container so that they can be resolved later by the ToggleDispatcher registration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureServices(IServiceCollection services)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> toggleSource = <span style=color:#66d9ef>new</span> ToggleSource(<span style=color:#75715e>/* ... */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    services.AddTransient&lt;HttpMessageDispatcher&gt;();
</span></span><span style=display:flex><span>    services.AddTransient&lt;QueueMessageDispatcher&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    services.AddTransient&lt;IMessageDispatcher&gt;(context =&gt; <span style=color:#66d9ef>new</span> ToggleDispatcher(
</span></span><span style=display:flex><span>        () =&gt; toggleSource.IsActive(Toggles.AsyncMessageDispatch),
</span></span><span style=display:flex><span>        context.GetService&lt;QueueMessageDispatcher&gt;(),
</span></span><span style=display:flex><span>        context.GetService&lt;HttpMessageDispatcher&gt;())
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=3-dynamicer-configuration>3. Dynamic(er) Configuration<a hidden class=anchor aria-hidden=true href=#3-dynamicer-configuration>#</a></h2><p>We can take this another step further too, if we want to be able to have a phased rollout of this new <code>QueueMessageDispatcher</code>, for example, based on the sender address. In this case, we can create another decorator which uses the individual message to make the decision. The only difference to the original <code>ToggleDispatcher</code> is that the first argument now also provides a <code>Message</code> object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageBasedToggleDispatcher</span> : IMessageDispatcher
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Func&lt;Message, <span style=color:#66d9ef>bool</span>&gt; _isToggleActive;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IMessageDispatcher _queueSender;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IMessageDispatcher _httpSender;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> MessageBasedToggleDispatcher(Func&lt;Message, <span style=color:#66d9ef>bool</span>&gt; isToggleActive, IMessageDispatcher queueSender, IMessageDispatcher httpSender)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _isToggleActive = isToggleActive;
</span></span><span style=display:flex><span>        _queueSender = queueSender;
</span></span><span style=display:flex><span>        _httpSender = httpSender;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Task&lt;SendResult&gt; Send(Message message)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> chosen = _isToggleActive(message)
</span></span><span style=display:flex><span>            ? _queueSender
</span></span><span style=display:flex><span>            : _httpSender;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> chosen.Send(message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The startup registration is modified to pass the message property we care about to the <code>ToggleSource</code>, with the <code>toggleSource.IsActive()</code> call being responsible for what to do with the key we have passed in. Perhaps it does something like a consistent hash of the address, and if the value is above a certain threshold the toggle is active, or maybe it queries a whitelist of people who the toggle is enabled for.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> ConfigureServices(IServiceCollection services)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> toggleSource = <span style=color:#66d9ef>new</span> ToggleSource(<span style=color:#75715e>/* ... */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    services.AddTransient&lt;HttpMessageDispatcher&gt;();
</span></span><span style=display:flex><span>    services.AddTransient&lt;QueueMessageDispatcher&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    services.AddTransient&lt;IMessageDispatcher&gt;(context =&gt; <span style=color:#66d9ef>new</span> MessageBasedToggleDispatcher(
</span></span><span style=display:flex><span>        message =&gt; toggleSource.IsActive(Toggles.AsyncMessageDispatch, message.SenderAddress),
</span></span><span style=display:flex><span>        context.GetService&lt;QueueMessageDispatcher&gt;(),
</span></span><span style=display:flex><span>        context.GetService&lt;HttpMessageDispatcher&gt;())
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>This method of branching is extremly flexible, as it allows us to use toggles to replace feature implementations, but also gives us lots of places where we can add other decorators to add functionality to the pipeline. For example, we could add an auditing decorator or one which implements the outbox pattern - and the calling code which depends only on <code>IMessageDispatcher</code> doesn&rsquo;t need to care.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/feature-flags/>feature flags</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/di/>di</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2019/06/11/feature-toggles-reducing-coupling/><span class=title>« Prev Page</span><br><span>Feature Toggles: Reducing Coupling</span></a>
<a class=next href=https://andydote.co.uk/2019/05/31/consul-dns-forwarding-alpine/><span class=title>Next Page »</span><br><span>Configuring Consul DNS Forwarding in Alpine Linux</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>