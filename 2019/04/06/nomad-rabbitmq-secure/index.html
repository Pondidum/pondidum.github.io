<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Running a Secure RabbitMQ Cluster in Nomad | Andy Dote</title>
<meta name=keywords content="infrastructure,vagrant,nomad,consul,rabbitmq,vault"><meta name=description content="Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.
The things I want to cover are:
Username and Password for the management UI Secure value for the Erlang Cookie SSL for Management and AMQP As usual, the demo repository with all the code is available if you&rsquo;d rather just jump into that."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2019/04/06/nomad-rabbitmq-secure/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Running a Secure RabbitMQ Cluster in Nomad"><meta property="og:description" content="Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.
The things I want to cover are:
Username and Password for the management UI Secure value for the Erlang Cookie SSL for Management and AMQP As usual, the demo repository with all the code is available if you&rsquo;d rather just jump into that."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2019/04/06/nomad-rabbitmq-secure/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-04-06T00:00:00+00:00"><meta property="article:modified_time" content="2019-04-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Running a Secure RabbitMQ Cluster in Nomad"><meta name=twitter:description content="Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.
The things I want to cover are:
Username and Password for the management UI Secure value for the Erlang Cookie SSL for Management and AMQP As usual, the demo repository with all the code is available if you&rsquo;d rather just jump into that."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Running a Secure RabbitMQ Cluster in Nomad","item":"https://andydote.co.uk/2019/04/06/nomad-rabbitmq-secure/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Running a Secure RabbitMQ Cluster in Nomad","name":"Running a Secure RabbitMQ Cluster in Nomad","description":"Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.\nThe things I want to cover are:\nUsername and Password for the management UI Secure value for the Erlang Cookie SSL for Management and AMQP As usual, the demo repository with all the code is available if you\u0026rsquo;d rather just jump into that.","keywords":["infrastructure","vagrant","nomad","consul","rabbitmq","vault"],"articleBody":"Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.\nThe things I want to cover are:\nUsername and Password for the management UI Secure value for the Erlang Cookie SSL for Management and AMQP As usual, the demo repository with all the code is available if you’d rather just jump into that.\nConfigure Nomad To Integrate With Vault To manage the certificates and credentials I will use another Hashicorp tool called Vault, which provides Secrets As A Service. It can be configured for High Availability, but for the demo, we will just use a single instance on one of our Nomad machines.\nVault We’ll update the Vagrant script used in the last post about Nomad Rabbitmq Clustering to add in a single Vault node. This is not suitable for using Vault in production; for that there should be a separate Vault cluster running somewhere, but as this post is focusing on how to integrate with Vault, a single node will suffice.\nOnce we have Vault installed (see the provision.sh script), we need to set up a few parts. First is a PKI (public key infrastructure), better known as a Certificate Authority (CA). We will generate a single root certificate and have our client machines (and optionally the host machine) trust that one certificate.\nAs this the machines are running in Hyper-V with the Default Switch, we can use the inbuilt domain name, mshome.net, and provide our own certificates. This script is run as part of the Server (nomad1) provisioning script, but in a production environment would be outside of this scope.\ndomain=\"mshome.net\" vault secrets enable pki vault secrets tune -max-lease-ttl=87600h pki vault write -field=certificate pki/root/generate/internal common_name=\"$domain\" ttl=87600h \\ \u003e /vagrant/vault/mshome.crt vault write pki/config/urls \\ issuing_certificates=\"$VAULT_ADDR/v1/pki/ca\" \\ crl_distribution_points=\"$VAULT_ADDR/v1/pki/crl\" vault write pki/roles/rabbit \\ allowed_domains=\"$domain\" \\ allow_subdomains=true \\ generate_lease=true \\ max_ttl=\"720h\" sudo cp /vagrant/vault/mshome.crt /usr/local/share/ca-certificates/mshome.crt sudo update-ca-certificates If you don’t want scary screens in FireFox and Chrome, you’ll need to install the mshome.crt certificate into your trust store.\nNext up, we have some policies we need in Vault. The first deals with what the Nomad Server(s) are allowed to do - namely to handle tokens for itself, and anything in the nomad-cluster role. A full commented version of this policy is available here.\npath \"auth/token/create/nomad-cluster\" { capabilities = [\"update\"] } path \"auth/token/roles/nomad-cluster\" { capabilities = [\"read\"] } path \"auth/token/lookup-self\" { capabilities = [\"read\"] } path \"auth/token/lookup\" { capabilities = [\"update\"] } path \"auth/token/revoke-accessor\" { capabilities = [\"update\"] } path \"sys/capabilities-self\" { capabilities = [\"update\"] } path \"auth/token/renew-self\" { capabilities = [\"update\"] } As this policy mentions the nomad-cluster role a few times, let’s have a look at that also:\n{ \"disallowed_policies\": \"nomad-server\", \"explicit_max_ttl\": 0, \"name\": \"nomad-cluster\", \"orphan\": true, \"period\": 259200, \"renewable\": true } This allows a fairly long-lived token to be created, which can be renewed. It is also limiting what the tokens are allowed to do, which can be done as either a block list (disallowed_policies) or an allow list (allowed_policies). In this case, I am letting the Clients access any policies except the nomad-server policy.\nWe can install both of these into Vault:\nvault policy write nomad-server /vagrant/vault/nomad-server-policy.hcl vault write auth/token/roles/nomad-cluster @/vagrant/vault/nomad-cluster-role.json Nomad Now that Vault is up and running, we should configure Nomad to talk to it. This is done in two places - the Server configuration, and the Client configuration.\nTo configure the Nomad Server, we update it’s configuration file to include a vault block, which contains a role name it will use to generate tokens (for itself and for the Nomad Clients), and an initial token.\nvault { enabled = true address = \"http://localhost:8200\" task_token_ttl = \"1h\" create_from_role = \"nomad-cluster\" token = \"some_token_here\" } The initial token is generated by the ./server.sh script - how you go about doing this in production will vary greatly depending on how you are managing your machines.\nThe Nomad Clients also need the Vault integration enabling, but in their case, it only needs the location of Vault, as the Server node(s) will provide tokens for the clients to use.\nvault { enabled = true address = \"http://nomad1.mshome.net:8200\" } Job Requirements Before we go about changing the job itself, we need to write some data into Vault for the job to use:\nCredentials: Username and password for the RabbitMQ Management UI, and the RABBITMQ_ERLANG_COOKIE A policy for the job allowing Certificate Generation and Credentials access Credentials First off, we need to create a username and password to use with the Management UI. This can be done via the Vault CLI:\nvault kv put secret/rabbit/admin \\ username=administrator \\ password=$(cat /proc/sys/kernel/random/uuid) For the Erlang Cookie, we will also generate a Guid, but this time we will store it under a separate path in Vault so that it can be locked down separately to the admin username and password if needed:\nvault kv put secret/rabbit/cookie \\ cookie=$(cat /proc/sys/kernel/random/uuid) Job Policy Following the principle of Least Privilege, we will create a policy for our rabbit job which only allows certificates to be generated, and rabbit credentials to be read.\npath \"pki/issue/rabbit\" { capabilities = [ \"create\", \"read\", \"update\", \"delete\", \"list\" ] } path \"secret/data/rabbit/*\" { capabilities = [ \"read\" ] } This is written into Vault in the same way as the other policies were:\nvault policy write rabbit /vagrant/vault/rabbit-policy.hcl Rabbit Job Configuration The first thing we need to do to the job is specify what policies we want to use with Vault, and what to do when a token or credential expires:\ntask \"rabbit\" { driver = \"docker\" vault { policies = [\"default\", \"rabbit\"] change_mode = \"restart\" } #... } Certificates To configure RabbitMQ to use SSL, we need to provide it with values for 3 environment variables:\nRABBITMQ_SSL_CACERTFILE - The CA certificate RABBITMQ_SSL_CERTFILE - The Certificate for RabbitMQ to use RABBITMQ_SSL_KEYFILE - the PrivateKey for the RabbitMQ certificate So let’s add a template block to the job to generate and write out a certificate. It’s worth noting that line endings matter. You either need your .nomad file to use LF line endings, or make the template a single line and use \\n to add the correct line endings in. I prefer to have the file with LF line endings.\ntemplate { data = \u003c","wordCount":"1749","inLanguage":"en","datePublished":"2019-04-06T00:00:00Z","dateModified":"2019-04-06T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2019/04/06/nomad-rabbitmq-secure/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Running a Secure RabbitMQ Cluster in Nomad</h1><div class=post-meta>&lt;span title='2019-04-06 00:00:00 +0000 UTC'>April 6, 2019&lt;/span>&amp;nbsp;·&amp;nbsp;9 min</div></header><div class=post-content><p>Last time I wrote about running a RabbitMQ cluster in Nomad, one of the main pieces of feedback I received was about the (lack) of security of the setup, so I decided to revisit this, and write about how to launch as secure RabbitMQ node in Nomad.</p><p>The things I want to cover are:</p><ul><li>Username and Password for the management UI</li><li>Secure value for the Erlang Cookie</li><li>SSL for Management and AMQP</li></ul><p>As usual, the <a href=https://github.com/Pondidum/Nomad-RabbitMQ-Demo>demo repository</a> with all the code is available if you&rsquo;d rather just jump into that.</p><h2 id=configure-nomad-to-integrate-with-vault>Configure Nomad To Integrate With Vault<a hidden class=anchor aria-hidden=true href=#configure-nomad-to-integrate-with-vault>#</a></h2><p>To manage the certificates and credentials I will use another Hashicorp tool called <a href=https://vaultproject.io/>Vault</a>, which provides Secrets As A Service. It can be configured for High Availability, but for the demo, we will just use a single instance on one of our Nomad machines.</p><h3 id=vault>Vault<a hidden class=anchor aria-hidden=true href=#vault>#</a></h3><p>We&rsquo;ll update the Vagrant script used in the <a href=/2019/01/28/nomad-rabbitmq-consul-cluster/>last post about Nomad Rabbitmq Clustering</a> to add in a single Vault node. <strong>This is not suitable for using Vault in production;</strong> for that there should be a separate Vault cluster running somewhere, but as this post is focusing on how to integrate with Vault, a single node will suffice.</p><p>Once we have Vault installed (<a href=https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/provision.sh#L50>see the <code>provision.sh</code> script</a>), we need to set up a few parts. First is a PKI (public key infrastructure), better known as a Certificate Authority (CA). We will generate a single root certificate and have our client machines (and optionally the host machine) trust that one certificate.</p><p>As this the machines are running in Hyper-V with the Default Switch, we can use the inbuilt domain name, <code>mshome.net</code>, and provide our own certificates. This script is run as part of the Server (<code>nomad1</code>) provisioning script, but in a production environment would be outside of this scope.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>domain<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mshome.net&#34;</span>
</span></span><span style=display:flex><span>vault secrets enable pki
</span></span><span style=display:flex><span>vault secrets tune -max-lease-ttl<span style=color:#f92672>=</span>87600h pki
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write -field<span style=color:#f92672>=</span>certificate pki/root/generate/internal common_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$domain<span style=color:#e6db74>&#34;</span> ttl<span style=color:#f92672>=</span>87600h <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    &gt; /vagrant/vault/mshome.crt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write pki/config/urls <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    issuing_certificates<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$VAULT_ADDR<span style=color:#e6db74>/v1/pki/ca&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    crl_distribution_points<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$VAULT_ADDR<span style=color:#e6db74>/v1/pki/crl&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write pki/roles/rabbit <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    allowed_domains<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$domain<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    allow_subdomains<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    generate_lease<span style=color:#f92672>=</span>true <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    max_ttl<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;720h&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo cp /vagrant/vault/mshome.crt /usr/local/share/ca-certificates/mshome.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><p>If you don&rsquo;t want scary screens in FireFox and Chrome, you&rsquo;ll need to install the <code>mshome.crt</code> certificate into your trust store.</p><p>Next up, we have some policies we need in Vault. The first deals with what the Nomad Server(s) are allowed to do - namely to handle tokens for itself, and anything in the <code>nomad-cluster</code> role. <a href=https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/vault/nomad-server-policy.hcl>A full commented version of this policy is available here</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>path <span style=color:#e6db74>&#34;auth/token/create/nomad-cluster&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;update&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;auth/token/roles/nomad-cluster&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;read&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;auth/token/lookup-self&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;read&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;auth/token/lookup&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;update&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;auth/token/revoke-accessor&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;update&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;sys/capabilities-self&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;update&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;auth/token/renew-self&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;update&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As this policy mentions the <code>nomad-cluster</code> role a few times, let&rsquo;s have a look at that also:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;disallowed_policies&#34;</span>: <span style=color:#e6db74>&#34;nomad-server&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;explicit_max_ttl&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;nomad-cluster&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;orphan&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;period&#34;</span>: <span style=color:#ae81ff>259200</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;renewable&#34;</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This allows a fairly long-lived token to be created, which can be renewed. It is also limiting what the tokens are allowed to do, which can be done as either a block list (<code>disallowed_policies</code>) or an allow list (<code>allowed_policies</code>). In this case, I am letting the Clients access any policies except the <code>nomad-server</code> policy.</p><p>We can install both of these into Vault:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault policy write nomad-server /vagrant/vault/nomad-server-policy.hcl
</span></span><span style=display:flex><span>vault write auth/token/roles/nomad-cluster @/vagrant/vault/nomad-cluster-role.json
</span></span></code></pre></div><h3 id=nomad>Nomad<a hidden class=anchor aria-hidden=true href=#nomad>#</a></h3><p>Now that Vault is up and running, we should configure Nomad to talk to it. This is done in two places - the Server configuration, and the Client configuration.</p><p>To configure the <strong>Nomad Server</strong>, we update it&rsquo;s configuration file to include a <code>vault</code> block, which contains a role name it will use to generate tokens (for itself and for the Nomad Clients), and an initial token.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>vault {
</span></span><span style=display:flex><span>    enabled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    address <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>
</span></span><span style=display:flex><span>    task_token_ttl <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1h&#34;</span>
</span></span><span style=display:flex><span>    create_from_role <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nomad-cluster&#34;</span>
</span></span><span style=display:flex><span>    token <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;some_token_here&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The initial token is generated by the <a href=https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/master/server.sh><code>./server.sh</code></a> script - how you go about doing this in production will vary greatly depending on how you are managing your machines.</p><p>The <strong>Nomad Clients</strong> also need the Vault integration enabling, but in their case, it only needs the location of Vault, as the Server node(s) will provide tokens for the clients to use.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>vault {
</span></span><span style=display:flex><span>    enabled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    address <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://nomad1.mshome.net:8200&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=job-requirements>Job Requirements<a hidden class=anchor aria-hidden=true href=#job-requirements>#</a></h2><p>Before we go about changing the job itself, we need to write some data into Vault for the job to use:</p><ul><li>Credentials: Username and password for the RabbitMQ Management UI, and the <code>RABBITMQ_ERLANG_COOKIE</code></li><li>A policy for the job allowing Certificate Generation and Credentials access</li></ul><h3 id=credentials>Credentials<a hidden class=anchor aria-hidden=true href=#credentials>#</a></h3><p>First off, we need to create a username and password to use with the Management UI. This can be done via the Vault CLI:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault kv put secret/rabbit/admin <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    username<span style=color:#f92672>=</span>administrator <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    password<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>cat /proc/sys/kernel/random/uuid<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>For the Erlang Cookie, we will also generate a Guid, but this time we will store it under a separate path in Vault so that it can be locked down separately to the admin username and password if needed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault kv put secret/rabbit/cookie <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    cookie<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>cat /proc/sys/kernel/random/uuid<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><h3 id=job-policy>Job Policy<a hidden class=anchor aria-hidden=true href=#job-policy>#</a></h3><p>Following the principle of <a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>Least Privilege</a>, we will create a policy for our <code>rabbit</code> job which only allows certificates to be generated, and rabbit credentials to be read.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>path <span style=color:#e6db74>&#34;pki/issue/rabbit&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;create&#34;</span>, <span style=color:#e6db74>&#34;read&#34;</span>, <span style=color:#e6db74>&#34;update&#34;</span>, <span style=color:#e6db74>&#34;delete&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;secret/data/rabbit/*&#34;</span> {
</span></span><span style=display:flex><span>  capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;read&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is written into Vault in the same way as the other policies were:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault policy write rabbit /vagrant/vault/rabbit-policy.hcl
</span></span></code></pre></div><h2 id=rabbit-job-configuration>Rabbit Job Configuration<a hidden class=anchor aria-hidden=true href=#rabbit-job-configuration>#</a></h2><p>The first thing we need to do to the job is specify what policies we want to use with Vault, and what to do when a token or credential expires:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>task <span style=color:#e6db74>&#34;rabbit&#34;</span> {
</span></span><span style=display:flex><span>  driver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;docker&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  vault {
</span></span><span style=display:flex><span>    policies <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;default&#34;</span>, <span style=color:#e6db74>&#34;rabbit&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    change_mode <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;restart&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>#...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=certificates>Certificates<a hidden class=anchor aria-hidden=true href=#certificates>#</a></h3><p>To configure RabbitMQ to use SSL, we need to provide it with values for 3 environment variables:</p><ul><li><code>RABBITMQ_SSL_CACERTFILE</code> - The CA certificate</li><li><code>RABBITMQ_SSL_CERTFILE</code> - The Certificate for RabbitMQ to use</li><li><code>RABBITMQ_SSL_KEYFILE</code> - the PrivateKey for the RabbitMQ certificate</li></ul><p>So let&rsquo;s add a <code>template</code> block to the job to generate and write out a certificate. It&rsquo;s worth noting that <strong>line endings matter</strong>. You either need your <code>.nomad</code> file to use LF line endings, or make the <code>template</code> a single line and use <code>\n</code> to add the correct line endings in. I prefer to have the file with LF line endings.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>template <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  data <span style=color:#f92672>=</span> <span style=color:#e6db74>&lt;&lt;EOH
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{{ $host := printf &#34;common_name=%s.mshome.net&#34; (env &#34;attr.unique.hostname&#34;) }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{{ with secret &#34;pki/issue/rabbit&#34; $host &#34;format=pem&#34; }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{{ .Data.certificate }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>{{ .Data.private_key }}{{ end }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOH</span>
</span></span><span style=display:flex><span>  destination <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;secrets/rabbit.pem&#34;</span>
</span></span><span style=display:flex><span>  change_mode <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;restart&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>As we want to use the Nomad node&rsquo;s hostname within the <code>common_name</code> parameter of the secret, we need to use a variable to fetch and format the value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>{{ $host :<span style=color:#f92672>=</span> printf <span style=color:#e6db74>&#34;common_name=%s.mshome.net&#34;</span> (env <span style=color:#e6db74>&#34;attr.unique.hostname&#34;</span>) }}
</span></span></code></pre></div><p>This can then be used by the <code>with secret</code> block to fetch a certificate for the current host:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>{{ with secret <span style=color:#e6db74>&#34;pki/issue/rabbit&#34;</span> $host <span style=color:#e6db74>&#34;format=pem&#34;</span> }}
</span></span></code></pre></div><p>Now that we have a certificate in the <code>./secrets/</code> directory, we can add a couple of volume mounts to the container, and set the environment variables with the container paths to the certificates. Note how the root certificate is coming from the <code>/vagrant</code> directory, not from Vault itself. Depending on how you are provisioning your machines to trust your CA, you will have a different path here!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>config {
</span></span><span style=display:flex><span>  image <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;pondidum/rabbitmq:consul&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>  volumes <span style=color:#f92672>=</span> <span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/vagrant/vault/mshome.crt:/etc/ssl/certs/mshome.crt&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;secrets/rabbit.pem:/etc/ssl/certs/rabbit.pem&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;secrets/rabbit.pem:/tmp/rabbitmq-ssl/combined.pem&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>env {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>RABBITMQ_SSL_CACERTFILE</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/etc/ssl/certs/mshome.crt&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>RABBITMQ_SSL_CERTFILE</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/etc/ssl/certs/rabbit.pem&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>RABBITMQ_SSL_KEYFILE</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/etc/ssl/certs/rabbit.pem&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>#...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You should also notice that we are writing the <code>secrets/rabbit.pem</code> file into the container twice: The second write is to a file in <code>/tmp</code> as a workaround for the <code>docker-entrypoint.sh</code> script. If we don&rsquo;t create this file ourselves, the container script will create it by combining the <code>RABBITMQ_SSL_CERTFILE</code> file and <code>RABBITMQ_SSL_KEYFILE</code> file, which will result in an invalid certificate, and a nightmare to figure out&mldr;</p><p>If the Vault integration in Nomad could write a single generated secret to two separate files, we wouldn&rsquo;t need this workaround. Alternatively, you could make a custom container with a customised startup script to deal with this for you.</p><p>You can see the version of this file with <a href=https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/a588d7c2483c999b2fa0f47433403dfe1838fd50/rabbit/secure.nomad>only these changes here</a></p><h3 id=credentials-1>Credentials<a hidden class=anchor aria-hidden=true href=#credentials-1>#</a></h3><p>Now that we have things running with a certificate, it would be a great idea to start using the Erlang Cookie value and Management UI credentials we stored in Vault earlier. This is a super easy change to support in the Nomad file - we need to add another <code>template</code> block, but this time set <code>env = true</code> which will instruct nomad that the key-values in the template should be loaded as environment variables:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>template <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    data <span style=color:#f92672>=</span> <span style=color:#e6db74>&lt;&lt;EOH
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {{ with secret &#34;secret/data/rabbit/cookie&#34; }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    RABBITMQ_ERLANG_COOKIE=&#34;{{ .Data.data.cookie }}&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {{ end }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {{ with secret &#34;secret/data/rabbit/admin&#34; }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    RABBITMQ_DEFAULT_USER={{ .Data.data.username }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    RABBITMQ_DEFAULT_PASS={{ .Data.data.password }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {{ end }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOH</span>
</span></span><span style=display:flex><span>    destination <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;secrets/rabbit.env&#34;</span>
</span></span><span style=display:flex><span>    env <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>The complete nomad file with <a href=https://github.com/Pondidum/Nomad-RabbitMQ-Demo/blob/a78736cac3a93a43a96cbe84492089fca29d15e1/rabbit/secure.nomad>both certificates and credentials can be seen here</a>.</p><h2 id=running>Running!<a hidden class=anchor aria-hidden=true href=#running>#</a></h2><p>Now, all we need to do is start our new secure cluster:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nomad job run rabbit/secure.nomad
</span></span></code></pre></div><h2 id=client-libraries>Client Libraries<a hidden class=anchor aria-hidden=true href=#client-libraries>#</a></h2><p>Now that you have a secure version of RabbitMQ running, there are some interesting things which can be done with the client libraries. While you can just use the secure port, RabbitMQ also supports <a href=https://www.rabbitmq.com/ssl.html#peer-verification>Peer Verification</a>, which means that the client has to present a certificate for itself, and RabbitMQ will validate that both certificates are signed by a common CA.</p><p>This process can be controlled with two environment variables:</p><ul><li><code>RABBITMQ_SSL_VERIFY</code> set to either <code>verify_peer</code> or <code>verify_none</code></li><li><code>RABBITMQ_SSL_FAIL_IF_NO_PEER_CERT</code> set to <code>true</code> to require client certificates, <code>false</code> to make them optional</li></ul><p>In .net land, if you are using MassTransit, the configuration looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> bus = Bus.Factory.CreateUsingRabbitMq(c =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    c.UseSerilog(logger);
</span></span><span style=display:flex><span>    c.Host(<span style=color:#e6db74>&#34;rabbitmq://nomad1.mshome.net:5671&#34;</span>, r =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        r.Username(<span style=color:#e6db74>&#34;some_application&#34;</span>);
</span></span><span style=display:flex><span>        r.Password(<span style=color:#e6db74>&#34;some_password&#34;</span>);
</span></span><span style=display:flex><span>        r.UseSsl(ssl =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            ssl.CertificatePath = <span style=color:#e6db74>@&#34;secrets/app.crt&#34;</span>;
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>There are also lots of other interesting things you can do with SSL and RabbitMQ, such as using the certificate as authentication rather than needing a username and password per app. But you should be generating your app credentials dynamically with Vault too&mldr;</p><h1 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h1><p>Finding all the small parts to make this work was quite a challenge. The <a href=https://gitter.im/hashicorp-nomad/Lobby>Nomad gitter</a> was useful when trying to figure out the certificates issue, and being able to read the <a href=https://github.com/docker-library/rabbitmq/blob/4b2b11c59ee65c2a09616b163d4572559a86bb7b/3.7/alpine/docker-entrypoint.sh#L363>source code</a> of the Docker image for RabbitMQ was invaluable to making the Certificate work.</p><p>If anyone sees anything I&rsquo;ve done wrong, or could be improved, I&rsquo;m happy to hear it!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/infrastructure/>infrastructure</a></li><li><a href=https://andydote.co.uk/tags/vagrant/>vagrant</a></li><li><a href=https://andydote.co.uk/tags/nomad/>nomad</a></li><li><a href=https://andydote.co.uk/tags/consul/>consul</a></li><li><a href=https://andydote.co.uk/tags/rabbitmq/>rabbitmq</a></li><li><a href=https://andydote.co.uk/tags/vault/>vault</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2019/05/29/consul-dns-forwarding/><span class=title>« Prev Page</span><br><span>Configuring Consul DNS Forwarding in Ubuntu 16.04</span>
</a><a class=next href=https://andydote.co.uk/2019/03/22/hyperv-networking/><span class=title>Next Page »</span><br><span>Hyper-V, Docker, and Networking Drama</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>