<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Consul DNS Fowarding in Alpine, revisited | Andy Dote</title><meta name=keywords content="consul,dns,infrastructure"><meta name=description content="I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn&rsquo;t resolve *.consul domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.
After a lot of googling and frustration, I was able to track down that it&rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn&rsquo;t do."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4ac25d88867f6882d86478d9b478a3d3efa1ed9e18f0bc5e432812301516cb28.css integrity="sha256-SsJdiIZ/aILYZHjZtHij0++h7Z4Y8LxeQygSMBUWyyg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Consul DNS Fowarding in Alpine, revisited"><meta property="og:description" content="I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn&rsquo;t resolve *.consul domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.
After a lot of googling and frustration, I was able to track down that it&rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn&rsquo;t do."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/"><meta property="article:section" content="post"><meta property="article:published_time" content="2019-12-30T00:00:00+00:00"><meta property="article:modified_time" content="2019-12-30T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Consul DNS Fowarding in Alpine, revisited"><meta name=twitter:description content="I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn&rsquo;t resolve *.consul domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.
After a lot of googling and frustration, I was able to track down that it&rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn&rsquo;t do."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Consul DNS Fowarding in Alpine, revisited","item":"https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Consul DNS Fowarding in Alpine, revisited","name":"Consul DNS Fowarding in Alpine, revisited","description":"I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn\u0026rsquo;t resolve *.consul domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.\nAfter a lot of googling and frustration, I was able to track down that it\u0026rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn\u0026rsquo;t do.","keywords":["consul","dns","infrastructure"],"articleBody":"I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn’t resolve *.consul domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.\nAfter a lot of googling and frustration, I was able to track down that it’s down to a difference (or optimisation) in musl libc, which glibc doesn’t do. From Musl libc’s Functional differences from glibc page, we can see under the Name Resolver/DNS section the relevant information:\nTraditional resolvers, including glibc’s, make use of multiple nameserver lines in resolv.conf by trying each one in sequence and falling to the next after one times out. musl’s resolver queries them all in parallel and accepts whichever response arrives first.\nThe machine’s /etc/resolv.conf file has two nameserver specified:\nnameserver 127.0.0.1 nameserver 192.168.121.1 The first is our Unbound instance which handles the forwarding to Consul, and the second is the DHCP set DNS server, in this case, libvirt/qemu’s dnsmasq instance.\nWhen running in a glibc based system, queries go to the first nameserver, and then if that can’t resolve the request, it is then sent to the next nameserver, and so forth. As Alpine Linux uses muslc, it makes the requests in parallel and uses the response from whichever response comes back first.\nWhen the DHCP DNS server is a network hop away, the latency involved means our resolution usually works, as the queries will hit the local DNS and get a response first. However, when the DHCP DNS is not that far away, for example when it is the DNS server that libvirt runs in the virtual network the machine is attached to, it becomes much more likely to get a response from that DNS server first, causing the failures I was seeing.\nThe solution to this is to change the setup so that all requests go to Unbound, which can then decide where to send them on to. This also has the additional benefits of making all DNS requests work the same on all systems; regardless of glibc or muslc being used.\nRebuilding DNS Resolution You can follow the same instructions in my previous Consul DNS forwarding post to setup Consul, as that is already in the right state for us.\nOnce Consul is up and running, it’s time to fix the rest of our pipeline.\nUnbound First, install unbound and configure it to start on boot:\napk add unbound rc-update add unbound The unbound config file (/etc/unbound/unbound.conf) is almost the same as the previous version, except we also have an include statement, pointing to a second config file, which we will generate shortly:\nserver: verbosity: 1 do-not-query-localhost: no domain-insecure: \"consul\" stub-zone: name: \"consul\" stub-addr: 127.0.0.1@8600 include: \"/etc/unbound/forward.conf\" Dhclient Next, we install dhclient so that we can make use of it’s hooks feature to generate our additional unbound config file.\napk add dhclient Create a config file for dhclient (/etc/dhcp/dhclient.conf), which again is almost the same as the previous post, but this time doesn’t specify prepend domain-name-servers:\noption rfc3442-classless-static-routes code 121 = array of unsigned integer 8; send host-name = gethostname(); request subnet-mask, broadcast-address, time-offset, routers, domain-name, domain-name-servers, domain-search, host-name, dhcp6.name-servers, dhcp6.domain-search, dhcp6.fqdn, dhcp6.sntp-servers, netbios-name-servers, netbios-scope, interface-mtu, rfc3442-classless-static-routes, ntp-servers; Now we can write two hooks. The first is an enter hook, which we can use to write the forward.conf file out.\ntouch /etc/dhclient-enter-hooks chmod +x /etc/dhclient-enter-hooks The content is a single statement to write the new_domain_name_servers value into a forward-zone for unbound:\n#!/bin/sh ( cat \u003c\u003c-EOF forward-zone: name: \".\" forward-addr: ${new_domain_name_servers} EOF ) | sudo tee /etc/unbound/forward.conf The second hook is an exit ook, which runs after dhclient has finished writing out all the files it controls (such as /etc/resolv.conf):\ntouch /etc/dhclient-exit-hooks chmod +x /etc/dhclient-exit-hooks The content is a single sed statement to replace the address of nameserver directives written to the /etc/resolv.conf with the unbound address:\n#!/bin/sh sudo sed -i 's/nameserver.*/nameserver 127.0.0.1/g' /etc/resolv.conf It’s worth noting; we could put the content of the enter hook into the exit hook if you would rather.\nFinally, we can delete our current resolv.conf and restart the networking service:\nrm /etc/resolv.conf # hack due to it dhclient making an invalid `chown` call. rc-service networking restart Testing We can now test that we can resolve the three kinds of address we care about:\ndig consul.service.consul - should return the eth0 ip of the machine dig alpinetest.karhu.xyz - should be resolved by libvirt’s dnsmasq instance dig example.com - should be resolved by an upstream DNS server Conculsion This was an interesting and somewhat annoying problem to solve, but it means I have a more robust setup in my virtual machines now. It’s interesting to note that if the DNS server from DHCP were not a local instance, the network latency added would make all the system function properly most of the time, as the local instance would answer before the remote instance could.\n","wordCount":"825","inLanguage":"en","datePublished":"2019-12-30T00:00:00Z","dateModified":"2019-12-30T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Consul DNS Fowarding in Alpine, revisited</h1><div class=post-meta><span title='2019-12-30 00:00:00 +0000 UTC'>December 30, 2019</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>I noticed when running an Alpine based virtual machine with Consul DNS forwarding set up, that sometimes the machine couldn&rsquo;t resolve <code>*.consul</code> domains, but not in a consistent manner. Inspecting the logs looked like the request was being made and responded to successfully, but the result was being ignored.</p><p>After a lot of googling and frustration, I was able to track down that it&rsquo;s down to a difference (or optimisation) in musl libc, which glibc doesn&rsquo;t do. From Musl libc&rsquo;s <a href=https://wiki.musl-libc.org/functional-differences-from-glibc.html>Functional differences from glibc</a> page, we can see under the Name Resolver/DNS section the relevant information:</p><blockquote><p>Traditional resolvers, including glibc&rsquo;s, make use of multiple nameserver lines in resolv.conf by trying each one in sequence and falling to the next after one times out. musl&rsquo;s resolver queries them all in parallel and accepts whichever response arrives first.</p></blockquote><p>The machine&rsquo;s <code>/etc/resolv.conf</code> file has two <code>nameserver</code> specified:</p><pre tabindex=0><code>nameserver 127.0.0.1
nameserver 192.168.121.1
</code></pre><p>The first is our <code>Unbound</code> instance which handles the forwarding to Consul, and the second is the DHCP set DNS server, in this case, libvirt/qemu&rsquo;s dnsmasq instance.</p><p>When running in a glibc based system, queries go to the first <code>nameserver</code>, and then if that can&rsquo;t resolve the request, it is then sent to the next <code>nameserver</code>, and so forth. As Alpine Linux uses muslc, it makes the requests in parallel and uses the response from whichever response comes back first.</p><p><img loading=lazy src=/images/muslc-dns.png alt="sequence diagram, showing parallel DNS requests"></p><p>When the DHCP DNS server is a network hop away, the latency involved means our resolution usually works, as the queries will hit the local DNS and get a response first. However, when the DHCP DNS is not that far away, for example when it is the DNS server that libvirt runs in the virtual network the machine is attached to, it becomes much more likely to get a response from that DNS server first, causing the failures I was seeing.</p><p>The solution to this is to change the setup so that all requests go to Unbound, which can then decide where to send them on to. This also has the additional benefits of making all DNS requests work the same on all systems; regardless of glibc or muslc being used.</p><p><img loading=lazy src=/images/unbound-dns.png alt="sequence diagram, showing all DNS requests going through unbound"></p><h2 id=rebuilding-dns-resolution>Rebuilding DNS Resolution<a hidden class=anchor aria-hidden=true href=#rebuilding-dns-resolution>#</a></h2><p>You can follow the same instructions in my previous <a href=/2019/05/31/consul-dns-forwarding-alpine/#run-consul>Consul DNS forwarding</a> post to setup Consul, as that is already in the right state for us.</p><p>Once Consul is up and running, it&rsquo;s time to fix the rest of our pipeline.</p><h3 id=unbound>Unbound<a hidden class=anchor aria-hidden=true href=#unbound>#</a></h3><p>First, install <code>unbound</code> and configure it to start on boot:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apk add unbound
</span></span><span style=display:flex><span>rc-update add unbound
</span></span></code></pre></div><p>The unbound config file (<code>/etc/unbound/unbound.conf</code>) is almost the same as the previous version, except we also have an <code>include</code> statement, pointing to a second config file, which we will generate shortly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>server</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>verbosity</span>: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>do-not-query-localhost</span>: <span style=color:#66d9ef>no</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>domain-insecure</span>: <span style=color:#e6db74>&#34;consul&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>stub-zone</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;consul&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>stub-addr</span>: <span style=color:#ae81ff>127.0.0.1</span>@<span style=color:#ae81ff>8600</span>
</span></span><span style=display:flex><span><span style=color:#f92672>include</span>: <span style=color:#e6db74>&#34;/etc/unbound/forward.conf&#34;</span>
</span></span></code></pre></div><h3 id=dhclient>Dhclient<a hidden class=anchor aria-hidden=true href=#dhclient>#</a></h3><p>Next, we install <code>dhclient</code> so that we can make use of it&rsquo;s hooks feature to generate our additional unbound config file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>apk add dhclient
</span></span></code></pre></div><p>Create a config file for dhclient (<code>/etc/dhcp/dhclient.conf</code>), which again is almost the same as the previous post, but this time doesn&rsquo;t specify <code>prepend domain-name-servers</code>:</p><pre tabindex=0><code class=language-conf data-lang=conf>option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;
send host-name = gethostname();
request subnet-mask, broadcast-address, time-offset, routers,
 domain-name, domain-name-servers, domain-search, host-name,
 dhcp6.name-servers, dhcp6.domain-search, dhcp6.fqdn, dhcp6.sntp-servers,
 netbios-name-servers, netbios-scope, interface-mtu,
 rfc3442-classless-static-routes, ntp-servers;
</code></pre><p>Now we can write two hooks. The first is an enter hook, which we can use to write the <code>forward.conf</code> file out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>touch /etc/dhclient-enter-hooks
</span></span><span style=display:flex><span>chmod +x /etc/dhclient-enter-hooks
</span></span></code></pre></div><p>The content is a single statement to write the <code>new_domain_name_servers</code> value into a <code>forward-zone</code> for unbound:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>cat <span style=color:#e6db74>&lt;&lt;-EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>forward-zone:
</span></span></span><span style=display:flex><span><span style=color:#e6db74> name: &#34;.&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74> forward-addr: ${new_domain_name_servers}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span><span style=color:#f92672>)</span> | sudo tee /etc/unbound/forward.conf
</span></span></code></pre></div><p>The second hook is an exit ook, which runs after dhclient has finished writing out all the files it controls (such as <code>/etc/resolv.conf</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>touch /etc/dhclient-exit-hooks
</span></span><span style=display:flex><span>chmod +x /etc/dhclient-exit-hooks
</span></span></code></pre></div><p>The content is a single <code>sed</code> statement to replace the address of <code>nameserver</code> directives written to the <code>/etc/resolv.conf</code> with the unbound address:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>sudo sed -i <span style=color:#e6db74>&#39;s/nameserver.*/nameserver 127.0.0.1/g&#39;</span> /etc/resolv.conf
</span></span></code></pre></div><p>It&rsquo;s worth noting; we could put the content of the <code>enter</code> hook into the <code>exit</code> hook if you would rather.</p><p>Finally, we can delete our current <code>resolv.conf</code> and restart the networking service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>rm /etc/resolv.conf <span style=color:#75715e># hack due to it dhclient making an invalid `chown` call.</span>
</span></span><span style=display:flex><span>rc-service networking restart
</span></span></code></pre></div><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>We can now test that we can resolve the three kinds of address we care about:</p><ul><li><code>dig consul.service.consul</code> - should return the <code>eth0</code> ip of the machine</li><li><code>dig alpinetest.karhu.xyz</code> - should be resolved by libvirt&rsquo;s dnsmasq instance</li><li><code>dig example.com</code> - should be resolved by an upstream DNS server</li></ul><h2 id=conculsion>Conculsion<a hidden class=anchor aria-hidden=true href=#conculsion>#</a></h2><p>This was an interesting and somewhat annoying problem to solve, but it means I have a more robust setup in my virtual machines now. It&rsquo;s interesting to note that if the DNS server from DHCP were not a local instance, the network latency added would make all the system function properly most of the time, as the local instance would answer before the remote instance could.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/consul/>consul</a></li><li><a href=https://andydote.co.uk/tags/dns/>dns</a></li><li><a href=https://andydote.co.uk/tags/infrastructure/>infrastructure</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2020/02/29/nomad-isolated-exec/><span class=title>« Prev Page</span><br><span>Nomad Isolated Exec</span></a>
<a class=next href=https://andydote.co.uk/2019/12/22/libvirt-hostname-resolution/><span class=title>Next Page »</span><br><span>Libvirt Hostname Resolution</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>