<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles - ISP | Andy Dote</title>
<meta name=keywords content="design,c#,solid"><meta name=description content="Interface Segregation Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
Interface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.
So as usual, lets start off with an set of types which don&rsquo;t adhere to the principle."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/03/01/solid-principles-isp/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Principles - ISP"><meta property="og:description" content="Interface Segregation Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
Interface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.
So as usual, lets start off with an set of types which don&rsquo;t adhere to the principle."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/03/01/solid-principles-isp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-03-01T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles - ISP"><meta name=twitter:description content="Interface Segregation Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
Interface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.
So as usual, lets start off with an set of types which don&rsquo;t adhere to the principle."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"SOLID Principles - ISP","item":"https://andydote.co.uk/2014/03/01/solid-principles-isp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles - ISP","name":"SOLID Principles - ISP","description":"Interface Segregation Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nInterface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.\nSo as usual, lets start off with an set of types which don\u0026rsquo;t adhere to the principle.","keywords":["design","c#","solid"],"articleBody":"Interface Segregation Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nInterface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.\nSo as usual, lets start off with an set of types which don’t adhere to the principle. Starting off, we have the following interface, which we are using to write data access classes with:\npublic interface IEntity { Guid ID { get; } void Save(); void Load(); } And a class which implements the interface:\npublic class Entity : IEntity { public Guid ID { get; private set; } public void Save() { Database.Save(this); } public void Load() { using (var reader = Database.Load(ID)) { ID = reader.GetGuid(0); Read(reader); } } protected virtual void Read(IDataReader reader) { //nothing in the base } } At first glance, this seems like a pretty reasonable Entity, it doesn’t have multiple responsibilities, and it is very simple. However, when we bring the second implementation of IEntity into the mix, it becomes more clear that some segregation would be useful:\npublic class ReadOnlyEntity : IEntity { public Guid ID { get; private set; } public void Save() { //do nothing } public void Load() { using (var reader = Database.Load(ID)) { ID = reader.GetGuid(0); Read(reader); } } protected virtual void Read(IDataReader reader) { //nothing in the base } } Why would a ReadOnlyEntity need a Save() method? What happens if you have a collection of data which gets loaded from your database, but never gets saved back (a list of countries and associated data for example.) Also, consumers of the IEntity interface get more access to methods than they need, for example the Database class being used here:\npublic class Database { public static void Save(IEntity entity) { entity.Load();\t//? } } From looking at our usages of our entities, we can see there are two specific roles: something that can be loaded, and something that can be saved. We start our separation by inheriting our existing interface:\npublic interface IEntity : ISaveable, ILoadable { } public interface ISaveable { Guid ID { get; } void Save(); } public interface ILoadable { Guid ID { get; } void Load(); } Here we have pulled the method and properties relevant for saving into one interface, and the methods and properties relevant to loading into another. By making IEntity inherit both ISaveable and ILoadable, we have no need to change any existing code yet.\nOur next step is to change usages of IEntity to take in the more specific interface that they require:\npublic class Database { public static void Save(ISaveable entity) { } } Once this is done, we can remove the IEntity interface, and update our implementations to use ISaveable and ILoadable instead:\npublic class Entity : ISaveable, ILoadable { public Guid ID { get; private set; } public void Save() { Database.Save(this); } public void Load() { using (var reader = Database.Load(ID)) { ID = reader.GetGuid(0); Read(reader); } } protected virtual void Read(IDataReader reader) { //nothing in the base } } public class ReadOnlyEntity : ILoadable { public Guid ID { get; private set; } public void Load() { using (var reader = Original.Database.Load(ID)) { ID = reader.GetGuid(0); Read(reader); } } protected virtual void Read(IDataReader reader) { //nothing in the base } } Now our objects are showing specifically what they are capable of - the ReadOnlyEntity doesn’t have a Save() method which you are not supposed to call!\nIf you do have a method which requires an object which is both an ISaveable and an ILoadable, rather than pass in the same object to two parameters, you can achieve it with a generic parameter:\npublic void DoSomething(T entity) where T : ISaveable, ILoadable { entity.Save(); entity.Load(); } Hopefully this shows the reasoning of segregating your interfaces and the steps to segregate existing interfaces.\nAll source code is available on my Github: Solid.Demo Source Code\n","wordCount":"688","inLanguage":"en","datePublished":"2014-03-01T00:00:00Z","dateModified":"2014-03-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/03/01/solid-principles-isp/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles - ISP</h1><div class=post-meta>&lt;span title='2014-03-01 00:00:00 +0000 UTC'>March 1, 2014&lt;/span>&amp;nbsp;·&amp;nbsp;4 min</div></header><div class=post-content><h2 id=interface-segregation-principle>Interface Segregation Principle<a hidden class=anchor aria-hidden=true href=#interface-segregation-principle>#</a></h2><p><a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility</a> | <a href=http://andydote.co.uk/solid-principles-ocp>Open Closed</a> | <a href=http://andydote.co.uk/solid-principles-lsp>Liskov Substitution</a> | <a href=http://andydote.co.uk/solid-principles-isp>Interface Segregation</a> | <a href=http://andydote.co.uk/solid-principles-dip>Dependency Inversion</a></p><p>Interface Segregation I find is often ignored, or people tend not to see the point in. Segregating your Interfaces is a very useful way of reducing compexity in your systems, and comes with a number of benefits, such as making mocking inputs easier, and making your objects smaller and simpler.</p><p>So as usual, lets start off with an set of types which don&rsquo;t adhere to the principle. Starting off, we have the following interface, which we are using to write data access classes with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IEntity</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Guid ID { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> Save();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> Load();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And a class which implements the interface:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entity</span> : IEntity
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Guid ID { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Save()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Database.Save(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Load()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> reader = Database.Load(ID))
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			ID = reader.GetGuid(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>			Read(reader);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Read(IDataReader reader)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>//nothing in the base</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At first glance, this seems like a pretty reasonable Entity, it doesn&rsquo;t have multiple responsibilities, and it is very simple. However, when we bring the second implementation of <code>IEntity</code> into the mix, it becomes more clear that some segregation would be useful:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReadOnlyEntity</span> : IEntity
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Guid ID { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Save()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>//do nothing</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Load()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> reader = Database.Load(ID))
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			ID = reader.GetGuid(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>			Read(reader);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Read(IDataReader reader)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>//nothing in the base</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Why would a <code>ReadOnlyEntity</code> need a <code>Save()</code> method? What happens if you have a collection of data which gets loaded from your database, but never gets saved back (a list of countries and associated data for example.) Also, consumers of the <code>IEntity</code> interface get more access to methods than they need, for example the <code>Database</code> class being used here:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Database</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Save(IEntity entity)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		entity.Load();	<span style=color:#75715e>//?</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>From looking at our usages of our entities, we can see there are two specific roles: something that can be loaded, and something that can be saved. We start our separation by inheriting our existing interface:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IEntity</span> : ISaveable, ILoadable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ISaveable</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Guid ID { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> Save();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ILoadable</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	Guid ID { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>void</span> Load();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we have pulled the method and properties relevant for saving into one interface, and the methods and properties relevant to loading into another. By making <code>IEntity</code> inherit both <code>ISaveable</code> and <code>ILoadable</code>, we have no need to change any existing code yet.</p><p>Our next step is to change usages of <code>IEntity</code> to take in the more specific interface that they require:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Database</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Save(ISaveable entity)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once this is done, we can remove the <code>IEntity</code> interface, and update our implementations to use <code>ISaveable</code> and <code>ILoadable</code> instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Entity</span> : ISaveable, ILoadable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Guid ID { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Save()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Database.Save(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Load()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> reader = Database.Load(ID))
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			ID = reader.GetGuid(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>			Read(reader);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Read(IDataReader reader)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>//nothing in the base</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ReadOnlyEntity</span> : ILoadable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Guid ID { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Load()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> reader = Original.Database.Load(ID))
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			ID = reader.GetGuid(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>			Read(reader);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Read(IDataReader reader)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#75715e>//nothing in the base</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now our objects are showing specifically what they are capable of - the <code>ReadOnlyEntity</code> doesn&rsquo;t have a <code>Save()</code> method which you are not supposed to call!</p><p>If you do have a method which requires an object which is both an <code>ISaveable</code> and an <code>ILoadable</code>, rather than pass in the same object to two parameters, you can achieve it with a generic parameter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> DoSomething&lt;T&gt;(T entity) <span style=color:#66d9ef>where</span> T : ISaveable, ILoadable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	entity.Save();
</span></span><span style=display:flex><span>	entity.Load();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Hopefully this shows the reasoning of segregating your interfaces and the steps to segregate existing interfaces.</p><p>All source code is available on my Github: <a href=https://github.com/Pondidum/Solid.Demo>Solid.Demo Source Code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/solid/>solid</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/03/15/solid-principles-dip/><span class=title>« Prev Page</span><br><span>SOLID Principles - DIP</span>
</a><a class=next href=https://andydote.co.uk/2014/02/23/solid-principles-lsp/><span class=title>Next Page »</span><br><span>SOLID Principles - LSP</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>