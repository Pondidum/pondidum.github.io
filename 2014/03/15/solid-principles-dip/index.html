<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles - DIP | Andy Dote</title><meta name=keywords content="design,c#,solid"><meta name=description content="Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Dependency Inversion Principle states that &ldquo;Depend upon Abstractions. Do not depend upon concretions&rdquo;. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don&rsquo;t have to buy new set of devices when you move house, and you don&rsquo;t have to buy a new house for your devices!"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/03/15/solid-principles-dip/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Principles - DIP"><meta property="og:description" content="Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Dependency Inversion Principle states that &ldquo;Depend upon Abstractions. Do not depend upon concretions&rdquo;. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don&rsquo;t have to buy new set of devices when you move house, and you don&rsquo;t have to buy a new house for your devices!"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/03/15/solid-principles-dip/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-03-15T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles - DIP"><meta name=twitter:description content="Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Dependency Inversion Principle states that &ldquo;Depend upon Abstractions. Do not depend upon concretions&rdquo;. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don&rsquo;t have to buy new set of devices when you move house, and you don&rsquo;t have to buy a new house for your devices!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"SOLID Principles - DIP","item":"https://andydote.co.uk/2014/03/15/solid-principles-dip/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles - DIP","name":"SOLID Principles - DIP","description":"Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Dependency Inversion Principle states that \u0026ldquo;Depend upon Abstractions. Do not depend upon concretions\u0026rdquo;. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don\u0026rsquo;t have to buy new set of devices when you move house, and you don\u0026rsquo;t have to buy a new house for your devices!","keywords":["design","c#","solid"],"articleBody":"Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Dependency Inversion Principle states that “Depend upon Abstractions. Do not depend upon concretions”. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don’t have to buy new set of devices when you move house, and you don’t have to buy a new house for your devices!\nIn software terms this means that our higher level classes should not directly depend on lower level classes, but should depend on some intermediary. The same goes for depending on external resources. For example, if you have this class which takes a request string, and deserializes it, and does something with the resulting object:\npublic class RequestHandler { \tpublic void OnRequestReceived(string json) \t{ \tvar data = NewtonSoftJson.Deserialize(json);  \tConsole.WriteLine(data.Name + \" Received.\"); \t} } This has two problems - the first is that it is totally dependant on the NewtonSoftJson class which means we are in violation of the Dependency Inversion Principle, and also we are tied to a specific provider. We also are using a static method on the NewtonSoftJson class, which makes the method impossible to test, if we didn’t want to depend on NewtonSoftJson for our test.\nWe can move towards fixing both of these problems by adding an interface, and depending on that for serialization instead:\npublic interface IJsonSerializer { \tT Deserialize(string json); }  public class JsonSerializer : IJsonSerializer { \tpublic T Deserialize(string json) \t{ \treturn NewtonSoftJson.Deserialize(json); \t} }  public class RequestHandler { \tprivate readonly IJsonSerializer _serializer;  \tpublic RequestHandler(IJsonSerializer serializer) \t{ \t_serializer = serializer; \t}  \tpublic void OnRequestReceived(string json) \t{ \tvar data = _serializer.Deserialize(json);  \tConsole.WriteLine(data.Name + \" Received.\"); \t} } By doing this, the RequestHandler class is now dependant on an abstraction rather than a concretion. This nets us many benefits: We are no longer directly dependant on NewtonSoftJson, our OnRequestReceived method has become more testable, and we have also centralised our json serialization logic.\nThis means that if we wish to change to a different library for json serialization (or use the JavaScriptSerializer built into the .net framework) we can just create a new class which implements IJsonSerializer and pass an instance of the new class to RequestHandler. It also means that anywhere we want to do json serialization can just take an IJsonSerializer in as a dependency, and not care what the dependency is actually doing when Deserialize is called.\nHopefully this explains a little more on how inverting your dependencies can help make your software more flexible, and more maintainable.\nAll source code is available on my Github: Solid.Demo Source Code\n","wordCount":"446","inLanguage":"en","datePublished":"2014-03-15T00:00:00Z","dateModified":"2014-03-15T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/03/15/solid-principles-dip/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles - DIP</h1><div class=post-meta><span title="2014-03-15 00:00:00 +0000 UTC">March 15, 2014</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p><a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility</a> | <a href=http://andydote.co.uk/solid-principles-ocp>Open Closed</a> | <a href=http://andydote.co.uk/solid-principles-lsp>Liskov Substitution</a> | <a href=http://andydote.co.uk/solid-principles-isp>Interface Segregation</a> | <a href=http://andydote.co.uk/solid-principles-dip>Dependency Inversion</a></p><p>The Dependency Inversion Principle states that &ldquo;Depend upon Abstractions. Do not depend upon concretions&rdquo;. A good real world example of this is plug sockets around your house; any device you buy can be plugged into any socket in your house. You don&rsquo;t have to buy new set of devices when you move house, and you don&rsquo;t have to buy a new house for your devices!</p><p>In software terms this means that our higher level classes should not directly depend on lower level classes, but should depend on some intermediary. The same goes for depending on external resources. For example, if you have this class which takes a request string, and deserializes it, and does something with the resulting object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RequestHandler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnRequestReceived(<span style=color:#66d9ef>string</span> json)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> data = NewtonSoftJson.Deserialize&lt;RequestData&gt;(json);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				Console.WriteLine(data.Name + <span style=color:#e6db74>&#34; Received.&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This has two problems - the first is that it is totally dependant on the <code>NewtonSoftJson</code> class which means we are in violation of the Dependency Inversion Principle, and also we are tied to a specific provider. We also are using a static method on the <code>NewtonSoftJson</code> class, which makes the method impossible to test, if we didn&rsquo;t want to depend on <code>NewtonSoftJson</code> for our test.</p><p>We can move towards fixing both of these problems by adding an interface, and depending on that for serialization instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IJsonSerializer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>		T Deserialize&lt;T&gt;(<span style=color:#66d9ef>string</span> json);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JsonSerializer</span> : IJsonSerializer
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> T Deserialize&lt;T&gt;(<span style=color:#66d9ef>string</span> json)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> NewtonSoftJson.Deserialize&lt;T&gt;(json);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RequestHandler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IJsonSerializer <span style=color:#ae81ff>_</span>serializer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> RequestHandler(IJsonSerializer serializer)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>				<span style=color:#ae81ff>_</span>serializer = serializer;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnRequestReceived(<span style=color:#66d9ef>string</span> json)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> data = <span style=color:#ae81ff>_</span>serializer.Deserialize&lt;RequestData&gt;(json);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				Console.WriteLine(data.Name + <span style=color:#e6db74>&#34; Received.&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By doing this, the <code>RequestHandler</code> class is now dependant on an abstraction rather than a concretion. This nets us many benefits: We are no longer directly dependant on <code>NewtonSoftJson</code>, our <code>OnRequestReceived</code> method has become more testable, and we have also centralised our json serialization logic.</p><p>This means that if we wish to change to a different library for json serialization (or use the <code>JavaScriptSerializer</code> built into the .net framework) we can just create a new class which implements <code>IJsonSerializer</code> and pass an instance of the new class to <code>RequestHandler</code>. It also means that anywhere we want to do json serialization can just take an <code>IJsonSerializer</code> in as a dependency, and not care what the dependency is actually doing when <code>Deserialize</code> is called.</p><p>Hopefully this explains a little more on how inverting your dependencies can help make your software more flexible, and more maintainable.</p><p>All source code is available on my Github: <a href=https://github.com/Pondidum/Solid.Demo>Solid.Demo Source Code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/solid/>solid</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/03/29/using-a-micro-orm-to-decouple-your-db-access/><span class=title>« Prev Page</span><br><span>Using a Micro ORM to decouple your DB Access</span></a>
<a class=next href=https://andydote.co.uk/2014/03/01/solid-principles-isp/><span class=title>Next Page »</span><br><span>SOLID Principles - ISP</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>