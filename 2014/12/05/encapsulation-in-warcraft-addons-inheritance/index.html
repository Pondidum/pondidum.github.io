<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Encapsulation in Warcraft Addons - Inheritance | Andy Dote</title><meta name=keywords content="design,lua,warcraft"><meta name=description content="Using Inheritance (sort of) When we actually need inheritance, things get a little more complicated. We need to use two of lua&rsquo;s slightly harder features to get it to work: metatables and colon notation. A little background on these will help:
MetaTables All &ldquo;objects&rdquo; in lua are tables, and tables can something called a metatable added to them. Metatables can have special methods on them which run under certain circumstances (called metamethods), such as keys being added."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/12/05/encapsulation-in-warcraft-addons-inheritance/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ea821116adbd94ff8c04bf7745204429750a1079f16951db0415b837fc273249.css integrity="sha256-6oIRFq29lP+MBL93RSBEKXUKEHnxaVHbBBW4N/wnMkk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Encapsulation in Warcraft Addons - Inheritance"><meta property="og:description" content="Using Inheritance (sort of) When we actually need inheritance, things get a little more complicated. We need to use two of lua&rsquo;s slightly harder features to get it to work: metatables and colon notation. A little background on these will help:
MetaTables All &ldquo;objects&rdquo; in lua are tables, and tables can something called a metatable added to them. Metatables can have special methods on them which run under certain circumstances (called metamethods), such as keys being added."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/12/05/encapsulation-in-warcraft-addons-inheritance/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-12-05T00:00:00+00:00"><meta property="article:modified_time" content="2014-12-05T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Encapsulation in Warcraft Addons - Inheritance"><meta name=twitter:description content="Using Inheritance (sort of) When we actually need inheritance, things get a little more complicated. We need to use two of lua&rsquo;s slightly harder features to get it to work: metatables and colon notation. A little background on these will help:
MetaTables All &ldquo;objects&rdquo; in lua are tables, and tables can something called a metatable added to them. Metatables can have special methods on them which run under certain circumstances (called metamethods), such as keys being added."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Encapsulation in Warcraft Addons - Inheritance","item":"https://andydote.co.uk/2014/12/05/encapsulation-in-warcraft-addons-inheritance/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Encapsulation in Warcraft Addons - Inheritance","name":"Encapsulation in Warcraft Addons - Inheritance","description":"Using Inheritance (sort of) When we actually need inheritance, things get a little more complicated. We need to use two of lua\u0026rsquo;s slightly harder features to get it to work: metatables and colon notation. A little background on these will help:\nMetaTables All \u0026ldquo;objects\u0026rdquo; in lua are tables, and tables can something called a metatable added to them. Metatables can have special methods on them which run under certain circumstances (called metamethods), such as keys being added.","keywords":["design","lua","warcraft"],"articleBody":"Using Inheritance (sort of) When we actually need inheritance, things get a little more complicated. We need to use two of lua’s slightly harder features to get it to work: metatables and colon notation. A little background on these will help:\nMetaTables All “objects” in lua are tables, and tables can something called a metatable added to them. Metatables can have special methods on them which run under certain circumstances (called metamethods), such as keys being added. A full list of metamethods is available here.\nThe metamethod we are interested in is called called __index, which gets triggered when a key is not found in the table.\nThere are two ways of using __index. The first is to assign it a function, which gets passed two arguments: table, and key. This is useful if you want to provide a default value if a key in a table isn’t found, which I use in the spellData example in the previous post.\nThe other way of using __index is to pass it another table of methods to call, like in this example:\nlocal meta = { print = function() print(\"Hi from the metatable\") end } local actual = { test = function() print(\"testing\") end } --wont work: -- actual.print() setmetatable(actual, { __index = meta }) -- now it will! -- actual.print() By calling setmetatable on actual, we provide actual with all the methods on meta. A table can only have one meta table though, and you might break things by overwriting it (example, don’t call setmetatable on a Frame or ActionButton…)\nColon Notation All methods on a table can be called in two ways; with a colon, or with a period. The colon can be thought of as “fill in the first parameter with the table this is being called on”. For example, these two statements are equivalent:\nlocal x = string.gsub(\"hello world\", \"hello\", \"bye\") local x = \"hello world\":gsub(\"hello\", \"bye\") In the example above, the signature of gsub is something like this:\nlocal string = { gsub = function(self, searchTerm, replacement) --self is the input string end, } The convention used is to call the first parameter self. We can now use this colon notation with metatables to make our version of inheritance.\nCombining local base = { increase = function(self) self.count = self.count + 1 end, print = function(self) print(\"The count is \" .. self.count .. \".\") end } local first = { count = 0 } setmetatable(first, { __index = base }) local second = { count = 100 } setmetatable(second, { __index = base }) --usage first:increase() second:increase() first:print()\t-- prints 1 first:print()\t-- prints 101 Due to the way the colon operator works, the self parameter is filled in with the table calling the method, not the table the method is defined on. So calling first:increase() is the same as base.increase(first)\nUsage We can now take these elements, and craft a set of classes designed for reuse. We start off with our root object (think System.Object if you are from a .net world.)\nlocal class = { extend = function(self, this) return setmetatable(this, { __index = self }) end, new = function(self, ...) local this = setmetatable({}, { __index = self }) this:ctor(...) return this end, ctor = function(self, ...) end, } We have two methods here, extend and new. The new method is nice and straight forward - it creates a new table, assigns the meta to be class and calls the ctor method (which is the one you would want to replace in sub classes).\nThe extend method takes in a new table, and applies and sets the meta to class. This is what is used to inherit and add new functionality.\nFor example, in my control library, I have a base class with some common methods:\nlocal control = class:extend({ size = function(self, config) self.frame:SetSize(unpack(config)) end, point = function(self, config) self.frame:SetPoint(unpack(config)) end, parent = function(self, value) self.frame:SetParent(value) end, }) And then many other classes which extend the base, cilling in the ctor method with how to actually create the frame:\nlocal label = control:extend({ ctor = function(self, name, parent) self.frame = CreateFrame(\"Frame\", name, parent) self.label = self.frame:CreateFontString() self.label:SetAllPoints(self.frame) self.label:SetFont(fonts.normal, 12) end, }) local textbox = control:extend({ ctor = function(self, name, parent) self.frame = CreateFrame(\"editbox\", name, parent, \"InputBoxTemplate\") self.frame:SetAutoFocus(false) self.frame:SetFont(fonts.normal, 12) end, text = function(self, value) self.frame:SetText(value) end, }) Some classes, such as the textbox provide other methods where they make sense.\nCalling Base Class Methods If we wish to start overriding a method and then call the original method within, things start to get a lot more complicated.\nlocal class = { extend = function(self, this) this.base = self return setmetatable(this, { __index = self }) end, } local child = class:extend({ method = function(self) self.name = \"child\" end, }) local grandchild = child:extend({ method = function(self) self.base:method() end }) While this looks like it will work, it will cause some strange and hard to debug problems (I know it will, it took me ages to figure out.)\nThe problem is that when you do self.base:method() you are effectively doing self.base.method(self.base), which means the base method is referencing the wrong table!\nWe can solve this, but it requires a certain level of voodoo. First we need to change our extend method:\nextend = function(self, this) this.super = function(child) local parent = { __index = function(_, methodName) return function(_, ...) self[methodName](child, ...) end end } return setmetatable({}, parent) end return setmetatable(this, { __index = self }) end This took me far too long to come up with and get working. Essentially what it does is take all calls, and replace the self parameter with the correct table.\nThis method has some restrictions, in that you can only go ‘up’ one level in the class hierarchy, e.g. you cannot do item:super():super():super(). In practice though, I have never needed to do this.\nThe entirety of my class file can be found on my github.\nProblems There are two disadvantages to this method of creating objects. The first is using a table like this, you can no longer totally hide variables as you could do in the closure version. The other is the complexity added - especially if you wish to allow base method calling, however in balance, you only need to write the super() functionality once (or use mine!)\nWhen writing addons, I use both methods of encapsulation where they fit best - as like everything else in development the answer to what to use is “it depends”.\n","wordCount":"1081","inLanguage":"en","datePublished":"2014-12-05T00:00:00Z","dateModified":"2014-12-05T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/12/05/encapsulation-in-warcraft-addons-inheritance/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Encapsulation in Warcraft Addons - Inheritance</h1><div class=post-meta><span title='2014-12-05 00:00:00 +0000 UTC'>December 5, 2014</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><h2 id=using-inheritance-sort-of>Using Inheritance (sort of)<a hidden class=anchor aria-hidden=true href=#using-inheritance-sort-of>#</a></h2><p>When we actually need inheritance, things get a little more complicated. We need to use two of lua&rsquo;s slightly harder features to get it to work: <code>metatables</code> and <code>colon notation</code>. A little background on these will help:</p><h3 id=metatables>MetaTables<a hidden class=anchor aria-hidden=true href=#metatables>#</a></h3><p>All &ldquo;objects&rdquo; in lua are tables, and tables can something called a metatable added to them. Metatables can have special methods on them which run under certain circumstances (called metamethods), such as keys being added. A full list of metamethods is <a href=http://lua-users.org/wiki/MetatableEvents>available here</a>.</p><p>The metamethod we are interested in is called called <code>__index</code>, which gets triggered when a key is not found in the table.</p><p>There are two ways of using <code>__index</code>. The first is to assign it a function, which gets passed two arguments: <code>table</code>, and <code>key</code>. This is useful if you want to provide a default value if a key in a table isn&rsquo;t found, which I use in the <code>spellData</code> example <a href=http://andydote.co.uk/2014/11/28/encapsulation-in-warcraft-addons-closures.html>in the previous post</a>.</p><p>The other way of using <code>__index</code> is to pass it another table of methods to call, like in this example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> meta <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	print <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>()
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;Hi from the metatable&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> actual <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	test <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>()
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;testing&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>--wont work:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- actual.print()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setmetatable(actual, { __index <span style=color:#f92672>=</span> meta })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- now it will!</span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- actual.print()</span>
</span></span></code></pre></div><p>By calling <code>setmetatable</code> on <code>actual</code>, we provide <code>actual</code> with all the methods on <code>meta</code>. A table can only have one meta table though, and you might break things by overwriting it (example, don&rsquo;t call <code>setmetatable</code> on a Frame or ActionButton&mldr;)</p><h3 id=colon-notation>Colon Notation<a hidden class=anchor aria-hidden=true href=#colon-notation>#</a></h3><p>All methods on a table can be called in two ways; with a colon, or with a period. The colon can be thought of as &ldquo;fill in the first parameter with the table this is being called on&rdquo;. For example, these two statements are equivalent:</p><pre tabindex=0><code class=language-lua%} data-lang=lua%}>local x = string.gsub(&#34;hello world&#34;, &#34;hello&#34;, &#34;bye&#34;)
local x = &#34;hello world&#34;:gsub(&#34;hello&#34;, &#34;bye&#34;)
</code></pre><p>In the example above, the signature of <code>gsub</code> is something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> string <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	gsub <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, searchTerm, replacement)
</span></span><span style=display:flex><span>		<span style=color:#75715e>--self is the input string</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The convention used is to call the first parameter <code>self</code>. We can now use this colon notation with metatables to make our version of inheritance.</p><h3 id=combining>Combining<a hidden class=anchor aria-hidden=true href=#combining>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> base <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	increase <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self)
</span></span><span style=display:flex><span>		self.count <span style=color:#f92672>=</span> self.count <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>	print <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self)
</span></span><span style=display:flex><span>		print(<span style=color:#e6db74>&#34;The count is &#34;</span> <span style=color:#f92672>..</span> self.count <span style=color:#f92672>..</span> <span style=color:#e6db74>&#34;.&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> first <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>setmetatable(first, { __index <span style=color:#f92672>=</span> base })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> second <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	count <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>setmetatable(second, { __index <span style=color:#f92672>=</span> base })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>--usage</span>
</span></span><span style=display:flex><span>first:increase()
</span></span><span style=display:flex><span>second:increase()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>first:print()		<span style=color:#75715e>-- prints 1</span>
</span></span><span style=display:flex><span>first:print()		<span style=color:#75715e>-- prints 101</span>
</span></span></code></pre></div><p>Due to the way the colon operator works, the <code>self</code> parameter is filled in with the table calling the method, not the table the method is defined on. So calling <code>first:increase()</code> is the same as <code>base.increase(first)</code></p><h2 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h2><p>We can now take these elements, and craft a set of classes designed for reuse. We start off with our root object (think <code>System.Object</code> if you are from a .net world.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> class <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	extend <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, this)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> setmetatable(this, { __index <span style=color:#f92672>=</span> self })
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	new <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, ...)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>local</span> this <span style=color:#f92672>=</span> setmetatable({}, { __index <span style=color:#f92672>=</span> self })
</span></span><span style=display:flex><span>		this:ctor(...)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> this
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ctor <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, ...)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We have two methods here, <code>extend</code> and <code>new</code>. The <code>new</code> method is nice and straight forward - it creates a new table, assigns the meta to be <code>class</code> and calls the <code>ctor</code> method (which is the one you would want to replace in sub classes).</p><p>The <code>extend</code> method takes in a new table, and applies and sets the meta to <code>class</code>. This is what is used to inherit and add new functionality.</p><p>For example, in my control library, I have a base class with some common methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> control <span style=color:#f92672>=</span> class:extend({
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	size <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, config)
</span></span><span style=display:flex><span>		self.frame:SetSize(unpack(config))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	point <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, config)
</span></span><span style=display:flex><span>		self.frame:SetPoint(unpack(config))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	parent <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, value)
</span></span><span style=display:flex><span>		self.frame:SetParent(value)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>And then many other classes which extend the base, cilling in the <code>ctor</code> method with how to actually create the frame:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> label <span style=color:#f92672>=</span> control:extend({
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ctor <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, name, parent)
</span></span><span style=display:flex><span>		self.frame <span style=color:#f92672>=</span> CreateFrame(<span style=color:#e6db74>&#34;Frame&#34;</span>, name, parent)
</span></span><span style=display:flex><span>		self.label <span style=color:#f92672>=</span> self.frame:CreateFontString()
</span></span><span style=display:flex><span>		self.label:SetAllPoints(self.frame)
</span></span><span style=display:flex><span>		self.label:SetFont(fonts.normal, <span style=color:#ae81ff>12</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> textbox  <span style=color:#f92672>=</span> control:extend({
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ctor <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, name, parent)
</span></span><span style=display:flex><span>		self.frame <span style=color:#f92672>=</span> CreateFrame(<span style=color:#e6db74>&#34;editbox&#34;</span>, name, parent, <span style=color:#e6db74>&#34;InputBoxTemplate&#34;</span>)
</span></span><span style=display:flex><span>		self.frame:SetAutoFocus(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>		self.frame:SetFont(fonts.normal, <span style=color:#ae81ff>12</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	text <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, value)
</span></span><span style=display:flex><span>		self.frame:SetText(value)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Some classes, such as the textbox provide other methods where they make sense.</p><h3 id=calling-base-class-methods>Calling Base Class Methods<a hidden class=anchor aria-hidden=true href=#calling-base-class-methods>#</a></h3><p>If we wish to start overriding a method and then call the original method within, things start to get a lot more complicated.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span><span style=color:#66d9ef>local</span> class <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>	extend <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, this)
</span></span><span style=display:flex><span>		this.base <span style=color:#f92672>=</span> self
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> setmetatable(this, { __index <span style=color:#f92672>=</span> self })
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> child <span style=color:#f92672>=</span> class:extend({
</span></span><span style=display:flex><span>	method <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self)
</span></span><span style=display:flex><span>		self.name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;child&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>,
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>local</span> grandchild <span style=color:#f92672>=</span> child:extend({
</span></span><span style=display:flex><span>	method <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self)
</span></span><span style=display:flex><span>		self.base:method()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>While this looks like it will work, it will cause some strange and hard to debug problems (I know it will, it took me ages to figure out.)</p><p>The problem is that when you do <code>self.base:method()</code> you are effectively doing <code>self.base.method(self.base)</code>, which means the base method is referencing the wrong table!</p><p>We can solve this, but it requires a certain level of voodoo. First we need to change our <code>extend</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-lua data-lang=lua><span style=display:flex><span>extend <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(self, this)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	this.super <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(child)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>local</span> parent <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>			__index <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(_, methodName)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>(_, ...)
</span></span><span style=display:flex><span>					self[methodName](child, ...)
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> setmetatable({}, parent)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> setmetatable(this, { __index <span style=color:#f92672>=</span> self })
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p>This took me far too long to come up with and get working. Essentially what it does is take all calls, and replace the <code>self</code> parameter with the correct table.</p><p>This method has some restrictions, in that you can only go &lsquo;up&rsquo; one level in the class hierarchy, e.g. you cannot do <code>item:super():super():super()</code>. In practice though, I have never needed to do this.</p><p>The entirety of my class file can be found on <a href=https://github.com/Pondidum/Dark/blob/abcaa319ccce1bb448a1e04f1d82b8d24578acbe/class.lua>my github</a>.</p><h3 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h3><p>There are two disadvantages to this method of creating objects. The first is using a table like this, you can no longer totally hide variables as you could do in the closure version. The other is the complexity added - especially if you wish to allow base method calling, however in balance, you only need to write the <code>super()</code> functionality once (or use mine!)</p><p>When writing addons, I use both methods of encapsulation where they fit best - as like everything else in development the answer to what to use is &ldquo;it depends&rdquo;.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/lua/>lua</a></li><li><a href=https://andydote.co.uk/tags/warcraft/>warcraft</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2015/03/25/communicating-intent-in-apis/><span class=title>« Prev Page</span><br><span>Communicating Intent in APIs</span></a>
<a class=next href=https://andydote.co.uk/2014/11/28/encapsulation-in-warcraft-addons-closures/><span class=title>Next Page »</span><br><span>Encapsulation in Warcraft Addons - Closures</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>