<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles - SRP | Andy Dote</title><meta name=keywords content="design,c#,solid"><meta name=description content="Single Responsibility Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
SRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don&rsquo;t see the use in their particular case.
A particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/02/18/solid-principles-srp/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Principles - SRP"><meta property="og:description" content="Single Responsibility Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
SRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don&rsquo;t see the use in their particular case.
A particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/02/18/solid-principles-srp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles - SRP"><meta name=twitter:description content="Single Responsibility Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
SRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don&rsquo;t see the use in their particular case.
A particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"SOLID Principles - SRP","item":"https://andydote.co.uk/2014/02/18/solid-principles-srp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles - SRP","name":"SOLID Principles - SRP","description":"Single Responsibility Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nSRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don\u0026rsquo;t see the use in their particular case.\nA particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses.","keywords":["design","c#","solid"],"articleBody":"Single Responsibility Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nSRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don’t see the use in their particular case.\nA particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses. A slightly contrived example is this:\npublic class JobPostingService { private static readonly TimeSpan Timeout = new TimeSpan(0, 10, 0); private readonly JobWebService _jobService; private List _jobs; private DateTime _lastLoaded; public JobPostingService() { _jobService = new JobWebService(); _lastLoaded = DateTime.MinValue; } public IEnumerable GetCurrentJobs() { if (_lastLoaded - DateTime.Now \u003e Timeout) { _jobs = _jobService.GetLiveJobs().ToList(); _lastLoaded = DateTime.Now; } return _jobs; } public void PostToFreeBoards(Job job) { var jobs = GetCurrentJobs(); if (jobs.Any(j =\u003e j.ID == job.ID)) return; _jobService.Post(job, Boards.FreeBoard1 | Boards.FreeBoard2); } public void PostToAllBoards(Job job) { var jobs = GetCurrentJobs(); if (jobs.Any(j =\u003e j.ID == job.ID)) return; _jobService.Post(job, Boards.PaidBoard1 | Boards.PaidBoard2); } } This class is fairly small, but it is already showing the symptoms of doing too many things; it is dealing with caching, as well as posting jobs. While this is not a major problem at the moment, it is also easier to nip the problem in the bud - before a load of new requirements/changes arrive and complicate things.\nThe Solution We start off by changing our class to take it’s dependencies in via constructor parameters (Dependency Injection, the ‘D’ in SOLID):\npublic JobPostingService(JobWebService jobService) { _jobService = jobService; _lastLoaded = DateTime.MinValue; } So the usage of the JobPostingService goes from this:\nvar poster = new JobPostingService(); To this:\nvar poster = new JobPostingService(new JobWebService()); Next, we take the JobWebService class and extract \u0026 implement an interface of it’s methods:\npublic interface IJobService { IEnumerable GetLiveJobs(); bool Post(Job job, Boards boards); } public class JobWebService : IJobService { //... } And finally, create a new class which only deals with caching the results of a JobService, by wrapping calls to another instance:\npublic class CachedJobService : IJobService { private List _jobs; private DateTime _lastLoaded; private readonly TimeSpan _timeout; private readonly IJobService _other; public CachedJobService(IJobService otherService) : this(otherService, new TimeSpan(0, 10, 0)) { } public CachedJobService(IJobService otherService, TimeSpan timeout) { _other = otherService; _timeout = timeout; _lastLoaded = DateTime.MinValue; } public IEnumerable GetLiveJobs() { if (_lastLoaded - DateTime.Now \u003e _timeout) { _jobs = _other.GetLiveJobs().ToList(); _lastLoaded = DateTime.Now; } return _jobs; } public bool Post(Job job, Boards boards) { return _other.Post(job, boards); } } This class passes all Post() calls to the other implementation, but caches the results of calls to GetLiveJobs(), and we have added a time-out as an optional constructor parameter. This wrapping calls to another implementation is called The Decorator Pattern.\nAs the JobPostingService class no longer has to cache the results of calls to JobService itself, we can delete all the caching related code:\npublic class JobPostingService { private readonly IJobService _jobService; public JobPostingService(IJobService jobService) { _jobService = jobService; } public IEnumerable GetCurrentJobs() { return _jobService.GetLiveJobs(); } public void PostToFreeBoards(Job job) { var jobs = GetCurrentJobs(); if (jobs.Any(j =\u003e j.ID == job.ID)) return; _jobService.Post(job, Boards.FreeBoard1 | Boards.FreeBoard2); } public void PostToAllBoards(Job job) { var jobs = GetCurrentJobs(); if (jobs.Any(j =\u003e j.ID == job.ID)) return; _jobService.Post(job, Boards.PaidBoard1 | Boards.PaidBoard2); } } And our usage changes again, from this:\nvar poster = new JobPostingService(new JobWebService()); To this:\nvar webService = new CachedJobService(new JobWebService()); var poster = new JobPostingService(webService); We have now successfully extracted all the various pieces of functionality into separate classes, which has gained us the ability to test individual features (caching can be tested with a fake IJobService and checked to see when calls go through to the service), and the ability to adapt more easily to new requirements. Talking of which…\nNew Requirement: The third party webservice is not always available, allow use of a fallback webservice.\nNow you could go and modify the JobPostingService class to have a second webservice parameter:\nvar primaryService = new CachedJobService(new JobWebService()); var secondaryService = new CachedJobService(new BackupWebService()); var poster = new JobPostingService(primaryService, secondaryService); But what happens when a third service is added? and a fourth? Surely there is another way?\nAs luck would have it, we can use the IJobService interface to create a single class which handles all the logic for switching between the two services:\npublic class FailoverJobService : IJobService { private readonly List _services; public FailoverJobService(params IJobService[] services) { _services = services.ToList(); } public IEnumerable GetLiveJobs() { return _services.SelectMany(s =\u003e s.GetLiveJobs()); } public bool Post(Job job, Boards boards) { return _services.Any(service =\u003e service.Post(job, boards)); } } This class takes in a number of IJobServices and will try each one in turn to post jobs, and when listing jobs, gets the results from all services. In the same manner as the CachedJobService, we have a single class which can easily be tested without effecting any of the other functionality.\nThe really interesting point comes when we decide when to use caching? do you cache each service passed to the FailoverJobService:\nvar primaryService = new CachedJobService(new JobWebService()); var secondaryService = new CachedJobService(new BackupWebService()); var failover = new FailoverJobService(primaryService, secondaryService); var poster = new JobPostingService(failover); Or do you cache the FailoverJobService itself:\nvar primaryService = new JobWebService(); var secondaryService = new BackupWebService(); var failover = new CachedJobService(new FailoverJobService(primaryService, secondaryService)); var poster = new JobPostingService(failover); Or both?\nHopefully this article has explained 1/5th (maybe a little more, we did do Dependency Injection after all!) of the SOLID principles, and how it can be useful to keep your code as small and modular as possible.\nAll source code is available on my Github: Solid.Demo Source Code\n","wordCount":"969","inLanguage":"en","datePublished":"2014-02-18T00:00:00Z","dateModified":"2014-02-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/02/18/solid-principles-srp/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles - SRP</h1><div class=post-meta><span title='2014-02-18 00:00:00 +0000 UTC'>February 18, 2014</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><h2 id=single-responsibility-principle>Single Responsibility Principle<a hidden class=anchor aria-hidden=true href=#single-responsibility-principle>#</a></h2><p><a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility</a> | <a href=http://andydote.co.uk/solid-principles-ocp>Open Closed</a> | <a href=http://andydote.co.uk/solid-principles-lsp>Liskov Substitution</a> | <a href=http://andydote.co.uk/solid-principles-isp>Interface Segregation</a> | <a href=http://andydote.co.uk/solid-principles-dip>Dependency Inversion</a></p><p>SRP (Single Responsibility Principle) is something I hear a lot of developers agree is a good thing, but when I read their code, they violate it without realising, or don&rsquo;t see the use in their particular case.</p><p>A particularly prominent example I find in our code bases is Permissioning and Caching. These two requirements can often slip into classes slowly - especially if requirements are not clear, or change as the task progresses. A slightly contrived example is this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobPostingService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> TimeSpan Timeout = <span style=color:#66d9ef>new</span> TimeSpan(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> JobWebService _jobService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> List&lt;Job&gt; _jobs;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> DateTime _lastLoaded;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> JobPostingService()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_jobService = <span style=color:#66d9ef>new</span> JobWebService();
</span></span><span style=display:flex><span>		_lastLoaded = DateTime.MinValue;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IEnumerable&lt;Job&gt; GetCurrentJobs()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (_lastLoaded - DateTime.Now &gt; Timeout)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			_jobs = _jobService.GetLiveJobs().ToList();
</span></span><span style=display:flex><span>			_lastLoaded = DateTime.Now;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _jobs;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PostToFreeBoards(Job job)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> jobs = GetCurrentJobs();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (jobs.Any(j =&gt; j.ID == job.ID))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_jobService.Post(job, Boards.FreeBoard1 | Boards.FreeBoard2);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PostToAllBoards(Job job)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> jobs = GetCurrentJobs();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (jobs.Any(j =&gt; j.ID == job.ID))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_jobService.Post(job, Boards.PaidBoard1 | Boards.PaidBoard2);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This class is fairly small, but it is already showing the symptoms of doing too many things; it is dealing with caching, as well as posting jobs. While this is not a major problem at the moment, it is also easier to nip the problem in the bud - before a load of new requirements/changes arrive and complicate things.</p><h2 id=the-solution>The Solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><p>We start off by changing our class to take it&rsquo;s dependencies in via constructor parameters (Dependency Injection, the &lsquo;D&rsquo; in SOLID):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> JobPostingService(JobWebService jobService)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	_jobService = jobService;
</span></span><span style=display:flex><span>	_lastLoaded = DateTime.MinValue;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>So the usage of the <code>JobPostingService</code> goes from this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService();
</span></span></code></pre></div><p>To this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService(<span style=color:#66d9ef>new</span> JobWebService());
</span></span></code></pre></div><p>Next, we take the <code>JobWebService</code> class and extract & implement an interface of it&rsquo;s methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IJobService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	IEnumerable&lt;Job&gt; GetLiveJobs();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>bool</span> Post(Job job, Boards boards);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobWebService</span> : IJobService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally, create a new class which only deals with caching the results of a JobService, by wrapping calls to another instance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CachedJobService</span> : IJobService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> List&lt;Job&gt; _jobs;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> DateTime _lastLoaded;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> TimeSpan _timeout;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IJobService _other;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> CachedJobService(IJobService otherService)
</span></span><span style=display:flex><span>		: <span style=color:#66d9ef>this</span>(otherService, <span style=color:#66d9ef>new</span> TimeSpan(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> CachedJobService(IJobService otherService, TimeSpan timeout)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_other = otherService;
</span></span><span style=display:flex><span>		_timeout = timeout;
</span></span><span style=display:flex><span>		_lastLoaded = DateTime.MinValue;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IEnumerable&lt;Job&gt; GetLiveJobs()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (_lastLoaded - DateTime.Now &gt; _timeout)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			_jobs = _other.GetLiveJobs().ToList();
</span></span><span style=display:flex><span>			_lastLoaded = DateTime.Now;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _jobs;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Post(Job job, Boards boards)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _other.Post(job, boards);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This class passes all <code>Post()</code> calls to the other implementation, but caches the results of calls to <code>GetLiveJobs()</code>, and we have added a time-out as an optional constructor parameter. This wrapping calls to another implementation is called <a href=http://en.wikipedia.org/wiki/Decorator_pattern>The Decorator Pattern</a>.</p><p>As the JobPostingService class no longer has to cache the results of calls to <code>JobService</code> itself, we can delete all the caching related code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>JobPostingService</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IJobService _jobService;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> JobPostingService(IJobService jobService)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_jobService = jobService;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IEnumerable&lt;Job&gt; GetCurrentJobs()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _jobService.GetLiveJobs();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PostToFreeBoards(Job job)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> jobs = GetCurrentJobs();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (jobs.Any(j =&gt; j.ID == job.ID))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_jobService.Post(job, Boards.FreeBoard1 | Boards.FreeBoard2);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> PostToAllBoards(Job job)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> jobs = GetCurrentJobs();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (jobs.Any(j =&gt; j.ID == job.ID))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_jobService.Post(job, Boards.PaidBoard1 | Boards.PaidBoard2);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And our usage changes again, from this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService(<span style=color:#66d9ef>new</span> JobWebService());
</span></span></code></pre></div><p>To this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> webService = <span style=color:#66d9ef>new</span> CachedJobService(<span style=color:#66d9ef>new</span> JobWebService());
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService(webService);
</span></span></code></pre></div><p>We have now successfully extracted all the various pieces of functionality into separate classes, which has gained us the ability to test individual features (caching can be tested with a fake <code>IJobService</code> and checked to see when calls go through to the service), and the ability to adapt more easily to new requirements. Talking of which&mldr;</p><blockquote><p>New Requirement: The third party webservice is not always available, allow use of a fallback webservice.</p></blockquote><p>Now you could go and modify the <code>JobPostingService</code> class to have a second webservice parameter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> primaryService = <span style=color:#66d9ef>new</span> CachedJobService(<span style=color:#66d9ef>new</span> JobWebService());
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> secondaryService = <span style=color:#66d9ef>new</span> CachedJobService(<span style=color:#66d9ef>new</span> BackupWebService());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService(primaryService, secondaryService);
</span></span></code></pre></div><p>But what happens when a third service is added? and a fourth? Surely there is another way?</p><p>As luck would have it, we can use the <code>IJobService</code> interface to create a single class which handles all the logic for switching between the two services:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FailoverJobService</span> : IJobService
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;IJobService&gt; _services;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> FailoverJobService(<span style=color:#66d9ef>params</span> IJobService[] services)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_services = services.ToList();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IEnumerable&lt;Job&gt; GetLiveJobs()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _services.SelectMany(s =&gt; s.GetLiveJobs());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Post(Job job, Boards boards)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _services.Any(service =&gt; service.Post(job, boards));
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This class takes in a number of <code>IJobService</code>s and will try each one in turn to post jobs, and when listing jobs, gets the results from all services. In the same manner as the <code>CachedJobService</code>, we have a single class which can easily be tested without effecting any of the other functionality.</p><p>The really interesting point comes when we decide when to use caching? do you cache each service passed to the <code>FailoverJobService</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> primaryService = <span style=color:#66d9ef>new</span> CachedJobService(<span style=color:#66d9ef>new</span> JobWebService());
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> secondaryService = <span style=color:#66d9ef>new</span> CachedJobService(<span style=color:#66d9ef>new</span> BackupWebService());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> failover = <span style=color:#66d9ef>new</span> FailoverJobService(primaryService, secondaryService);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService(failover);
</span></span></code></pre></div><p>Or do you cache the <code>FailoverJobService</code> itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> primaryService = <span style=color:#66d9ef>new</span> JobWebService();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> secondaryService = <span style=color:#66d9ef>new</span> BackupWebService();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> failover = <span style=color:#66d9ef>new</span> CachedJobService(<span style=color:#66d9ef>new</span> FailoverJobService(primaryService, secondaryService));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> poster = <span style=color:#66d9ef>new</span> JobPostingService(failover);
</span></span></code></pre></div><p>Or both?</p><p>Hopefully this article has explained 1/5th (maybe a little more, we did do Dependency Injection after all!) of the SOLID principles, and how it can be useful to keep your code as small and modular as possible.</p><p>All source code is available on my Github: <a href=https://github.com/Pondidum/Solid.Demo>Solid.Demo Source Code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/solid/>solid</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/02/19/solid-principles-ocp/><span class=title>« Prev Page</span><br><span>SOLID Principles - OCP</span></a>
<a class=next href=https://andydote.co.uk/2014/02/02/specialising-a-general-application/><span class=title>Next Page »</span><br><span>Specialising a General Application</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>