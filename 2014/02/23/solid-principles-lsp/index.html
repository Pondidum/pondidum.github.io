<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles - LSP | Andy Dote</title>
<meta name=keywords content="design,c#,solid"><meta name=description content="Liskov Substitution Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Liskov Substitution Principle is states:
If S is a sub-type of T, then objects of type T maybe replaced with objects of type S
At face value, it means that a small class hierarchy like this:
public class FileEntry { } public class DbFileEntry : FileEntry { } And a method which takes in a FileEntry, can be called like this:"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/02/23/solid-principles-lsp/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Principles - LSP"><meta property="og:description" content="Liskov Substitution Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Liskov Substitution Principle is states:
If S is a sub-type of T, then objects of type T maybe replaced with objects of type S
At face value, it means that a small class hierarchy like this:
public class FileEntry { } public class DbFileEntry : FileEntry { } And a method which takes in a FileEntry, can be called like this:"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/02/23/solid-principles-lsp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-02-23T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles - LSP"><meta name=twitter:description content="Liskov Substitution Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Liskov Substitution Principle is states:
If S is a sub-type of T, then objects of type T maybe replaced with objects of type S
At face value, it means that a small class hierarchy like this:
public class FileEntry { } public class DbFileEntry : FileEntry { } And a method which takes in a FileEntry, can be called like this:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"SOLID Principles - LSP","item":"https://andydote.co.uk/2014/02/23/solid-principles-lsp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles - LSP","name":"SOLID Principles - LSP","description":"Liskov Substitution Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Liskov Substitution Principle is states:\nIf S is a sub-type of T, then objects of type T maybe replaced with objects of type S\nAt face value, it means that a small class hierarchy like this:\npublic class FileEntry { } public class DbFileEntry : FileEntry { } And a method which takes in a FileEntry, can be called like this:","keywords":["design","c#","solid"],"articleBody":"Liskov Substitution Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Liskov Substitution Principle is states:\nIf S is a sub-type of T, then objects of type T maybe replaced with objects of type S\nAt face value, it means that a small class hierarchy like this:\npublic class FileEntry { } public class DbFileEntry : FileEntry { } And a method which takes in a FileEntry, can be called like this:\nProcessFile(new FileEntry()); Or like this:\nProcessFile(new DbFileEntry()); This however only takes the principle at face value, and would not provide much value. However, just because a class implements the expected interface does not necessarily mean that it can be a drop in replacement for another implementation. This can be down to a number of factors, such as side effects of methods (like different kinds of exception being thrown), and external modification of state.\nSide Effects In this example, you can see that the methods both have a pre-condition on some internal data, but as they throw different kinds of exceptions, they violate the principle:\npublic class FileEntry { public virtual void Process() { if (File.Exists(Path) == false) throw new FileNotFoundException(Path); //do work } } public class DbFileEntry : FileEntry { public override void Process() { if (Database.Contains(_id) == false) throw new KeyNotFoundException(_id.ToString()); //do work } } The reason for this being a violation is due to what the calling code is expecting to handle:\npublic void RunFiles(IEnumerable files) { foreach (var file in files) { try { file.Process(); } catch (FileNotFoundException ex) { _fails.Add(file.Name); } } } This method when called with a list of FileEntry will run every entry, and add the names of any which failed to a collection for later use. However if it were called with a list of DbFileEntry, the first file to fail would cause then entire method to fail, and no more files would be processed.\nFixing the classes so they obey the LSP could be done by changing the DbFileEntry to throw the same kind of exception as the FileEntry, but the exception type FileNotFoundException wouldn’t make sense in the context of a database.\nThe solution is to create a new exception type which the Process methods with throw, and that the RunFiles method will catch:\npublic class FileEntry { public virtual void Process() { if (File.Exists(Path) == false) throw new FileEntryProcessException(FileNotFoundException(Path)); //do work } } public class DbFileEntry : FileEntry { public override void Process() { if (_database.Contains(_id) == false) throw new FileEntryProcessException(KeyNotFoundException(_id)); //do work } } public void RunFiles(IEnumerable files) { foreach ( var file in files) { try { file.Process(); } catch (FileEntryProcessException ex) { _fails.Add(file.Name); } } } By keeping the original exceptions we were going to throw as the .InnerException property of our new FileEntryProcessException we can still preserve the more specific exceptions, while allowing the RunFiles method to catch it.\nAn alternate solution to this would be to have two new specific exception types, which both inherit a single type:\npublic abstract class ProcessException : Exception() { } public class FileNotFoundProcessException : ProcessException { public FileNotFoundProcessException(String path) {} } public class KeyNotFoundProcessException : ProcessException { public KeyNotFoundProcessException(Guid id) {} } The problem with this approach is that you are hoping that all consumers of FileEntry are catching ProcessException, rather than one of it’s sub-classes. By using the first solution, you are forcing the consumer to catch your one exception type.\nState Mutation Extra methods on a sub class can cause a violation of the Liskov Substitution Principle too; by mutating state, and causing calling code to make un-expected transitions. Take this for example:\npublic class DefaultStateGenerator { private int _state; public int GetNextStateID(int currentState) { return Math.Min(++currentState, 3); } } public class StateMachine { public StateMachine(IStateGenerator generator) { _generator = generator; } public void Transition() { var newState = _generator.GetNextStateID(_currentState); switch (newState) { case 0: break; //do nothing case 1: break; //do nothing case 2: PayTheMan(); break; } _currentState = newState; } } Using the DefaultStateGenerator will cause the state machine to work as expected - it will transition through the states, calling PayTheMan one on state 2, and then just sticking at state 3 for subsequent calls. However, if you were to use the EvilStateGenerator things might be a bit different:\npublic class EvilStateGenerator : IStateGenerator { private bool _evil; public int GetNextStateID(int currentState) { return _evil ? 2 : Math.Min(++currentState, 3); } public void BeEvil() { _evil = true; } } This EvilStateGenerator works as usual, until a call to its BeEvil method gets called, at which point it will return state 2 every time, causing the PayTheMan method to be called on every Transition.\nHopefully these two examples provide sufficient reason for paying attention to the Liskov Substitution Principle.\nAll source code is available on my Github: Solid.Demo Source Code\n","wordCount":"806","inLanguage":"en","datePublished":"2014-02-23T00:00:00Z","dateModified":"2014-02-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/02/23/solid-principles-lsp/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles - LSP</h1><div class=post-meta>&lt;span title='2014-02-23 00:00:00 +0000 UTC'>February 23, 2014&lt;/span>&amp;nbsp;·&amp;nbsp;4 min</div></header><div class=post-content><h2 id=liskov-substitution-principle>Liskov Substitution Principle<a hidden class=anchor aria-hidden=true href=#liskov-substitution-principle>#</a></h2><p><a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility</a> | <a href=http://andydote.co.uk/solid-principles-ocp>Open Closed</a> | <a href=http://andydote.co.uk/solid-principles-lsp>Liskov Substitution</a> | <a href=http://andydote.co.uk/solid-principles-isp>Interface Segregation</a> | <a href=http://andydote.co.uk/solid-principles-dip>Dependency Inversion</a></p><p>The Liskov Substitution Principle is states:</p><blockquote><p>If <strong>S</strong> is a sub-type of <strong>T</strong>, then objects of type <strong>T</strong> maybe replaced with objects of type <strong>S</strong></p></blockquote><p>At face value, it means that a small class hierarchy like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileEntry</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DbFileEntry</span> : FileEntry
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And a method which takes in a <code>FileEntry</code>, can be called like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>ProcessFile(<span style=color:#66d9ef>new</span> FileEntry());
</span></span></code></pre></div><p>Or like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>ProcessFile(<span style=color:#66d9ef>new</span> DbFileEntry());
</span></span></code></pre></div><p>This however only takes the principle at face value, and would not provide much value. However, just because a class implements the expected interface does not necessarily mean that it can be a drop in replacement for another implementation. This can be down to a number of factors, such as side effects of methods (like different kinds of exception being thrown), and external modification of state.</p><h3 id=side-effects>Side Effects<a hidden class=anchor aria-hidden=true href=#side-effects>#</a></h3><p>In this example, you can see that the methods both have a pre-condition on some internal data, but as they throw different kinds of exceptions, they violate the principle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileEntry</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Process()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (File.Exists(Path) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FileNotFoundException(Path);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//do work</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DbFileEntry</span> : FileEntry
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Process()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (Database.Contains(_id) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> KeyNotFoundException(_id.ToString());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//do work</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The reason for this being a violation is due to what the calling code is expecting to handle:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RunFiles(IEnumerable&lt;FileEntry&gt; files)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> file <span style=color:#66d9ef>in</span> files)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			file.Process();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>catch</span> (FileNotFoundException ex)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			_fails.Add(file.Name);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This method when called with a list of <code>FileEntry</code> will run every entry, and add the names of any which failed to a collection for later use. However if it were called with a list of <code>DbFileEntry</code>, the first file to fail would cause then entire method to fail, and no more files would be processed.</p><p>Fixing the classes so they obey the LSP could be done by changing the <code>DbFileEntry</code> to throw the same kind of exception as the <code>FileEntry</code>, but the exception type <code>FileNotFoundException</code> wouldn&rsquo;t make sense in the context of a database.</p><p>The solution is to create a new exception type which the <code>Process</code> methods with throw, and that the <code>RunFiles</code> method will catch:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileEntry</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Process()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (File.Exists(Path) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FileEntryProcessException(FileNotFoundException(Path));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//do work</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DbFileEntry</span> : FileEntry
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Process()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (_database.Contains(_id) == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> FileEntryProcessException(KeyNotFoundException(_id));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>//do work</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RunFiles(IEnumerable&lt;FileEntry&gt; files)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>foreach</span> ( <span style=color:#66d9ef>var</span> file <span style=color:#66d9ef>in</span> files)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			file.Process();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>catch</span> (FileEntryProcessException ex)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			_fails.Add(file.Name);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By keeping the original exceptions we were going to throw as the <code>.InnerException</code> property of our new <code>FileEntryProcessException</code> we can still preserve the more specific exceptions, while allowing the <code>RunFiles</code> method to catch it.</p><p>An alternate solution to this would be to have two new specific exception types, which both inherit a single type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ProcessException</span> : Exception()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FileNotFoundProcessException</span> : ProcessException
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> FileNotFoundProcessException(String path)
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyNotFoundProcessException</span> : ProcessException
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> KeyNotFoundProcessException(Guid id)
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The problem with this approach is that you are hoping that all consumers of <code>FileEntry</code> are catching <code>ProcessException</code>, rather than one of it&rsquo;s sub-classes. By using the first solution, you are forcing the consumer to catch your one exception type.</p><h3 id=state-mutation>State Mutation<a hidden class=anchor aria-hidden=true href=#state-mutation>#</a></h3><p>Extra methods on a sub class can cause a violation of the Liskov Substitution Principle too; by mutating state, and causing calling code to make un-expected transitions. Take this for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>DefaultStateGenerator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> _state;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> GetNextStateID(<span style=color:#66d9ef>int</span> currentState)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> Math.Min(++currentState, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StateMachine</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> StateMachine(IStateGenerator generator)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_generator = generator;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Transition()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> newState = _generator.GetNextStateID(_currentState);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (newState)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>; <span style=color:#75715e>//do nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>; <span style=color:#75715e>//do nothing</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>				PayTheMan();
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_currentState = newState;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using the <code>DefaultStateGenerator</code> will cause the state machine to work as expected - it will transition through the states, calling <code>PayTheMan</code> one on state 2, and then just sticking at state 3 for subsequent calls. However, if you were to use the <code>EvilStateGenerator</code> things might be a bit different:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EvilStateGenerator</span> : IStateGenerator
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> _evil;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> GetNextStateID(<span style=color:#66d9ef>int</span> currentState)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> _evil ? <span style=color:#ae81ff>2</span> : Math.Min(++currentState, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> BeEvil()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_evil = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This <code>EvilStateGenerator</code> works as usual, until a call to its <code>BeEvil</code> method gets called, at which point it will return state 2 every time, causing the <code>PayTheMan</code> method to be called on every <code>Transition</code>.</p><p>Hopefully these two examples provide sufficient reason for paying attention to the Liskov Substitution Principle.</p><p>All source code is available on my Github: <a href=https://github.com/Pondidum/Solid.Demo>Solid.Demo Source Code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/solid/>solid</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/03/01/solid-principles-isp/><span class=title>« Prev Page</span><br><span>SOLID Principles - ISP</span>
</a><a class=next href=https://andydote.co.uk/2014/02/19/solid-principles-ocp/><span class=title>Next Page »</span><br><span>SOLID Principles - OCP</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>