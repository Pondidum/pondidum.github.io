<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles - OCP | Andy Dote</title><meta name=keywords content="design,c#,solid"><meta name=description content="Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/02/19/solid-principles-ocp/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4ac25d88867f6882d86478d9b478a3d3efa1ed9e18f0bc5e432812301516cb28.css integrity="sha256-SsJdiIZ/aILYZHjZtHij0++h7Z4Y8LxeQygSMBUWyyg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Principles - OCP"><meta property="og:description" content="Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/02/19/solid-principles-ocp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-02-19T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles - OCP"><meta name=twitter:description content="Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"SOLID Principles - OCP","item":"https://andydote.co.uk/2014/02/19/solid-principles-ocp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles - OCP","name":"SOLID Principles - OCP","description":"Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection.","keywords":["design","c#","solid"],"articleBody":"Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection. The user can also add, edit and delete items from the grids.\nThe class was originally implemented something like this:\npublic class UserGrid { public UserGrid() { _menu.Add(new ToolStripMenuItem { Text = \"Emails\", Tag = MenuTypes.Emails }); _menu.Add(new ToolStripMenuItem { Text = \"Addresses\", Tag = MenuTypes.Addresses }); _menu.Add(new ToolStripMenuItem { Text = \"Phone Numbers\", Tag = MenuTypes.Phones }); } public void Populate() { var selection = GetMenuSelection(); var rows = new List(); switch (selection) { case MenuTypes.Emails: rows.AddRange(_user.EmailAddresses); break; case MenuTypes.Addresses: rows.AddRange(_user.Addresses); break; case MenuTypes.Phones: rows.AddRange(_user.PhoneNumbers); break; } _grid.Rows.Clear(); _grid.Rows.AddRange(rows.ToArray()); } public void OnAddClicked() { var selection = GetMenuSelection(); switch (selection) { case MenuTypes.Emails: var emailEditor = new EmailEditor(new Email()); emailEditor.ShowDialog(); break; case MenuTypes.Addresses: var addressEditor = new AddressEditor(new Address()); addressEditor.ShowDialog(); break; case MenuTypes.Phones: var phoneEditor = new PhoneEditor(new Phone()); phoneEditor.ShowDialog(); break; } } } I haven’t listed all the methods here, but you get the idea - a lot of repeated-ish code (switch statements), and when you want to add a new grid type you have to do the following steps:\nAdd a new entry to the MenuTypes enum. Add the new menu item in the constructor. Add an implementation to the Populate method. Add an implementation for each action to the add, edit and delete methods. This pretty much defines the opposite of the Open Closed Principle - the class has to be edited to add in any new functionality, and grows larger each time. Throw in some more logic to the class, such as:\nYou cannot edit Addresses, they can only be added or removed. You can only delete an Email if it was added less than 1 week ago. A Super User can do anything. A General User can only view items. and you are asking for trouble, and when those requirements change or get added to, you will have to go back through all the different methods to make sure your logic holds true.\nThe Solution In a similar way to how we handled refactoring and improving the code of the JobPostingService in the last post, we can make a set of small steps to improve this class.\nUnlike the last solution, we are going to use an abstract class as our base, rather than an Interface. This is picked as we have some methods which are optional (see the first requirement), so we may not wish to implement all methods.\nOur first step is to create our base class:\npublic abstract class GridHandler { public User User { get; set; } public abstract String Title { get; } public abstract IEnumerable Populate(); public virtual void Add() {} public virtual void Edit(object item) {} public virtual void Delete(object item) {} } Note that the Title property and Populate method are abstract - you must implement these at the very least to be a GridHandler. At the same time as this, we will lay our groundwork in the UserGrid class:\npublic class UserGrid { private readonly List _handlers; public UserGrid() { _handlers = new List(); _grid = new DataGridView(); _menu = new List(); _menu.Add(new ToolStripMenuItem { Text = \"Emails\", Tag = MenuTypes.Emails }); _menu.Add(new ToolStripMenuItem { Text = \"Addresses\", Tag = MenuTypes.Addresses }); _menu.Add(new ToolStripMenuItem { Text = \"Phone Numbers\", Tag = MenuTypes.Phones }); } public void AddHandler(GridHandler handler) { _handlers.Add(handler); _menu.Add(new ToolStripMenuItem { Text = handler.Title }); } public void SetUser(User user) { _user = user; _handlers.ForEach(handler =\u003e handler.User = user); } public void Populate() { var handler = GetHandlerForSelection(); if (handler != null) { _grid.Rows.Clear(); _grid.Rows.AddRange(handler.Populate().ToArray()); return; } var selection = GetMenuSelection(); var rows = new List(); switch (selection) { case MenuTypes.Emails: rows.AddRange(_user.EmailAddresses); break; case MenuTypes.Addresses: rows.AddRange(_user.Addresses); break; case MenuTypes.Phones: rows.AddRange(_user.PhoneNumbers); break; } _grid.Rows.Clear(); _grid.Rows.AddRange(rows.ToArray()); } } The UserGrid class has had a new method called AddHandler, which allows handlers to be added to the grid. The SetUser method has been updated to also set the User property on all handlers, and all the Add, Edit, Delete and Populate methods have been updated to attempt to try and use a handler, and if none is found, use the existing implementation.\nOur next step is to create the first GridHandler, which will be for Email Addresses:\npublic class EmailGridHandler : GridHandler { public override string Title { get { return \"Email Addresses\"; } } public override IEnumerable Populate() { return User.EmailAddresses; } public override void Add() { var email = new Email(); var editor = new EmailEditor(email); editor.ShowDialog(); User.AddEmail(email); } public override void Edit(object item) { var email = (Email)item; var editor = new EmailEditor(email); editor.ShowDialog(); } public override void Delete(object item) { var email = (Email)item; User.RemoveEmail(email); } } As you can see, this class obeys the Single Responsibility Principle as it only deals with how to change data from the User object into data and actions for the grid.\nWe can now update the usage of our UserGrid to take advantage of the new GridHandler:\npublic class Usage : Form { private UserGrid _grid; public Usage() { _grid = new UserGrid(); _grid.AddHandler(new EmailGridHandler()); } } All that remains to be done now is to go through the UserGrid and remove all the code relating to Emails. The extraction of functionality steps can then be repeated for each of the existing grid types (Address and Phone in our case.)\nOnce this is done, we can go back to the UserGrid and remove all non-grid code, leaving us with this:\npublic class UserGrid { private readonly List _handlers; public UserGrid() { _handlers = new List(); } public void AddHandler(GridHandler handler) { _handlers.Add(handler); _menu.Add(new ToolStripMenuItem { Text = handler.Title }); } public void SetUser(User user) { _handlers.ForEach(handler =\u003e handler.User = user); } public void Populate() { var handler = GetHandlerForSelection(); if (handler != null) { _grid.Rows.Clear(); _grid.Rows.AddRange(handler.Populate().ToArray()); } } public void OnAddClicked() { var handler = GetHandlerForSelection(); if (handler != null) { handler.Add(); Populate(); } } } As you can see, the UserGrid class is now much smaller, and has no user specific logic in it. This means we don’t need to modify the class when we want to add a new grid type (it is closed for modification), but as adding new functionality to the grid just consists of another call to .AddHandler(new WebsiteGridHandler()); we have made it open for extension.\nAll source code is available on my Github: Solid.Demo Source Code\n","wordCount":"1123","inLanguage":"en","datePublished":"2014-02-19T00:00:00Z","dateModified":"2014-02-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/02/19/solid-principles-ocp/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles - OCP</h1><div class=post-meta><span title='2014-02-19 00:00:00 +0000 UTC'>February 19, 2014</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><h2 id=open-closed-principle>Open Closed Principle<a hidden class=anchor aria-hidden=true href=#open-closed-principle>#</a></h2><p><a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility</a> | <a href=http://andydote.co.uk/solid-principles-ocp>Open Closed</a> | <a href=http://andydote.co.uk/solid-principles-lsp>Liskov Substitution</a> | <a href=http://andydote.co.uk/solid-principles-isp>Interface Segregation</a> | <a href=http://andydote.co.uk/solid-principles-dip>Dependency Inversion</a></p><p>The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification?
A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection. The user can also add, edit and delete items from the grids.</p><p>The class was originally implemented something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGrid</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> UserGrid()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Emails&#34;</span>, Tag = MenuTypes.Emails });
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Addresses&#34;</span>, Tag = MenuTypes.Addresses });
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Phone Numbers&#34;</span>, Tag = MenuTypes.Phones });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> selection = GetMenuSelection();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> rows = <span style=color:#66d9ef>new</span> List&lt;DataGridViewRow&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (selection)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Emails:
</span></span><span style=display:flex><span>				rows.AddRange(_user.EmailAddresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Addresses:
</span></span><span style=display:flex><span>				rows.AddRange(_user.Addresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Phones:
</span></span><span style=display:flex><span>				rows.AddRange(_user.PhoneNumbers);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_grid.Rows.Clear();
</span></span><span style=display:flex><span>		_grid.Rows.AddRange(rows.ToArray());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnAddClicked()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> selection = GetMenuSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (selection)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Emails:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> emailEditor = <span style=color:#66d9ef>new</span> EmailEditor(<span style=color:#66d9ef>new</span> Email());
</span></span><span style=display:flex><span>				emailEditor.ShowDialog();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Addresses:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> addressEditor = <span style=color:#66d9ef>new</span> AddressEditor(<span style=color:#66d9ef>new</span> Address());
</span></span><span style=display:flex><span>				addressEditor.ShowDialog();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Phones:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> phoneEditor = <span style=color:#66d9ef>new</span> PhoneEditor(<span style=color:#66d9ef>new</span> Phone());
</span></span><span style=display:flex><span>				phoneEditor.ShowDialog();
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I haven&rsquo;t listed all the methods here, but you get the idea - a lot of repeated-ish code (switch statements), and when you want to add a new grid type you have to do the following steps:</p><ul><li>Add a new entry to the MenuTypes enum.</li><li>Add the new menu item in the constructor.</li><li>Add an implementation to the Populate method.</li><li>Add an implementation for each action to the add, edit and delete methods.</li></ul><p>This pretty much defines the opposite of the Open Closed Principle - the class has to be edited to add in any new functionality, and grows larger each time. Throw in some more logic to the class, such as:</p><ul><li>You cannot edit Addresses, they can only be added or removed.</li><li>You can only delete an Email if it was added less than 1 week ago.</li><li>A Super User can do anything.</li><li>A General User can only view items.</li></ul><p>and you are asking for trouble, and when those requirements change or get added to, you will have to go back through all the different methods to make sure your logic holds true.</p><h2 id=the-solution>The Solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><p>In a similar way to how we handled refactoring and improving the code of the <code>JobPostingService</code> in the last post, we can make a set of small steps to improve this class.</p><p>Unlike the last solution, we are going to use an abstract class as our base, rather than an Interface. This is picked as we have some methods which are optional (see the first requirement), so we may not wish to implement all methods.</p><p>Our first step is to create our base class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GridHandler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> User User { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> String Title { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> IEnumerable&lt;DataGridViewRow&gt; Populate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Add()
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Edit(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Delete(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that the <code>Title</code> property and <code>Populate</code> method are abstract - you must implement these at the very least to be a <code>GridHandler</code>.
At the same time as this, we will lay our groundwork in the <code>UserGrid</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGrid</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;GridHandler&gt; _handlers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> UserGrid()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_handlers = <span style=color:#66d9ef>new</span> List&lt;GridHandler&gt;();
</span></span><span style=display:flex><span>		_grid = <span style=color:#66d9ef>new</span> DataGridView();
</span></span><span style=display:flex><span>		_menu = <span style=color:#66d9ef>new</span> List&lt;ToolStripMenuItem&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Emails&#34;</span>, Tag = MenuTypes.Emails });
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Addresses&#34;</span>, Tag = MenuTypes.Addresses });
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Phone Numbers&#34;</span>, Tag = MenuTypes.Phones });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> AddHandler(GridHandler handler)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_handlers.Add(handler);
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = handler.Title });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetUser(User user)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_user = user;
</span></span><span style=display:flex><span>		_handlers.ForEach(handler =&gt; handler.User = user);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = GetHandlerForSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			_grid.Rows.Clear();
</span></span><span style=display:flex><span>			_grid.Rows.AddRange(handler.Populate().ToArray());
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> selection = GetMenuSelection();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> rows = <span style=color:#66d9ef>new</span> List&lt;DataGridViewRow&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (selection)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Emails:
</span></span><span style=display:flex><span>				rows.AddRange(_user.EmailAddresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Addresses:
</span></span><span style=display:flex><span>				rows.AddRange(_user.Addresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Phones:
</span></span><span style=display:flex><span>				rows.AddRange(_user.PhoneNumbers);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		_grid.Rows.Clear();
</span></span><span style=display:flex><span>		_grid.Rows.AddRange(rows.ToArray());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>UserGrid</code> class has had a new method called <code>AddHandler</code>, which allows handlers to be added to the grid. The <code>SetUser</code> method has been updated to also set the <code>User</code> property on all handlers, and all the <code>Add</code>, <code>Edit</code>, <code>Delete</code> and <code>Populate</code> methods have been updated to attempt to try and use a handler, and if none is found, use the existing implementation.</p><p>Our next step is to create the first <code>GridHandler</code>, which will be for Email Addresses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EmailGridHandler</span> : GridHandler
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>string</span> Title
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Email Addresses&#34;</span>; }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> IEnumerable&lt;DataGridViewRow&gt; Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> User.EmailAddresses;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Add()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> email = <span style=color:#66d9ef>new</span> Email();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> editor = <span style=color:#66d9ef>new</span> EmailEditor(email);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		editor.ShowDialog();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		User.AddEmail(email);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Edit(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> email = (Email)item;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> editor = <span style=color:#66d9ef>new</span> EmailEditor(email);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		editor.ShowDialog();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Delete(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> email = (Email)item;
</span></span><span style=display:flex><span>		User.RemoveEmail(email);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, this class obeys the <a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility Principle</a> as it only deals with how to change data from the <code>User</code> object into data and actions for the grid.</p><p>We can now update the usage of our <code>UserGrid</code> to take advantage of the new <code>GridHandler</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Usage</span> : Form
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> UserGrid _grid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Usage()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_grid = <span style=color:#66d9ef>new</span> UserGrid();
</span></span><span style=display:flex><span>		_grid.AddHandler(<span style=color:#66d9ef>new</span> EmailGridHandler());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All that remains to be done now is to go through the <code>UserGrid</code> and remove all the code relating to <code>Email</code>s. The extraction of functionality steps can then be repeated for each of the existing grid types (<code>Address</code> and <code>Phone</code> in our case.)</p><p>Once this is done, we can go back to the <code>UserGrid</code> and remove all non-grid code, leaving us with this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGrid</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;GridHandler&gt; _handlers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> UserGrid()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_handlers = <span style=color:#66d9ef>new</span> List&lt;GridHandler&gt;();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> AddHandler(GridHandler handler)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_handlers.Add(handler);
</span></span><span style=display:flex><span>		_menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = handler.Title });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetUser(User user)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		_handlers.ForEach(handler =&gt; handler.User = user);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = GetHandlerForSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			_grid.Rows.Clear();
</span></span><span style=display:flex><span>			_grid.Rows.AddRange(handler.Populate().ToArray());
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnAddClicked()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = GetHandlerForSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			handler.Add();
</span></span><span style=display:flex><span>			Populate();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, the <code>UserGrid</code> class is now much smaller, and has no user specific logic in it. This means we don&rsquo;t need to modify the class when we want to add a new grid type (it is <strong>closed for modification</strong>), but as adding new functionality to the grid just consists of another call to <code>.AddHandler(new WebsiteGridHandler());</code> we have made it <strong>open for extension</strong>.</p><p>All source code is available on my Github: <a href=https://github.com/Pondidum/Solid.Demo>Solid.Demo Source Code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/solid/>solid</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/02/23/solid-principles-lsp/><span class=title>« Prev Page</span><br><span>SOLID Principles - LSP</span></a>
<a class=next href=https://andydote.co.uk/2014/02/18/solid-principles-srp/><span class=title>Next Page »</span><br><span>SOLID Principles - SRP</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>