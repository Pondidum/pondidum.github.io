<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOLID Principles - OCP | Andy Dote</title><meta name=keywords content="design,c#,solid"><meta name=description content="Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/02/19/solid-principles-ocp/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="SOLID Principles - OCP"><meta property="og:description" content="Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/02/19/solid-principles-ocp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-02-19T00:00:00+00:00"><meta property="article:modified_time" content="2014-02-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SOLID Principles - OCP"><meta name=twitter:description content="Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion
The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"SOLID Principles - OCP","item":"https://andydote.co.uk/2014/02/19/solid-principles-ocp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOLID Principles - OCP","name":"SOLID Principles - OCP","description":"Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection.","keywords":["design","c#","solid"],"articleBody":"Open Closed Principle Single Responsibility | Open Closed | Liskov Substitution | Interface Segregation | Dependency Inversion\nThe Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification? A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection. The user can also add, edit and delete items from the grids.\nThe class was originally implemented something like this:\npublic class UserGrid {  \tpublic UserGrid() \t{ \t_menu.Add(new ToolStripMenuItem { Text = \"Emails\", Tag = MenuTypes.Emails }); \t_menu.Add(new ToolStripMenuItem { Text = \"Addresses\", Tag = MenuTypes.Addresses }); \t_menu.Add(new ToolStripMenuItem { Text = \"Phone Numbers\", Tag = MenuTypes.Phones }); \t}  \tpublic void Populate() \t{ \tvar selection = GetMenuSelection(); \tvar rows = new List();  \tswitch (selection) \t{ \tcase MenuTypes.Emails: \trows.AddRange(_user.EmailAddresses); \tbreak;  \tcase MenuTypes.Addresses: \trows.AddRange(_user.Addresses); \tbreak;  \tcase MenuTypes.Phones: \trows.AddRange(_user.PhoneNumbers); \tbreak; \t}  \t_grid.Rows.Clear(); \t_grid.Rows.AddRange(rows.ToArray()); \t}  \tpublic void OnAddClicked() \t{ \tvar selection = GetMenuSelection();  \tswitch (selection) \t{ \tcase MenuTypes.Emails:  \tvar emailEditor = new EmailEditor(new Email()); \temailEditor.ShowDialog();  \tbreak;  \tcase MenuTypes.Addresses:  \tvar addressEditor = new AddressEditor(new Address()); \taddressEditor.ShowDialog();  \tbreak;  \tcase MenuTypes.Phones:  \tvar phoneEditor = new PhoneEditor(new Phone()); \tphoneEditor.ShowDialog(); \tbreak; \t} \t} } I haven’t listed all the methods here, but you get the idea - a lot of repeated-ish code (switch statements), and when you want to add a new grid type you have to do the following steps:\n Add a new entry to the MenuTypes enum. Add the new menu item in the constructor. Add an implementation to the Populate method. Add an implementation for each action to the add, edit and delete methods.  This pretty much defines the opposite of the Open Closed Principle - the class has to be edited to add in any new functionality, and grows larger each time. Throw in some more logic to the class, such as:\n You cannot edit Addresses, they can only be added or removed. You can only delete an Email if it was added less than 1 week ago. A Super User can do anything. A General User can only view items.  and you are asking for trouble, and when those requirements change or get added to, you will have to go back through all the different methods to make sure your logic holds true.\nThe Solution In a similar way to how we handled refactoring and improving the code of the JobPostingService in the last post, we can make a set of small steps to improve this class.\nUnlike the last solution, we are going to use an abstract class as our base, rather than an Interface. This is picked as we have some methods which are optional (see the first requirement), so we may not wish to implement all methods.\nOur first step is to create our base class:\npublic abstract class GridHandler { \tpublic User User { get; set; } \tpublic abstract String Title { get; } \tpublic abstract IEnumerable Populate();  \tpublic virtual void Add() \t{}  \tpublic virtual void Edit(object item) \t{}  \tpublic virtual void Delete(object item) \t{} } Note that the Title property and Populate method are abstract - you must implement these at the very least to be a GridHandler. At the same time as this, we will lay our groundwork in the UserGrid class:\npublic class UserGrid { \tprivate readonly List _handlers;  \tpublic UserGrid() \t{ \t_handlers = new List(); \t_grid = new DataGridView(); \t_menu = new List();  \t_menu.Add(new ToolStripMenuItem { Text = \"Emails\", Tag = MenuTypes.Emails }); \t_menu.Add(new ToolStripMenuItem { Text = \"Addresses\", Tag = MenuTypes.Addresses }); \t_menu.Add(new ToolStripMenuItem { Text = \"Phone Numbers\", Tag = MenuTypes.Phones });  \t}  \tpublic void AddHandler(GridHandler handler) \t{ \t_handlers.Add(handler); \t_menu.Add(new ToolStripMenuItem { Text = handler.Title }); \t}  \tpublic void SetUser(User user) \t{ \t_user = user; \t_handlers.ForEach(handler = handler.User = user); \t}  \tpublic void Populate() \t{ \tvar handler = GetHandlerForSelection();  \tif (handler != null) \t{ \t_grid.Rows.Clear(); \t_grid.Rows.AddRange(handler.Populate().ToArray()); \treturn; \t}  \tvar selection = GetMenuSelection(); \tvar rows = new List();  \tswitch (selection) \t{ \tcase MenuTypes.Emails: \trows.AddRange(_user.EmailAddresses); \tbreak;  \tcase MenuTypes.Addresses: \trows.AddRange(_user.Addresses); \tbreak;  \tcase MenuTypes.Phones: \trows.AddRange(_user.PhoneNumbers); \tbreak; \t}  \t_grid.Rows.Clear(); \t_grid.Rows.AddRange(rows.ToArray()); \t} } The UserGrid class has had a new method called AddHandler, which allows handlers to be added to the grid. The SetUser method has been updated to also set the User property on all handlers, and all the Add, Edit, Delete and Populate methods have been updated to attempt to try and use a handler, and if none is found, use the existing implementation.\nOur next step is to create the first GridHandler, which will be for Email Addresses:\npublic class EmailGridHandler : GridHandler { \tpublic override string Title \t{ \tget { return \"Email Addresses\"; } \t}  \tpublic override IEnumerable Populate() \t{ \treturn User.EmailAddresses; \t}  \tpublic override void Add() \t{ \tvar email = new Email(); \tvar editor = new EmailEditor(email);  \teditor.ShowDialog();  \tUser.AddEmail(email); \t}  \tpublic override void Edit(object item) \t{ \tvar email = (Email)item; \tvar editor = new EmailEditor(email);  \teditor.ShowDialog(); \t}  \tpublic override void Delete(object item) \t{ \tvar email = (Email)item; \tUser.RemoveEmail(email); \t} } As you can see, this class obeys the Single Responsibility Principle as it only deals with how to change data from the User object into data and actions for the grid.\nWe can now update the usage of our UserGrid to take advantage of the new GridHandler:\npublic class Usage : Form { \tprivate UserGrid _grid;  \tpublic Usage() \t{ \t_grid = new UserGrid(); \t_grid.AddHandler(new EmailGridHandler()); \t} } All that remains to be done now is to go through the UserGrid and remove all the code relating to Emails. The extraction of functionality steps can then be repeated for each of the existing grid types (Address and Phone in our case.)\nOnce this is done, we can go back to the UserGrid and remove all non-grid code, leaving us with this:\npublic class UserGrid { \tprivate readonly List _handlers;  \tpublic UserGrid() \t{ \t_handlers = new List(); \t}  \tpublic void AddHandler(GridHandler handler) \t{ \t_handlers.Add(handler); \t_menu.Add(new ToolStripMenuItem { Text = handler.Title }); \t}  \tpublic void SetUser(User user) \t{ \t_handlers.ForEach(handler = handler.User = user); \t}  \tpublic void Populate() \t{ \tvar handler = GetHandlerForSelection();  \tif (handler != null) \t{ \t_grid.Rows.Clear(); \t_grid.Rows.AddRange(handler.Populate().ToArray()); \t} \t}  \tpublic void OnAddClicked() \t{ \tvar handler = GetHandlerForSelection();  \tif (handler != null) \t{ \thandler.Add(); \tPopulate(); \t} \t} } As you can see, the UserGrid class is now much smaller, and has no user specific logic in it. This means we don’t need to modify the class when we want to add a new grid type (it is closed for modification), but as adding new functionality to the grid just consists of another call to .AddHandler(new WebsiteGridHandler()); we have made it open for extension.\nAll source code is available on my Github: Solid.Demo Source Code\n","wordCount":"1123","inLanguage":"en","datePublished":"2014-02-19T00:00:00Z","dateModified":"2014-02-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/02/19/solid-principles-ocp/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SOLID Principles - OCP</h1><div class=post-meta><span title="2014-02-19 00:00:00 +0000 UTC">February 19, 2014</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><h2 id=open-closed-principle>Open Closed Principle<a hidden class=anchor aria-hidden=true href=#open-closed-principle>#</a></h2><p><a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility</a> | <a href=http://andydote.co.uk/solid-principles-ocp>Open Closed</a> | <a href=http://andydote.co.uk/solid-principles-lsp>Liskov Substitution</a> | <a href=http://andydote.co.uk/solid-principles-isp>Interface Segregation</a> | <a href=http://andydote.co.uk/solid-principles-dip>Dependency Inversion</a></p><p>The Open Closed Principle is one that I often find is miss-understood - how can something be open for extension, but closed for modification?
A good example of this principle being implemented cropped up at work a while ago, we had a UI element which has a reusable grid, which gets populated with data based on a menu selection. The user can also add, edit and delete items from the grids.</p><p>The class was originally implemented something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGrid</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> UserGrid()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Emails&#34;</span>, Tag = MenuTypes.Emails });
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Addresses&#34;</span>, Tag = MenuTypes.Addresses });
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Phone Numbers&#34;</span>, Tag = MenuTypes.Phones });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> selection = GetMenuSelection();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> rows = <span style=color:#66d9ef>new</span> List&lt;DataGridViewRow&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (selection)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Emails:
</span></span><span style=display:flex><span>				rows.AddRange(<span style=color:#ae81ff>_</span>user.EmailAddresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Addresses:
</span></span><span style=display:flex><span>				rows.AddRange(<span style=color:#ae81ff>_</span>user.Addresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Phones:
</span></span><span style=display:flex><span>				rows.AddRange(<span style=color:#ae81ff>_</span>user.PhoneNumbers);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid.Rows.Clear();
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid.Rows.AddRange(rows.ToArray());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnAddClicked()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> selection = GetMenuSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (selection)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Emails:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> emailEditor = <span style=color:#66d9ef>new</span> EmailEditor(<span style=color:#66d9ef>new</span> Email());
</span></span><span style=display:flex><span>				emailEditor.ShowDialog();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Addresses:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> addressEditor = <span style=color:#66d9ef>new</span> AddressEditor(<span style=color:#66d9ef>new</span> Address());
</span></span><span style=display:flex><span>				addressEditor.ShowDialog();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Phones:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> phoneEditor = <span style=color:#66d9ef>new</span> PhoneEditor(<span style=color:#66d9ef>new</span> Phone());
</span></span><span style=display:flex><span>				phoneEditor.ShowDialog();
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I haven&rsquo;t listed all the methods here, but you get the idea - a lot of repeated-ish code (switch statements), and when you want to add a new grid type you have to do the following steps:</p><ul><li>Add a new entry to the MenuTypes enum.</li><li>Add the new menu item in the constructor.</li><li>Add an implementation to the Populate method.</li><li>Add an implementation for each action to the add, edit and delete methods.</li></ul><p>This pretty much defines the opposite of the Open Closed Principle - the class has to be edited to add in any new functionality, and grows larger each time. Throw in some more logic to the class, such as:</p><ul><li>You cannot edit Addresses, they can only be added or removed.</li><li>You can only delete an Email if it was added less than 1 week ago.</li><li>A Super User can do anything.</li><li>A General User can only view items.</li></ul><p>and you are asking for trouble, and when those requirements change or get added to, you will have to go back through all the different methods to make sure your logic holds true.</p><h2 id=the-solution>The Solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><p>In a similar way to how we handled refactoring and improving the code of the <code>JobPostingService</code> in the last post, we can make a set of small steps to improve this class.</p><p>Unlike the last solution, we are going to use an abstract class as our base, rather than an Interface. This is picked as we have some methods which are optional (see the first requirement), so we may not wish to implement all methods.</p><p>Our first step is to create our base class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>GridHandler</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> User User { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> String Title { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> IEnumerable&lt;DataGridViewRow&gt; Populate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Add()
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Edit(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Delete(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that the <code>Title</code> property and <code>Populate</code> method are abstract - you must implement these at the very least to be a <code>GridHandler</code>.
At the same time as this, we will lay our groundwork in the <code>UserGrid</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGrid</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;GridHandler&gt; <span style=color:#ae81ff>_</span>handlers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> UserGrid()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>handlers = <span style=color:#66d9ef>new</span> List&lt;GridHandler&gt;();
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid = <span style=color:#66d9ef>new</span> DataGridView();
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu = <span style=color:#66d9ef>new</span> List&lt;ToolStripMenuItem&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Emails&#34;</span>, Tag = MenuTypes.Emails });
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Addresses&#34;</span>, Tag = MenuTypes.Addresses });
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = <span style=color:#e6db74>&#34;Phone Numbers&#34;</span>, Tag = MenuTypes.Phones });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> AddHandler(GridHandler handler)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>handlers.Add(handler);
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = handler.Title });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetUser(User user)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>user = user;
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>handlers.ForEach(handler =&gt; handler.User = user);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = GetHandlerForSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>_</span>grid.Rows.Clear();
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>_</span>grid.Rows.AddRange(handler.Populate().ToArray());
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> selection = GetMenuSelection();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> rows = <span style=color:#66d9ef>new</span> List&lt;DataGridViewRow&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>switch</span> (selection)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Emails:
</span></span><span style=display:flex><span>				rows.AddRange(<span style=color:#ae81ff>_</span>user.EmailAddresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Addresses:
</span></span><span style=display:flex><span>				rows.AddRange(<span style=color:#ae81ff>_</span>user.Addresses);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>case</span> MenuTypes.Phones:
</span></span><span style=display:flex><span>				rows.AddRange(<span style=color:#ae81ff>_</span>user.PhoneNumbers);
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid.Rows.Clear();
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid.Rows.AddRange(rows.ToArray());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>UserGrid</code> class has had a new method called <code>AddHandler</code>, which allows handlers to be added to the grid. The <code>SetUser</code> method has been updated to also set the <code>User</code> property on all handlers, and all the <code>Add</code>, <code>Edit</code>, <code>Delete</code> and <code>Populate</code> methods have been updated to attempt to try and use a handler, and if none is found, use the existing implementation.</p><p>Our next step is to create the first <code>GridHandler</code>, which will be for Email Addresses:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EmailGridHandler</span> : GridHandler
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>string</span> Title
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Email Addresses&#34;</span>; }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> IEnumerable&lt;DataGridViewRow&gt; Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> User.EmailAddresses;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Add()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> email = <span style=color:#66d9ef>new</span> Email();
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> editor = <span style=color:#66d9ef>new</span> EmailEditor(email);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		editor.ShowDialog();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		User.AddEmail(email);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Edit(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> email = (Email)item;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> editor = <span style=color:#66d9ef>new</span> EmailEditor(email);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		editor.ShowDialog();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Delete(<span style=color:#66d9ef>object</span> item)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> email = (Email)item;
</span></span><span style=display:flex><span>		User.RemoveEmail(email);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, this class obeys the <a href=http://andydote.co.uk/solid-principles-srp>Single Responsibility Principle</a> as it only deals with how to change data from the <code>User</code> object into data and actions for the grid.</p><p>We can now update the usage of our <code>UserGrid</code> to take advantage of the new <code>GridHandler</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Usage</span> : Form
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> UserGrid <span style=color:#ae81ff>_</span>grid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Usage()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid = <span style=color:#66d9ef>new</span> UserGrid();
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>grid.AddHandler(<span style=color:#66d9ef>new</span> EmailGridHandler());
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All that remains to be done now is to go through the <code>UserGrid</code> and remove all the code relating to <code>Email</code>s. The extraction of functionality steps can then be repeated for each of the existing grid types (<code>Address</code> and <code>Phone</code> in our case.)</p><p>Once this is done, we can go back to the <code>UserGrid</code> and remove all non-grid code, leaving us with this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UserGrid</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> List&lt;GridHandler&gt; <span style=color:#ae81ff>_</span>handlers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> UserGrid()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>handlers = <span style=color:#66d9ef>new</span> List&lt;GridHandler&gt;();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> AddHandler(GridHandler handler)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>handlers.Add(handler);
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>menu.Add(<span style=color:#66d9ef>new</span> ToolStripMenuItem { Text = handler.Title });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> SetUser(User user)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>handlers.ForEach(handler =&gt; handler.User = user);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Populate()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = GetHandlerForSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>_</span>grid.Rows.Clear();
</span></span><span style=display:flex><span>			<span style=color:#ae81ff>_</span>grid.Rows.AddRange(handler.Populate().ToArray());
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> OnAddClicked()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = GetHandlerForSelection();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (handler != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			handler.Add();
</span></span><span style=display:flex><span>			Populate();
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can see, the <code>UserGrid</code> class is now much smaller, and has no user specific logic in it. This means we don&rsquo;t need to modify the class when we want to add a new grid type (it is <strong>closed for modification</strong>), but as adding new functionality to the grid just consists of another call to <code>.AddHandler(new WebsiteGridHandler());</code> we have made it <strong>open for extension</strong>.</p><p>All source code is available on my Github: <a href=https://github.com/Pondidum/Solid.Demo>Solid.Demo Source Code</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/solid/>solid</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/02/23/solid-principles-lsp/><span class=title>« Prev Page</span><br><span>SOLID Principles - LSP</span></a>
<a class=next href=https://andydote.co.uk/2014/02/18/solid-principles-srp/><span class=title>Next Page »</span><br><span>SOLID Principles - SRP</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>