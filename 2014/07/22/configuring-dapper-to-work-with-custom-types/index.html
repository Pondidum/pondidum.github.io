<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Configuring Dapper to work with custom types | Andy Dote</title><meta name=keywords content="design,c#,typing,sql,database,orm"><meta name=description content="In the last post we looked at using custom ID types to help abstract the column type from the domain.
This works well until you start trying to load and save entities using an ORM, as the ORM has not way to know how to map a column to a custom type. ORMs provide extension points to allow you to create these mappings. As I tend to favour using Dapper, we will go through setting it up to work with our custom ID types."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2014/07/22/configuring-dapper-to-work-with-custom-types/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Configuring Dapper to work with custom types"><meta property="og:description" content="In the last post we looked at using custom ID types to help abstract the column type from the domain.
This works well until you start trying to load and save entities using an ORM, as the ORM has not way to know how to map a column to a custom type. ORMs provide extension points to allow you to create these mappings. As I tend to favour using Dapper, we will go through setting it up to work with our custom ID types."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2014/07/22/configuring-dapper-to-work-with-custom-types/"><meta property="article:section" content="post"><meta property="article:published_time" content="2014-07-22T00:00:00+00:00"><meta property="article:modified_time" content="2014-07-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Configuring Dapper to work with custom types"><meta name=twitter:description content="In the last post we looked at using custom ID types to help abstract the column type from the domain.
This works well until you start trying to load and save entities using an ORM, as the ORM has not way to know how to map a column to a custom type. ORMs provide extension points to allow you to create these mappings. As I tend to favour using Dapper, we will go through setting it up to work with our custom ID types."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Configuring Dapper to work with custom types","item":"https://andydote.co.uk/2014/07/22/configuring-dapper-to-work-with-custom-types/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Configuring Dapper to work with custom types","name":"Configuring Dapper to work with custom types","description":"In the last post we looked at using custom ID types to help abstract the column type from the domain.\nThis works well until you start trying to load and save entities using an ORM, as the ORM has not way to know how to map a column to a custom type. ORMs provide extension points to allow you to create these mappings. As I tend to favour using Dapper, we will go through setting it up to work with our custom ID types.","keywords":["design","c#","typing","sql","database","orm"],"articleBody":"In the last post we looked at using custom ID types to help abstract the column type from the domain.\nThis works well until you start trying to load and save entities using an ORM, as the ORM has not way to know how to map a column to a custom type. ORMs provide extension points to allow you to create these mappings. As I tend to favour using Dapper, we will go through setting it up to work with our custom ID types.\nWe need to be able to get the raw value out of the id type, but without exposing this to the outside world. To do this we internal interface:\ninternal interface IValueID { \tobject Value(); } Then update our id struct with a private implementation of the interface, and also mark the only constructor as internal:\npublic struct PersonID : IValueID { \tprivate readonly Guid _id;  \tinternal PersonID(Guid id) \t{ \t_id = id; \t}  \tobject IValueID.Value() \t{ \treturn _id; \t} } We now can define a class which Dapper can use to do the mapping from uuid to id:\npublic class PersonIDHandler : SqlMapper.TypeHandler { \tpublic override void SetValue(IDbDataParameter parameter, PersonID value) \t{ \tparameter.Value = ((IValueID)value).Value(); \t}  \tpublic override PersonID Parse(object value) \t{ \treturn new PersonID((Guid)value); \t} } We then need to regiter the command with Dapper once on start up of our application:\nSqlMapper.AddTypeHandler(new PersonIDHandler()); Now when Dapper loads an object with a property type of PersonID it will invoke the Parse method on PersonIDHandler, and populate the resulting object correctly. It will also work when getting a value from the PersonID property, invoking the SetValue method on PersonIDHandler.\nExtension While the PersonIDHandler works, I really don’t want to be creating essentially the same class over and over again for each ID type. We can fix this by using a generic id handler class, and some reflection magic.\nWe start off by creating a generic class for id handling:\npublic class CustomHandler : SqlMapper.TypeHandler { \tprivate readonly Func_createInstance;  \tpublic CustomHandler() \t{ \tvar ctor = typeof(T) \t.GetConstructors() \t.Single(c = c.GetParameters().Count() == 1);  \tvar paramType = ctor \t.GetParameters() \t.First() \t.ParameterType;  \t_createInstance = (value) = (T)ctor.Invoke(new[] { Convert.ChangeType(value, paramType) }); \t}  \tpublic override void SetValue(IDbDataParameter parameter, T value) \t{ \tparameter.Value = ((IValueID)value).Value(); \t}  \tpublic override T Parse(object value) \t{ \treturn _createInstance(value); \t} } The constructor of this class just finds a single constructor on our ID type with one argument, and creates a Func which will create an instance of the id passing in the value. We put all this constructor discovery logic into the CustomHandler’s constructor as this information only needs to be calculated once, and can then be used for every Parse call.\nWe then need to write something to build an instance of this for each ID type in our system. As all of our IDs need to implement IValueID to work, we can scan for all types in the assembly implementing this interface, and then operate on those.\npublic class InitialiseDapper : IApplicationStart { \tpublic void Initialise() \t{ \tvar interfaceType = typeof(IValueID);  \tvar idTypes = interfaceType \t.Assembly \t.GetTypes() \t.Where(t = t.IsInterface == false) \t.Where(t = t.IsAbstract == false) \t.Where(t = t.GetInterfaces().Contains(interfaceType));  \tvar handler = typeof(CustomHandler);  \tforeach (var idType in idTypes) \t{ \tvar ctor = handler \t.MakeGenericType(new[] { idType }) \t.GetConstructor(Type.EmptyTypes);  \tvar instance = (SqlMapper.ITypeHandler)ctor.Invoke(new object[] { });  \tSqlMapper.AddTypeHandler(idType, instance); \t} \t} } This class first scans the assembly containing IValueID for all types implementing IValueID which are not abstract, and not interfaces themselves. It then goes through each of these types, and builds a new instance of CustomHandler for each type, and registers it with Dapper.\nYou might notice this is in a class which implements IApplicationStart - In most of my larger projects, I tend to have an interface like this, which defines a single void Initialise(); method. Implementations of the interface get looked for on startup of the application, and their Initialise method called once each.\n","wordCount":"656","inLanguage":"en","datePublished":"2014-07-22T00:00:00Z","dateModified":"2014-07-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2014/07/22/configuring-dapper-to-work-with-custom-types/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Configuring Dapper to work with custom types</h1><div class=post-meta><span title="2014-07-22 00:00:00 +0000 UTC">July 22, 2014</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>In the <a href=http://andydote.co.uk/strong-type-your-entity-ids>last post</a> we looked at using custom ID types to help abstract the column type from the domain.</p><p>This works well until you start trying to load and save entities using an ORM, as the ORM has not way to know how to map a column to a custom type. ORMs provide extension points to allow you to create these mappings. As I tend to favour using <a href=https://github.com/StackExchange/dapper-dot-net>Dapper</a>, we will go through setting it up to work with our custom ID types.</p><p>We need to be able to get the raw value out of the id type, but without exposing this to the outside world. To do this we internal interface:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IValueID</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>object</span> Value();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then update our id struct with a private implementation of the interface, and also mark the only constructor as internal:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>PersonID</span> : IValueID
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Guid <span style=color:#ae81ff>_</span>id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>internal</span> PersonID(Guid id)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>id = id;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>object</span> IValueID.Value()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>_</span>id;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We now can define a class which Dapper can use to do the mapping from uuid to id:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PersonIDHandler</span> : SqlMapper.TypeHandler&lt;PersonID&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> SetValue(IDbDataParameter parameter, PersonID <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		parameter.Value = ((IValueID)<span style=color:#66d9ef>value</span>).Value();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> PersonID Parse(<span style=color:#66d9ef>object</span> <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> PersonID((Guid)<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We then need to regiter the command with Dapper once on start up of our application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>SqlMapper.AddTypeHandler(<span style=color:#66d9ef>new</span> PersonIDHandler());
</span></span></code></pre></div><p>Now when Dapper loads an object with a property type of <code>PersonID</code> it will invoke the <code>Parse</code> method on <code>PersonIDHandler</code>, and populate the resulting object correctly. It will also work when getting a value from the <code>PersonID</code> property, invoking the <code>SetValue</code> method on <code>PersonIDHandler</code>.</p><h2 id=extension>Extension<a hidden class=anchor aria-hidden=true href=#extension>#</a></h2><p>While the <code>PersonIDHandler</code> works, I really don&rsquo;t want to be creating essentially the same class over and over again for each ID type. We can fix this by using a generic id handler class, and some reflection magic.</p><p>We start off by creating a generic class for id handling:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CustomHandler</span>&lt;T&gt; : SqlMapper.TypeHandler&lt;T&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Func&lt;Object, T&gt; <span style=color:#ae81ff>_</span>createInstance;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> CustomHandler()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> ctor = <span style=color:#66d9ef>typeof</span>(T)
</span></span><span style=display:flex><span>			.GetConstructors()
</span></span><span style=display:flex><span>			.Single(c =&gt; c.GetParameters().Count() == <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> paramType = ctor
</span></span><span style=display:flex><span>			.GetParameters()
</span></span><span style=display:flex><span>			.First()
</span></span><span style=display:flex><span>			.ParameterType;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>createInstance = (<span style=color:#66d9ef>value</span>) =&gt; (T)ctor.Invoke(<span style=color:#66d9ef>new</span>[] { Convert.ChangeType(<span style=color:#66d9ef>value</span>, paramType) });
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> SetValue(IDbDataParameter parameter, T <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		parameter.Value = ((IValueID)<span style=color:#66d9ef>value</span>).Value();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> T Parse(<span style=color:#66d9ef>object</span> <span style=color:#66d9ef>value</span>)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>_</span>createInstance(<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The constructor of this class just finds a single constructor on our ID type with one argument, and creates a Func which will create an instance of the id passing in the value. We put all this constructor discovery logic into the <code>CustomHandler</code>&rsquo;s constructor as this information only needs to be calculated once, and can then be used for every <code>Parse</code> call.</p><p>We then need to write something to build an instance of this for each ID type in our system. As all of our IDs need to implement <code>IValueID</code> to work, we can scan for all types in the assembly implementing this interface, and then operate on those.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>InitialiseDapper</span> : IApplicationStart
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Initialise()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> interfaceType = <span style=color:#66d9ef>typeof</span>(IValueID);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> idTypes = interfaceType
</span></span><span style=display:flex><span>			.Assembly
</span></span><span style=display:flex><span>			.GetTypes()
</span></span><span style=display:flex><span>			.Where(t =&gt; t.IsInterface == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			.Where(t =&gt; t.IsAbstract == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			.Where(t =&gt; t.GetInterfaces().Contains(interfaceType));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> handler = <span style=color:#66d9ef>typeof</span>(CustomHandler&lt;&gt;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> idType <span style=color:#66d9ef>in</span> idTypes)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>var</span> ctor = handler
</span></span><span style=display:flex><span>				.MakeGenericType(<span style=color:#66d9ef>new</span>[] { idType })
</span></span><span style=display:flex><span>				.GetConstructor(Type.EmptyTypes);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>var</span> instance = (SqlMapper.ITypeHandler)ctor.Invoke(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[] { });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			SqlMapper.AddTypeHandler(idType, instance);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This class first scans the assembly containing <code>IValueID</code> for all types implementing <code>IValueID</code> which are not abstract, and not interfaces themselves. It then goes through each of these types, and builds a new instance of <code>CustomHandler</code> for each type, and registers it with Dapper.</p><p>You might notice this is in a class which implements <code>IApplicationStart</code> - In most of my larger projects, I tend to have an interface like this, which defines a single <code>void Initialise();</code> method. Implementations of the interface get looked for on startup of the application, and their <code>Initialise</code> method called once each.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/typing/>typing</a></li><li><a href=https://andydote.co.uk/tags/sql/>sql</a></li><li><a href=https://andydote.co.uk/tags/database/>database</a></li><li><a href=https://andydote.co.uk/tags/orm/>orm</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2014/08/04/edgejs-for-embedded-webuis/><span class=title>« Prev Page</span><br><span>Edge.js for Embedded Webuis</span></a>
<a class=next href=https://andydote.co.uk/2014/07/17/strong-type-your-entity-ids/><span class=title>Next Page »</span><br><span>Strong Type your entity IDs.</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>