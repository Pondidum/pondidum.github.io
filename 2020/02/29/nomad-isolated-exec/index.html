<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Nomad Isolated Exec | Andy Dote</title><meta name=keywords content="infrastructure,nomad,docker"><meta name=description content="One of the many features of Nomad that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt &ldquo;Task Drivers&rdquo; there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.
The one I want to talk about today, however, is called exec. This Task Driver runs any given executable, so if you have an application which you don&rsquo;t want (or can&rsquo;t) put into a container, you can still schedule it with Nomad."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2020/02/29/nomad-isolated-exec/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Nomad Isolated Exec"><meta property="og:description" content="One of the many features of Nomad that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt &ldquo;Task Drivers&rdquo; there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.
The one I want to talk about today, however, is called exec. This Task Driver runs any given executable, so if you have an application which you don&rsquo;t want (or can&rsquo;t) put into a container, you can still schedule it with Nomad."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2020/02/29/nomad-isolated-exec/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-02-29T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-29T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Nomad Isolated Exec"><meta name=twitter:description content="One of the many features of Nomad that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt &ldquo;Task Drivers&rdquo; there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.
The one I want to talk about today, however, is called exec. This Task Driver runs any given executable, so if you have an application which you don&rsquo;t want (or can&rsquo;t) put into a container, you can still schedule it with Nomad."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Nomad Isolated Exec","item":"https://andydote.co.uk/2020/02/29/nomad-isolated-exec/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Nomad Isolated Exec","name":"Nomad Isolated Exec","description":"One of the many features of Nomad that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt \u0026ldquo;Task Drivers\u0026rdquo; there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.\nThe one I want to talk about today, however, is called exec. This Task Driver runs any given executable, so if you have an application which you don\u0026rsquo;t want (or can\u0026rsquo;t) put into a container, you can still schedule it with Nomad.","keywords":["infrastructure","nomad","docker"],"articleBody":"One of the many features of Nomad that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt “Task Drivers” there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.\nThe one I want to talk about today, however, is called exec. This Task Driver runs any given executable, so if you have an application which you don’t want (or can’t) put into a container, you can still schedule it with Nomad. When I run demos (particularly at conferences), I try to have everything runnable without an internet connection, which means I have to make sure all the Docker containers I wish to run are within a local Docker Registry already, and, well, sometimes I forget. By using exec, I can serve a binary off my machine with no container overheads involved.\nInsecurity? Until recently, I had always considered exec as a tradeoff: I don’t need a docker container, but I lose the isolation of the container, and the application I run has full access to everything on this host.\nWhat I hadn’t realised, is that exec actually uses the host operating system’s isolation features via the libcontainer package to contain the application. On Linux, this means using cgroups and a chroot, making the level of isolation roughly the same as a docker container provides.\nWhen you specify a binary to run, it must meet a few criteria:\nAn absolute path within Nomad’s chroot A relative path within the Allocation Directory For instance, to run a dotnet core application consists of invoking /usr/bin/dotnet with the relative path of the dll extracted from the artifact:\ntask \"consumer\" { driver = \"exec\" config { command = \"/usr/bin/dotnet\" args = [ \"local/Consumer.dll\" ] } artifact { source = \"http://s3.internal.net/consumer-dotnet.zip\" } } Whereas running a go binary can be done with a path relative to the allocation directory:\ntask \"consumer\" { driver = \"exec\" config { command = \"local/consumer\" } artifact { source = \"http://s3.internal.net/consumer-go.zip\" } } But what happens if we want to run a binary which is not within the default chroot environment used by exec?\nConfiguring The chroot Environment By default, Nomad links the following paths into the task’s chroot:\n[ \"/bin\", \"/etc\", \"/lib\", \"/lib32\", \"/lib64\", \"/run/resolvconf\", \"/sbin\", \"/usr\" ] We can configure the chroot per Nomad client, meaning we can provision nodes with different capabilities if necessary. This is done with the chroot_env setting in the client’s configuration file:\nclient { chroot_env { \"/bin\" = \"/bin\" \"/etc\" = \"/etc\" \"/lib\" = \"/lib\" \"/lib32\" = \"/lib32\" \"/lib64\" = \"/lib64\" \"/run/resolvconf\" = \"/run/resolvconf\" \"/sbin\" = \"/sbin\" \"/usr\" = \"/usr\" \"/vagrant\" = \"/vagrant\" } } In this case, I have added in the /vagrant path, which is useful as I usually provision a Nomad cluster using Vagrant, and thus have all my binaries etc. available in /vagrant. It means that my .nomad files for the demo have something like this for their tasks:\ntask \"dashboard\" { driver = \"exec\" config { command = \"/vagrant/apps/bin/dashboard\" } } Meaning I don’t need to host a Docker Registry, or HTTP server to expose my applications to the Nomad cluster.\nNeed Full Access? If you need full access to the host machine, you can use the non-isolating version of exec, called raw_exec. raw_exec works in the same way as exec, but without using cgroups and chroot. As this would be a security risk, it must be enabled on each Nomad client:\nclient { enabled = true } plugin \"raw_exec\" { config { enabled = true } } Wrapping Up One of the many reasons I like Nomad is its simplicity, especially when compared to something as big and complex as Kubernetes. Whenever I look into how Nomad works, I always seem to come away with the feeling that it has been well thought out, and how flexible it is because of this.\nBeing able to configure the chroot used by the Nomad clients means I can simplify my various demos further, as I can remove the need to have a webserver for an artifact source. As always, the less accidental complexity you have in your system, the better.\n","wordCount":"705","inLanguage":"en","datePublished":"2020-02-29T00:00:00Z","dateModified":"2020-02-29T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2020/02/29/nomad-isolated-exec/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Nomad Isolated Exec</h1><div class=post-meta><span title='2020-02-29 00:00:00 +0000 UTC'>February 29, 2020</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>One of the many features of <a href=https://nomadproject.io>Nomad</a> that I like is the ability to run things other than Docker containers. It has built-in support for Java, QEMU, and Rkt, although the latter is deprecated. Besides these inbuilt &ldquo;Task Drivers&rdquo; there are community maintained ones too, covering Podman, LXC, Firecraker and BSD Jails, amongst others.</p><p>The one I want to talk about today, however, is called <code>exec</code>. This Task Driver runs any given executable, so if you have an application which you don&rsquo;t want (or can&rsquo;t) put into a container, you can still schedule it with Nomad. When I run demos (particularly at conferences), I try to have everything runnable without an internet connection, which means I have to make sure all the Docker containers I wish to run are within a local Docker Registry already, and, well, sometimes I forget. By using <code>exec</code>, I can serve a binary off my machine with no container overheads involved.</p><h2 id=insecurity>Insecurity?<a hidden class=anchor aria-hidden=true href=#insecurity>#</a></h2><p>Until recently, I had always considered <code>exec</code> as a tradeoff: I don&rsquo;t need a docker container, but I lose the isolation of the container, and the application I run has full access to everything on this host.</p><p>What I hadn&rsquo;t realised, is that <code>exec</code> actually uses the host operating system&rsquo;s isolation features via the <a href="https://pkg.go.dev/github.com/opencontainers/runc/libcontainer?tab=doc">libcontainer</a> package to contain the application. On Linux, this means using <code>cgroups</code> and a <code>chroot</code>, making the level of isolation roughly the same as a docker container provides.</p><p>When you specify a binary to run, it must meet a few criteria:</p><ul><li>An absolute path within Nomad&rsquo;s <code>chroot</code></li><li>A relative path within the Allocation Directory</li></ul><p>For instance, to run a dotnet core application consists of invoking <code>/usr/bin/dotnet</code> with the relative path of the dll extracted from the artifact:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>task <span style=color:#e6db74>&#34;consumer&#34;</span> {
</span></span><span style=display:flex><span>    driver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;exec&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    config {
</span></span><span style=display:flex><span>        command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/usr/bin/dotnet&#34;</span>
</span></span><span style=display:flex><span>        args <span style=color:#f92672>=</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;local/Consumer.dll&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    artifact {
</span></span><span style=display:flex><span>        source <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://s3.internal.net/consumer-dotnet.zip&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Whereas running a go binary can be done with a path relative to the allocation directory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>task <span style=color:#e6db74>&#34;consumer&#34;</span> {
</span></span><span style=display:flex><span>    driver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;exec&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    config {
</span></span><span style=display:flex><span>        command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;local/consumer&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    artifact {
</span></span><span style=display:flex><span>        source <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;http://s3.internal.net/consumer-go.zip&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But what happens if we want to run a binary which is not within the default chroot environment used by <code>exec</code>?</p><h2 id=configuring-the-chroot-environment>Configuring The chroot Environment<a hidden class=anchor aria-hidden=true href=#configuring-the-chroot-environment>#</a></h2><p>By default, Nomad links the following paths into the task&rsquo;s chroot:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>[
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/bin&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/etc&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/lib&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/lib32&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/lib64&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/run/resolvconf&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/sbin&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/usr&#34;</span>
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>We can configure the <code>chroot</code> per Nomad client, meaning we can provision nodes with different capabilities if necessary. This is done with the <code>chroot_env</code> setting in the client&rsquo;s configuration file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>client {
</span></span><span style=display:flex><span>  chroot_env {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/bin&#34;</span>            <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/bin&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/etc&#34;</span>            <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/etc&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/lib&#34;</span>            <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/lib&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/lib32&#34;</span>          <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/lib32&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/lib64&#34;</span>          <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/lib64&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/run/resolvconf&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/run/resolvconf&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/sbin&#34;</span>           <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/sbin&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/usr&#34;</span>            <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/usr&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/vagrant&#34;</span>        <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/vagrant&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In this case, I have added in the <code>/vagrant</code> path, which is useful as I usually provision a Nomad cluster using <a href=https://vagrantup.com>Vagrant</a>, and thus have all my binaries etc. available in <code>/vagrant</code>. It means that my <code>.nomad</code> files for the demo have something like this for their tasks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>task <span style=color:#e6db74>&#34;dashboard&#34;</span> {
</span></span><span style=display:flex><span>    driver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;exec&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    config {
</span></span><span style=display:flex><span>        command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/vagrant/apps/bin/dashboard&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Meaning I don&rsquo;t need to host a Docker Registry, or HTTP server to expose my applications to the Nomad cluster.</p><h2 id=need-full-access>Need Full Access?<a hidden class=anchor aria-hidden=true href=#need-full-access>#</a></h2><p>If you need full access to the host machine, you can use the non-isolating version of <code>exec</code>, called <code>raw_exec</code>. <code>raw_exec</code> works in the same way as <code>exec</code>, but without using <code>cgroups</code> and <code>chroot</code>. As this would be a security risk, it must be enabled on each Nomad client:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>client {
</span></span><span style=display:flex><span>    enabled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>plugin <span style=color:#e6db74>&#34;raw_exec&#34;</span> {
</span></span><span style=display:flex><span>    config {
</span></span><span style=display:flex><span>        enabled <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>One of the many reasons I like Nomad is its simplicity, especially when compared to something as big and complex as Kubernetes. Whenever I look into how Nomad works, I always seem to come away with the feeling that it has been well thought out, and how flexible it is because of this.</p><p>Being able to configure the chroot used by the Nomad clients means I can simplify my various demos further, as I can remove the need to have a webserver for an artifact source. As always, the less accidental complexity you have in your system, the better.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/infrastructure/>infrastructure</a></li><li><a href=https://andydote.co.uk/tags/nomad/>nomad</a></li><li><a href=https://andydote.co.uk/tags/docker/>docker</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2020/03/15/observability-without-honeycomb/><span class=title>« Prev Page</span><br><span>Observability Without Honeycomb</span></a>
<a class=next href=https://andydote.co.uk/2019/12/30/consul-alpine-dns-revisited/><span class=title>Next Page »</span><br><span>Consul DNS Fowarding in Alpine, revisited</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>