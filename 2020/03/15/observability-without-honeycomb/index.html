<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Observability Without Honeycomb | Andy Dote</title><meta name=keywords content="observability,honeycomb,elk,monitoring"><meta name=description content="Before I start on this, I want to make it clear that if you can buy Honeycomb, you should. Outlined below is how I started to add observability to an existing codebase which already had the ELK stack available, and was unable to use Honeycomb. My hope, in this case, is that I can demonstrate how much value observability gives, and also show how much more value you would get with an excellent tool, such as Honeycomb."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2020/03/15/observability-without-honeycomb/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2b33c247bf6959372dd097f2cfdcd9f4d5019027cd9b1e28ae3d14c17c37ac00.css integrity="sha256-KzPCR79pWTct0Jfyz9zZ9NUBkCfNmx4orj0UwXw3rAA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Observability Without Honeycomb"><meta property="og:description" content="Before I start on this, I want to make it clear that if you can buy Honeycomb, you should. Outlined below is how I started to add observability to an existing codebase which already had the ELK stack available, and was unable to use Honeycomb. My hope, in this case, is that I can demonstrate how much value observability gives, and also show how much more value you would get with an excellent tool, such as Honeycomb."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2020/03/15/observability-without-honeycomb/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-03-15T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-15T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Observability Without Honeycomb"><meta name=twitter:description content="Before I start on this, I want to make it clear that if you can buy Honeycomb, you should. Outlined below is how I started to add observability to an existing codebase which already had the ELK stack available, and was unable to use Honeycomb. My hope, in this case, is that I can demonstrate how much value observability gives, and also show how much more value you would get with an excellent tool, such as Honeycomb."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Observability Without Honeycomb","item":"https://andydote.co.uk/2020/03/15/observability-without-honeycomb/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Observability Without Honeycomb","name":"Observability Without Honeycomb","description":"Before I start on this, I want to make it clear that if you can buy Honeycomb, you should. Outlined below is how I started to add observability to an existing codebase which already had the ELK stack available, and was unable to use Honeycomb. My hope, in this case, is that I can demonstrate how much value observability gives, and also show how much more value you would get with an excellent tool, such as Honeycomb.","keywords":["observability","honeycomb","elk","monitoring"],"articleBody":"Before I start on this, I want to make it clear that if you can buy Honeycomb, you should. Outlined below is how I started to add observability to an existing codebase which already had the ELK stack available, and was unable to use Honeycomb. My hope, in this case, is that I can demonstrate how much value observability gives, and also show how much more value you would get with an excellent tool, such as Honeycomb.\nWith that said, what is observability, how is it different to logging (and metrics), and why should you care?\nIf you already know, or would rather skip to the implementation, jump to Implementing with Elastic Search.\nWhat is it? The term Observability comes from systems engineering and is how you can determine the behaviour of the entire system from its outputs. In our case, this means the events we emit while processing requests. If we look at (my) hierarchy of monitoring, you can see that it starts with logging, with the next steps up being to output structured logs, then centralising those logs (no more SSHing into random hosts), and finally onto events:\nlogs \u003c structured logs \u003c centralised structured logs \u003c events (observability)\nThe Problem with Logs and Metrics With logs, you are writing out many lines as your process runs, which has a few problems, the primary being that you are often looking for data which is absent.\nHow many times have you been looking through many lines of logs, before realising “oh, the line about cache invalidation is missing, which means…”. It is much harder to notice data which is absent than data which is present, but with an unexpected value.\nThe second problem is the size of the logs saved. Logs, especially structured ones, contain a lot of useful information, such as request ids, session ids, paths, versions, host data, and anything else interesting. The majority of these fields are repeated for every log entry in the system, and that means they need to be stored and queryable at some point. Often, this is solved by deleting historical data, or sampling at write time, both of which cause data loss, and you are back to trying to notice data which isn’t there.\nMetrics exhibit the data loss problem by design. Metrics are deliberately aggregated client-side and then shipped to storage. The numbers you get from metrics can be useful, but when you look at where they come from, it becomes evident that they are just a projection of logs themselves. How many codebases have you read where every loggger.Info(\"...\", props); line is followed (or preceded) by stats.increment(\"some_counter)?\nSo What is an Event? An Event is a structured piece of data, with as much information about the current request in it as possible. The difference is that you emit one event per request per service, if you are doing microservices. You create an event at the beginning of handling a request and send it somewhere at the end of the request (whether successful or unsuccessful).\nFor things like background tasks, again, emitting one event per execution, and in well-structured monoliths, one event per request per component.\nThis doesn’t sound like much of a difference, until you start writing your code to add interesting properties to the event, rather than log lines. We want to store as much high cardinality data as possible (so anything unique, or nearly unique), the more of it, the better, as it lets us slice and dice our events by anything at a later time (e.g. by requestid, userid, endpoint paths, url parameters, http method, etc.)\nLooking at the caching example mentioned above, before we had this:\nfunc handleRequest(request *Request) { now := time.Now() if cache[request.UserID] == nil || cache[request.UserID].IsStale(now) { logger.Write(\"Cache miss for user\", request.UserID)) stats.Increment(\"cache_misses\") fillCache(cache, request.UserID) } //... stats.set(\"request_duration\", time.Since(now)) } When the user is in the cache, there is no logline written, which is fine when everything is working. However, when something unexpected happens, like daylight savings time or sudden clock drift, and suddenly all cache entries are never stale. You have a decrease in latency (which looks good), your cache_misses counter goes down (looks good), but your data is older than you realised, and bad things are happening down the line.\nIf you were to write this function with observability in mind, you might write something like this instead:\nfunc handleRequest(request *Request) { ev := libhoney.NewEvent() defer ev.Send() now := time.Now() ev.Timestamp = now ev.Add(map[string]interface{}{ \"request_id\": request.ID, \"request_path\": request.Path, \"request_method\": request.method, \"user_id\": request.UserID, \"cache_size\": len(cache), }) userData, found := cache[request.UserID] ev.AddField(\"cache_hit\", found) if !found || userData.IsStale(now) { userData = fillCache(ev, cache, request.UserID) } ev.AddField(\"cache_expires\", userData.CacheUntil) ev.AddField(\"cache_is_stale\", userData.IsStale(now)) //... ev.AddField(\"request_duration_ms\", time.Since(now) / time.Millisecond) } The resulting event will contain enough information so that in the future when a bug is introduced, you will be able to look at your events and see that yes, while request_duration_ms has gone down and cache_hit has gone up, all the events have cache_is_stale=false with cache_expires times much older than they should be.\nSo this is the value add of Observability: Answering Unknown Unknowns; the questions you didn’t know you needed to ask.\nImplementing with Elastic Search I won’t cover how to set up and manage the ELK stack (as my opinion is that you should pay someone else to run it. Don’t waste your engineering effort.) I will assume you have a way to get information from stdout of a process into ElasticSearch somehow (I usually use piping to Filebeat, which forwards to LogStash, which processes and pushes into ElasticSearch).\nBesides, the code is the important part. This is all written in Go, but I gather you can do similar to NodeJS apps etc. We will use Honeycomb’s [Libhoney-go] package to do the heavy lifting, and supply a custom Transmission. The following is the important part of a custom stdout write (loosely based on libhoney’s WriterSender):\nfunc (w *JsonSender) Add(ev *transmission.Event) { ev.Data[\"@timestamp\"] = ev.Timestamp content, _ := json.Marshal(ev.Data) content = append(content, '\\n') w.Lock() defer w.Unlock() w.Writer.Write(content) w.SendResponse(transmission.Response{ Metadata: ev.Metadata, }) } The key difference here is that I am only serialising the .Data property of the Event, and am inserting an extra @timestamp key to make my event structure conform to the standard LogStash pattern.\nAll that remains to do is configure libhoney to use the custom sender:\nlibhoney.Init(libhoney.Config{ Transmission: \u0026JsonSender{Writer: os.Stdout}, Dataset: \"my-api\", }) Running your service, you would start to see json objects on stdout which look something like this:\n{ \"@timestamp\": \"2020-03-15T14:51:43.041744363+02:00\", \"request_id\": \"7f46b313-0a37-457c-9727-b6fdc8c87733\", \"request_path\": \"/api/user/dashboard\", \"request_method\": \"GET\", \"user_id\": \"e6baf70f-9812-4cff-94e9-80a308077955\", \"cache_size\": 86, \"cache_hit\": true, \"cache_expires\": \"2020-03-15T15:02:17.045625680+02:00\", \"cache_is_stale\": false, \"request_duration_ms\": 17 } There are no message fields for you to read, but you can see everything which happened in this method; whether the user was found in the cache, how big the cache was etc.\nNow if we push that into ElasticSearch, we can filter by any of the values in the event; in this case, I filtered by user_id and added columns for all the cache properties.\nNow everything is in one place; you can slice and dice your data and figure out what exactly is going on. You can even write some metrics off your event queries if you want!\nImprovements \u0026 Caveats The main caveat is that pushing this into ElasticSearch is not as good as what you get from Honeycomb - It is just an improvement on logging messages and enables you to demonstrate the value of observability easily.\nOnce you’ve demonstrated how useful observability is, the next step is to migrate to Honeycomb and get even more value.\nI have written the word Honeycomb a lot in this post (9 times so far), but I want to stress that it is observability that we are after and that Honeycomb is an implementation detail. It also happens to be the only real observability tooling (although Lightstep, kind of.)\nAnd let’s not get started on the “3 pillars of observability” bullshit being peddled by other vendors.\n","wordCount":"1326","inLanguage":"en","datePublished":"2020-03-15T00:00:00Z","dateModified":"2020-03-15T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2020/03/15/observability-without-honeycomb/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Observability Without Honeycomb</h1><div class=post-meta><span title='2020-03-15 00:00:00 +0000 UTC'>March 15, 2020</span>&nbsp;·&nbsp;7 min</div></header><div class=post-content><p>Before I start on this, I want to make it clear that if you can buy <a href=https://honeycomb.io>Honeycomb</a>, you <strong>should</strong>. Outlined below is how I started to add observability to an existing codebase which already had the <a href=https://www.elastic.co/what-is/elk-stack>ELK stack</a> available, and was unable to use Honeycomb. My hope, in this case, is that I can demonstrate how much value observability gives, and also show how much <em>more</em> value you would get with an excellent tool, such as Honeycomb.</p><p>With that said, what is observability, how is it different to logging (and metrics), and why should you care?</p><p>If you already know, or would rather skip to the implementation, jump to <a href=#implementing-with-elastic-search>Implementing with Elastic Search</a>.</p><h2 id=what-is-it>What is it?<a hidden class=anchor aria-hidden=true href=#what-is-it>#</a></h2><p>The term Observability comes from systems engineering and is how you can determine the behaviour of the entire system from its outputs. In our case, this means the <strong>events</strong> we emit while processing requests. If we look at (my) hierarchy of monitoring, you can see that it starts with logging, with the next steps up being to output structured logs, then centralising those logs (no more SSHing into random hosts), and finally onto events:</p><blockquote><p>logs &lt; structured logs &lt; centralised structured logs &lt; events (observability)</p></blockquote><h2 id=the-problem-with-logs-and-metrics>The Problem with Logs and Metrics<a hidden class=anchor aria-hidden=true href=#the-problem-with-logs-and-metrics>#</a></h2><p>With logs, you are writing out many lines as your process runs, which has a few problems, the primary being that you are often looking for data which is absent.</p><p>How many times have you been looking through many lines of logs, before realising &ldquo;oh, the line about cache invalidation is missing, which means&mldr;&rdquo;. It is much harder to notice data which is absent than data which is present, but with an unexpected value.</p><p>The second problem is the size of the logs saved. Logs, especially structured ones, contain a lot of useful information, such as request ids, session ids, paths, versions, host data, and anything else interesting. The majority of these fields are repeated for every log entry in the system, and that means they need to be stored and queryable at some point. Often, this is solved by deleting historical data, or sampling at write time, both of which cause data loss, and you are back to trying to notice data which isn&rsquo;t there.</p><p>Metrics exhibit the data loss problem <em>by design</em>. Metrics are deliberately aggregated client-side and then shipped to storage. The numbers you get from metrics can be useful, but when you look at where they come from, it becomes evident that they are just a projection of logs themselves. How many codebases have you read where every <code>loggger.Info("...", props);</code> line is followed (or preceded) by <code>stats.increment("some_counter)</code>?</p><h2 id=so-what-is-an-event>So What is an Event?<a hidden class=anchor aria-hidden=true href=#so-what-is-an-event>#</a></h2><p>An Event is a structured piece of data, with as much information about the current request in it as possible. The difference is that you emit <strong>one</strong> event per request <strong>per service</strong>, if you are doing microservices. You create an event at the beginning of handling a request and send it somewhere at the end of the request (whether successful or unsuccessful).</p><p>For things like background tasks, again, emitting one event per execution, and in well-structured monoliths, one event per request per component.</p><p>This doesn&rsquo;t sound like much of a difference, until you start writing your code to add interesting properties to the event, rather than log lines. We want to store as much high cardinality data as possible (so anything unique, or nearly unique), the more of it, the better, as it lets us slice and dice our events by anything at a later time (e.g. by requestid, userid, endpoint paths, url parameters, http method, etc.)</p><p>Looking at the caching example mentioned above, before we had this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleRequest</span>(<span style=color:#a6e22e>request</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>now</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cache</span>[<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>] <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>cache</span>[<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>].<span style=color:#a6e22e>IsStale</span>(<span style=color:#a6e22e>now</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#e6db74>&#34;Cache miss for user&#34;</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>Increment</span>(<span style=color:#e6db74>&#34;cache_misses&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fillCache</span>(<span style=color:#a6e22e>cache</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>set</span>(<span style=color:#e6db74>&#34;request_duration&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>now</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When the user is in the cache, there is no logline written, which is fine when everything is working. However, when something unexpected happens, like daylight savings time or sudden clock drift, and suddenly all cache entries are never stale. You have a decrease in latency (which looks good), your <code>cache_misses</code> counter goes down (looks good), but your data is older than you realised, and bad things are happening down the line.</p><p>If you were to write this function with observability in mind, you might write something like this instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>handleRequest</span>(<span style=color:#a6e22e>request</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>libhoney</span>.<span style=color:#a6e22e>NewEvent</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Send</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>now</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Timestamp</span> = <span style=color:#a6e22e>now</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;request_id&#34;</span>: <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>ID</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;request_path&#34;</span>: <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>Path</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;request_method&#34;</span>: <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>method</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;user_id&#34;</span>: <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;cache_size&#34;</span>: len(<span style=color:#a6e22e>cache</span>),
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>userData</span>, <span style=color:#a6e22e>found</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cache</span>[<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;cache_hit&#34;</span>, <span style=color:#a6e22e>found</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>found</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>userData</span>.<span style=color:#a6e22e>IsStale</span>(<span style=color:#a6e22e>now</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>userData</span> = <span style=color:#a6e22e>fillCache</span>(<span style=color:#a6e22e>ev</span>, <span style=color:#a6e22e>cache</span>, <span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>UserID</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;cache_expires&#34;</span>, <span style=color:#a6e22e>userData</span>.<span style=color:#a6e22e>CacheUntil</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;cache_is_stale&#34;</span>, <span style=color:#a6e22e>userData</span>.<span style=color:#a6e22e>IsStale</span>(<span style=color:#a6e22e>now</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;request_duration_ms&#34;</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Since</span>(<span style=color:#a6e22e>now</span>) <span style=color:#f92672>/</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Millisecond</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The resulting event will contain enough information so that in the future when a bug is introduced, you will be able to look at your events and see that yes, while <code>request_duration_ms</code> has gone down and <code>cache_hit</code> has gone up, all the events have <code>cache_is_stale=false</code> with <code>cache_expires</code> times much older than they should be.</p><p>So this is the value add of Observability: Answering Unknown Unknowns; the questions you didn&rsquo;t know you needed to ask.</p><h2 id=implementing-with-elastic-search>Implementing with Elastic Search<a hidden class=anchor aria-hidden=true href=#implementing-with-elastic-search>#</a></h2><p>I won&rsquo;t cover how to set up and manage the ELK stack (as my opinion is that you should pay someone else to run it. Don&rsquo;t waste your engineering effort.) I will assume you have a way to get information from <code>stdout</code> of a process into ElasticSearch somehow (I usually use piping to <a href=https://www.elastic.co/beats/filebeat>Filebeat</a>, which forwards to <a href=https://www.elastic.co/logstash>LogStash</a>, which processes and pushes into <a href=https://www.elastic.co/elasticsearch/>ElasticSearch</a>).</p><p>Besides, the code is the important part. This is all written in Go, but I gather you can do similar to NodeJS apps etc. We will use Honeycomb&rsquo;s [Libhoney-go] package to do the heavy lifting, and supply a custom <code>Transmission</code>. The following is the important part of a custom stdout write (loosely based on libhoney&rsquo;s <code>WriterSender</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>w</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>JsonSender</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>ev</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>transmission</span>.<span style=color:#a6e22e>Event</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Data</span>[<span style=color:#e6db74>&#34;@timestamp&#34;</span>] = <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Timestamp</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>content</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Data</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>content</span> = append(<span style=color:#a6e22e>content</span>, <span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Writer</span>.<span style=color:#a6e22e>Write</span>(<span style=color:#a6e22e>content</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>SendResponse</span>(<span style=color:#a6e22e>transmission</span>.<span style=color:#a6e22e>Response</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Metadata</span>: <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Metadata</span>,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The key difference here is that I am only serialising the <code>.Data</code> property of the Event, and am inserting an extra <code>@timestamp</code> key to make my event structure conform to the standard LogStash pattern.</p><p>All that remains to do is configure libhoney to use the custom sender:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>libhoney</span>.<span style=color:#a6e22e>Init</span>(<span style=color:#a6e22e>libhoney</span>.<span style=color:#a6e22e>Config</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Transmission</span>: <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>JsonSender</span>{<span style=color:#a6e22e>Writer</span>: <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdout</span>},
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Dataset</span>:      <span style=color:#e6db74>&#34;my-api&#34;</span>,
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Running your service, you would start to see json objects on stdout which look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;@timestamp&#34;</span>: <span style=color:#e6db74>&#34;2020-03-15T14:51:43.041744363+02:00&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;request_id&#34;</span>: <span style=color:#e6db74>&#34;7f46b313-0a37-457c-9727-b6fdc8c87733&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;request_path&#34;</span>: <span style=color:#e6db74>&#34;/api/user/dashboard&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;request_method&#34;</span>: <span style=color:#e6db74>&#34;GET&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;user_id&#34;</span>: <span style=color:#e6db74>&#34;e6baf70f-9812-4cff-94e9-80a308077955&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;cache_size&#34;</span>: <span style=color:#ae81ff>86</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;cache_hit&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;cache_expires&#34;</span>: <span style=color:#e6db74>&#34;2020-03-15T15:02:17.045625680+02:00&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;cache_is_stale&#34;</span>: <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;request_duration_ms&#34;</span>: <span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are no message fields for you to read, but you can see everything which happened in this method; whether the user was found in the cache, how big the cache was etc.</p><p>Now if we push that into ElasticSearch, we can filter by any of the values in the event; in this case, I filtered by <code>user_id</code> and added columns for all the cache properties.</p><p><img loading=lazy src=observability-elk.png alt="Kibana Screenshot"></p><p>Now everything is in one place; you can slice and dice your data and figure out what exactly is going on. You can even write some metrics off your event queries if you want!</p><h2 id=improvements--caveats>Improvements & Caveats<a hidden class=anchor aria-hidden=true href=#improvements--caveats>#</a></h2><p>The main caveat is that pushing this into ElasticSearch is not as good as what you get from Honeycomb - It is just an improvement on logging messages and enables you to demonstrate the value of observability easily.</p><p>Once you&rsquo;ve demonstrated how useful observability is, the next step is to migrate to Honeycomb and get even more value.</p><p>I have written the word Honeycomb a lot in this post (9 times so far), but I want to stress that it is observability that we are after and that Honeycomb is an implementation detail. It also happens to be the only real observability tooling (although <a href=https://lightstep.com/>Lightstep</a>, kind of.)</p><p>And let&rsquo;s not get started on the &ldquo;3 pillars of observability&rdquo; bullshit being peddled by other vendors.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/observability/>observability</a></li><li><a href=https://andydote.co.uk/tags/honeycomb/>honeycomb</a></li><li><a href=https://andydote.co.uk/tags/elk/>elk</a></li><li><a href=https://andydote.co.uk/tags/monitoring/>monitoring</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/><span class=title>« Prev Page</span><br><span>Service Mesh with Consul Connect (and Nomad)</span></a>
<a class=next href=https://andydote.co.uk/2020/02/29/nomad-isolated-exec/><span class=title>Next Page »</span><br><span>Nomad Isolated Exec</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>