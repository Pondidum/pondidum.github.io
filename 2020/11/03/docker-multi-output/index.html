<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Forking Multi Container Docker Builds | Andy Dote</title><meta name=keywords content="docker"><meta name=description content="Following on from my last post on Isolated Multistage Docker Builds, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.
The Problem When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.
For example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2020/11/03/docker-multi-output/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4ac25d88867f6882d86478d9b478a3d3efa1ed9e18f0bc5e432812301516cb28.css integrity="sha256-SsJdiIZ/aILYZHjZtHij0++h7Z4Y8LxeQygSMBUWyyg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Forking Multi Container Docker Builds"><meta property="og:description" content="Following on from my last post on Isolated Multistage Docker Builds, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.
The Problem When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.
For example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2020/11/03/docker-multi-output/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-03T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Forking Multi Container Docker Builds"><meta name=twitter:description content="Following on from my last post on Isolated Multistage Docker Builds, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.
The Problem When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.
For example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Forking Multi Container Docker Builds","item":"https://andydote.co.uk/2020/11/03/docker-multi-output/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Forking Multi Container Docker Builds","name":"Forking Multi Container Docker Builds","description":"Following on from my last post on Isolated Multistage Docker Builds, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.\nThe Problem When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.\nFor example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving.","keywords":["docker"],"articleBody":"Following on from my last post on Isolated Multistage Docker Builds, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.\nThe Problem When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.\nFor example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving. One of the reasons to do this is separation of concerns: I don’t want to put my backend code where it doesn’t need to be. There is also, in this case, the fact that the backend code and nginx version need different base containers, meaning deploying the same container twice won’t work.\nSo let’s see how we solve this!\nCreating Separate Dockerfiles The first dockerfile to write is the common base, which I name Dockerfile.builder. This is the same as the previous post - we are assuming that the yarn ci:build step transpiles the typescript, and generates the static assets for our application.\nFROM node:15.0.1-alpine3.12 as builder WORKDIR /app COPY . ./ RUN yarn install --frozen-lockfile \u0026\u0026 yarn cache clean RUN yarn ci:build Next up is the server container, which will be in the Dockerfile.backend file, as try to name the files based on their purpose, rather than their technology used. As in the previous post, this installs the production dependencies for the application, and copies in the compiled output from the builder stage:\nARG builder_image FROM ${builder_image} as builder FROM node:15.0.1-alpine3.12 as output WORKDIR /app COPY package.json yarn.lock /app RUN yarn install --frozen-lockfile --production \u0026\u0026 yarn cache clean COPY --from builder /app/dist /app Now let’s deal with the Dockerfile.frontend. This uses nginx:1.19.3-alpine as a base, and copies in the nginx.conf file from the host, and the static assets directory from the builder container:\nARG builder_image FROM ${builder_image} as builder FROM nginx:1.19.3-alpine as output COPY ./nginx.conf /etc/nginx/nginx.conf COPY --from builder /app/dist/static /app Building Containers The reason we rely on the builder stage rather than the backend output stage is that we are now decoupled from layout/structural changes in that container, and we gain the ability to run the builds in parallel too (the \u0026 at the end of the lines), for a bit of a speed up on our build agents:\nversion=\"${GIT_COMMIT:0:7}\" builder_tag=\"builder:$version\" docker build --file Dockerfile.builder -t \"$builder_tag\" . # run the builder container here to do tests, lint, static analysis etc. docker build --file dockerfile.backend --build-arg \"builder_image=$builder_tag\" -t backend:$version . \u0026 docker build --file Dockerfile.frontend --build-arg \"builder_image=$builder_tag\" -t frontend:$version . \u0026 wait The result of this is 3 containers, all labled with the short version of the current git commit:\nbuilder:abc123e - contains all packages, compiled output backend:abc123e - node based, contains the node backend and static assets frontend:abc123e - nginx based, contains the static assets I can now publish the builder internally (so it can be cloned before builds for caching and speed), and deploy the backend and frontend to their different locations.\n","wordCount":"515","inLanguage":"en","datePublished":"2020-11-03T00:00:00Z","dateModified":"2020-11-03T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2020/11/03/docker-multi-output/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Forking Multi Container Docker Builds</h1><div class=post-meta><span title='2020-11-03 00:00:00 +0000 UTC'>November 3, 2020</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>Following on from <a href=/2020/11/01/docker-multistage-containers/>my last post on Isolated Multistage Docker Builds</a>, I thought it would be useful to cover another advantage to splitting your dockerfiles: building different output containers from a common base.</p><h2 id=the-problem>The Problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h2><p>When I have an application which when built, needs to have all assets in one container, and a subset of assets in a second container.</p><p>For example, writing a node webapp, where you want the compiled/bundled static assets available in the container as a fallback, and also stored in an nginx container for serving. One of the reasons to do this is separation of concerns: I don&rsquo;t want to put my backend code where it doesn&rsquo;t need to be. There is also, in this case, the fact that the backend code and nginx version need different base containers, meaning deploying the same container twice won&rsquo;t work.</p><p>So let&rsquo;s see how we solve this!</p><h2 id=creating-separate-dockerfiles>Creating Separate Dockerfiles<a hidden class=anchor aria-hidden=true href=#creating-separate-dockerfiles>#</a></h2><p>The first dockerfile to write is the common base, which I name <code>Dockerfile.builder</code>. This is the same as the previous post - we are assuming that the <code>yarn ci:build</code> step transpiles the typescript, and generates the static assets for our application.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> node:15.0.1-alpine3.12 as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> yarn install --frozen-lockfile <span style=color:#f92672>&amp;&amp;</span> yarn cache clean<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> yarn ci:build<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Next up is the server container, which will be in the <code>Dockerfile.backend</code> file, as try to name the files based on their purpose, rather than their technology used. As in the previous post, this installs the production dependencies for the application, and copies in the compiled output from the <code>builder</code> stage:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ARG</span> builder_image<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ${builder_image} as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> node:15.0.1-alpine3.12 as output</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> package.json yarn.lock /app<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> yarn install --frozen-lockfile --production <span style=color:#f92672>&amp;&amp;</span> yarn cache clean<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from builder /app/dist /app<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Now let&rsquo;s deal with the <code>Dockerfile.frontend</code>. This uses <code>nginx:1.19.3-alpine</code> as a base, and copies in the <code>nginx.conf</code> file from the host, and the static assets directory from the <code>builder</code> container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>ARG</span> builder_image<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ${builder_image} as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> nginx:1.19.3-alpine as output</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./nginx.conf /etc/nginx/nginx.conf<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from builder /app/dist/static /app<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h2 id=building-containers>Building Containers<a hidden class=anchor aria-hidden=true href=#building-containers>#</a></h2><p>The reason we rely on the <code>builder</code> stage rather than the <code>backend</code> output stage is that we are now decoupled from layout/structural changes in that container, and we gain the ability to run the builds in parallel too (the <code>&</code> at the end of the lines), for a bit of a speed up on our build agents:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>version<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>GIT_COMMIT:0:7<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>builder_tag<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;builder:</span>$version<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker build --file Dockerfile.builder -t <span style=color:#e6db74>&#34;</span>$builder_tag<span style=color:#e6db74>&#34;</span> .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># run the builder container here to do tests, lint, static analysis etc.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker build --file dockerfile.backend --build-arg <span style=color:#e6db74>&#34;builder_image=</span>$builder_tag<span style=color:#e6db74>&#34;</span> -t backend:$version . &amp;
</span></span><span style=display:flex><span>docker build --file Dockerfile.frontend --build-arg <span style=color:#e6db74>&#34;builder_image=</span>$builder_tag<span style=color:#e6db74>&#34;</span> -t frontend:$version . &amp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wait
</span></span></code></pre></div><p>The result of this is 3 containers, all labled with the short version of the current git commit:</p><ul><li><code>builder:abc123e</code> - contains all packages, compiled output</li><li><code>backend:abc123e</code> - node based, contains the node backend and static assets</li><li><code>frontend:abc123e</code> - nginx based, contains the static assets</li></ul><p>I can now publish the builder internally (so it can be cloned before builds for <a href=/2020/05/14/docker-layer-sharing/>caching and speed</a>), and deploy the <code>backend</code> and <code>frontend</code> to their different locations.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/docker/>docker</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2021/03/01/observability-with-infrastructure-as-code/><span class=title>« Prev Page</span><br><span>Observability with Infrastructure as Code</span></a>
<a class=next href=https://andydote.co.uk/2020/11/01/docker-multistage-containers/><span class=title>Next Page »</span><br><span>Isolated Docker Multistage Images</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>