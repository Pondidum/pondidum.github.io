<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Better BASHing Through Technology | Andy Dote</title><meta name=keywords content="bash"><meta name=description content="I write a lot of bash scripts for both my day job and my personal projects, and while they are functional, bash scripts always seem to lack that structure that I want, especially when compared to writing something in Go or C#. The main problem I have with bash scripts is that when I use functions, I lose the ability to log things.
For example the get_config_path function will print the path to the configuration file, which will get consumed by the do_work function:"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2020/08/28/better-bashing-through-technology/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4ac25d88867f6882d86478d9b478a3d3efa1ed9e18f0bc5e432812301516cb28.css integrity="sha256-SsJdiIZ/aILYZHjZtHij0++h7Z4Y8LxeQygSMBUWyyg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Better BASHing Through Technology"><meta property="og:description" content="I write a lot of bash scripts for both my day job and my personal projects, and while they are functional, bash scripts always seem to lack that structure that I want, especially when compared to writing something in Go or C#. The main problem I have with bash scripts is that when I use functions, I lose the ability to log things.
For example the get_config_path function will print the path to the configuration file, which will get consumed by the do_work function:"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2020/08/28/better-bashing-through-technology/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-08-28T00:00:00+00:00"><meta property="article:modified_time" content="2020-08-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Better BASHing Through Technology"><meta name=twitter:description content="I write a lot of bash scripts for both my day job and my personal projects, and while they are functional, bash scripts always seem to lack that structure that I want, especially when compared to writing something in Go or C#. The main problem I have with bash scripts is that when I use functions, I lose the ability to log things.
For example the get_config_path function will print the path to the configuration file, which will get consumed by the do_work function:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Better BASHing Through Technology","item":"https://andydote.co.uk/2020/08/28/better-bashing-through-technology/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Better BASHing Through Technology","name":"Better BASHing Through Technology","description":"I write a lot of bash scripts for both my day job and my personal projects, and while they are functional, bash scripts always seem to lack that structure that I want, especially when compared to writing something in Go or C#. The main problem I have with bash scripts is that when I use functions, I lose the ability to log things.\nFor example the get_config_path function will print the path to the configuration file, which will get consumed by the do_work function:","keywords":["bash"],"articleBody":"I write a lot of bash scripts for both my day job and my personal projects, and while they are functional, bash scripts always seem to lack that structure that I want, especially when compared to writing something in Go or C#. The main problem I have with bash scripts is that when I use functions, I lose the ability to log things.\nFor example the get_config_path function will print the path to the configuration file, which will get consumed by the do_work function:\nget_config_path() { echo \"Finding Machine Configurtaion\" if [ -n \"$CONFIG_PATH\" ] \u0026\u0026 [ -e \"$CONFIG_PATH\" ]; then # echo \"Using Configuration from environment\" echo \"$CONFIG_PATH\" return fi if [ -e \"~/.config/demo/config.toml\" ]; then # echo \"Using Configuration directory file\" echo \"~/.config/demo/config.toml\" return fi # echo \"Unable to find configuration\" exit 1 } do_work() { local -r config=$(get_config_path) # actual work... } The problem is, if I include the echo statements which are log lines, the config variable in the do_work function will contain them too.\nIn the past, this has caused me to use functions in bash very sparingly; usually with things that are short that I don’t need to add much logging to. However, I was recently building some AMIs, and happened to be browsing the Consul and Vault terraform module source, which uses several bash scripts which are written in a different style, which makes them vastly more maintainable.\nSo let’s have a look at the new structure I use, which is heavily based off these scripts.\nBetter Bash Scripts Before we get to the implementation, make sure you are using ShellCheck it provides static analysis of your scripts, pointing out many things like missing quotes, or incorrectly handling arrays. It has plugins for all your favourite editors too.\n0. General Styles and Constructs All variables should be declared readonly, and local if possible, to help prevent surprise values from being present if other functions forget to do the same.\n#top level readonly SCRIPT_NAME=\"$(basename \"$0\")\" some_method() { # within a method local -r config_path=\"$1\" } Functions should assign their passed arguments to named variables as the first thing they do, preferably matching the variable name they are passed, which helps later when you are searching through a script for usages of “config_file” and not having to find other names/aliases for the same value.\nread_config() { local -r config_file=\"$1\" local -r skip_validation=\"$2\" # ... } invoke() { # ... read_config \"$config_file\" \"$skip_validation\" } 1. Error Handling It should go without saying, but you really need to start your scripts with the following:\n#!/bin/bash set -euo pipefail; There are many better articles on what these specifically do, but suffice to say:\ne causes the script to stop on errors u causes it to error on undefined variables being used o pipefail causes a non-zero exit code from any command in a pipeline to fail the script too (rather than just the last command.) 2. Logging The real advantage of this structure is we get to have log statements! This is achieved by doing all logging to stderr instead of stdout. We use a standardised log function across all the scripts, which also includes the script’s name so when calling other scripts you can see which one wrote the log line:\nreadonly SCRIPT_NAME=\"$(basename \"$0\")\" log() { local -r level=\"$1\" local -r message=\"$2\" local -r timestamp=$(date +\"%Y-%m-%d %H:%M:%S\") \u003e\u00262 echo -e \"${timestamp} [${level}] [$SCRIPT_NAME] ${message}\" } Invoking the function is log \"INFO\" \"Some status\" or log \"WARN\" \"Something concerning\" etc.\n3. Error Checking We have some standard assertion functions which are used by the script when starting up to validate arguments:\nassert_not_empty() { local -r arg_name=\"$1\" local -r arg_value=\"$2\" if [[ -z \"$arg_value\" ]]; then log \"ERROR\" \"The value for '$arg_name' cannot be empty\" exit 1 fi } assert_is_installed() { local -r name=\"$1\" if [[ ! $(command -v \"$name\") ]]; then log \"ERROR\" \"The binary '$name' is required by this script but is not installed or in the system's PATH.\" exit 1 fi } 4. Argument parsing When scripts need to take parameters in, I prefer to use long-flag style, as they are little more readable for people checking invocations again in the future. This function is usually always called run, and is the last function defined, and is invoked immediately after definition, passing in all script arguments (run \"$@\"):\nrun() { local namespace=\"\" local suffix=\"\" local dry_run=\"false\" while [[ $# -gt 0 ]]; do local key=\"$1\" case \"$key\" in --namespace) namespace=\"$2\" shift ;; --suffix) assert_not_empty \"$key\" \"$2\" suffix=\"$2\" shift ;; --dry-run) dry_run=\"true\" ;; --help) print_usage exit ;; *) log \"ERROR\" \"Unrecognized argument: $key\" print_usage exit 1 ;; esac shift done # mandatory flag validation assert_not_empty \"--namespace\" \"$namespace\" # make sure tools are installed assert_is_installed \"vault\" assert_is_installed \"openssl\" assert_is_installed \"jq\" # do the work! local -r cert=$(generate_cert \"$suffix\") store_cert \"$namespace\" \"$cert\" \"$dry_run\" } run \"$@\" The validation uses the assert_not_empty function defined above, which is used in two ways: after the while loop to check mandatory values have been filled in, and within the case statement for optional flags values.\nWe also use assert_is_installed to validate that utilities we need are installed, such as vault, openssl and jq\nThe print_usage function is just a set of echo statements giving all the flags, and an example of invokation:\nprint_usage() { echo echo \"Usage: $SCRIPT_NAME [OPTIONS]\" echo echo \"This script creates a new certiticate, and it installs it into the right namespace\" echo echo \"Options:\" echo echo -e \" --namespace\\tThe namespace to install the certificate in\" echo -e \" --suffix\\tAn optional suffix for the hostname\" echo -e \" --dry-run\\tDon't install the certificate\" echo echo \"Example:\" echo echo \" $SCRIPT_NAME --namespace test --dry-run\" } Usage I keep a single template file which has all of this written into it, and new scripts start off with a copy-paste of the template. Could it be DRYer? Sure, but then I have to deal with dependency management, and it’s just not worth the hassle and overhead.\n","wordCount":"992","inLanguage":"en","datePublished":"2020-08-28T00:00:00Z","dateModified":"2020-08-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2020/08/28/better-bashing-through-technology/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Better BASHing Through Technology</h1><div class=post-meta><span title='2020-08-28 00:00:00 +0000 UTC'>August 28, 2020</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><p>I write a lot of bash scripts for both my day job and my personal projects, and while they are functional, bash scripts always seem to lack that structure that I want, especially when compared to writing something in Go or C#. The main problem I have with bash scripts is that when I use functions, I lose the ability to log things.</p><p>For example the <code>get_config_path</code> function will print the path to the configuration file, which will get consumed by the <code>do_work</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>get_config_path<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Finding Machine Configurtaion&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -n <span style=color:#e6db74>&#34;</span>$CONFIG_PATH<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>[</span> -e <span style=color:#e6db74>&#34;</span>$CONFIG_PATH<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># echo &#34;Using Configuration from environment&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;</span>$CONFIG_PATH<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -e <span style=color:#e6db74>&#34;~/.config/demo/config.toml&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># echo &#34;Using Configuration directory file&#34;</span>
</span></span><span style=display:flex><span>    echo <span style=color:#e6db74>&#34;~/.config/demo/config.toml&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># echo &#34;Unable to find configuration&#34;</span>
</span></span><span style=display:flex><span>  exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>do_work<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local -r config<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>get_config_path<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># actual work...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>The problem is, if I include the <code>echo</code> statements which are log lines, the <code>config</code> variable in the <code>do_work</code> function will contain them too.</p><p>In the past, this has caused me to use functions in bash very sparingly; usually with things that are short that I don&rsquo;t need to add much logging to. However, I was recently building some AMIs, and happened to be browsing the <a href=https://github.com/hashicorp/terraform-aws-consul>Consul</a> and <a href=https://github.com/hashicorp/terraform-aws-vault>Vault</a> terraform module source, which uses several bash scripts which are written in a different style, which makes them vastly more maintainable.</p><p>So let&rsquo;s have a look at the new structure I use, which is heavily based off these scripts.</p><h2 id=better-bash-scripts>Better Bash Scripts<a hidden class=anchor aria-hidden=true href=#better-bash-scripts>#</a></h2><p>Before we get to the implementation, make sure you are using <a href=https://github.com/koalaman/shellcheck/>ShellCheck</a> it provides static analysis of your scripts, pointing out many things like missing quotes, or incorrectly handling arrays. It has plugins for all your favourite editors too.</p><h3 id=0-general-styles-and-constructs>0. General Styles and Constructs<a hidden class=anchor aria-hidden=true href=#0-general-styles-and-constructs>#</a></h3><p>All variables should be declared <code>readonly</code>, and <code>local</code> if possible, to help prevent surprise values from being present if other functions forget to do the same.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#top level</span>
</span></span><span style=display:flex><span>readonly SCRIPT_NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>basename <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>some_method<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># within a method</span>
</span></span><span style=display:flex><span>  local -r config_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Functions should assign their passed arguments to named variables as the first thing they do, preferably matching the variable name they are passed, which helps later when you are searching through a script for usages of &ldquo;config_file&rdquo; and not having to find other names/aliases for the same value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>read_config<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local -r config_file<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  local -r skip_validation<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>invoke<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  read_config <span style=color:#e6db74>&#34;</span>$config_file<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$skip_validation<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=1-error-handling>1. Error Handling<a hidden class=anchor aria-hidden=true href=#1-error-handling>#</a></h3><p>It should go without saying, but you really need to start your scripts with the following:</p><pre tabindex=0><code>#!/bin/bash

set -euo pipefail;
</code></pre><p>There are <a href=https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/>many better articles</a> on what these specifically do, but suffice to say:</p><ul><li><code>e</code> causes the script to stop on errors</li><li><code>u</code> causes it to error on undefined variables being used</li><li><code>o pipefail</code> causes a non-zero exit code from any command in a pipeline to fail the script too (rather than just the last command.)</li></ul><h3 id=2-logging>2. Logging<a hidden class=anchor aria-hidden=true href=#2-logging>#</a></h3><p>The real advantage of this structure is we get to have log statements! This is achieved by doing all logging to <code>stderr</code> instead of <code>stdout</code>. We use a standardised <code>log</code> function across all the scripts, which also includes the script&rsquo;s name so when calling other scripts you can see which one wrote the log line:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>readonly SCRIPT_NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>basename <span style=color:#e6db74>&#34;</span>$0<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>log<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local -r level<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  local -r message<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  local -r timestamp<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>date +<span style=color:#e6db74>&#34;%Y-%m-%d %H:%M:%S&#34;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  &gt;&amp;<span style=color:#ae81ff>2</span> echo -e <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>timestamp<span style=color:#e6db74>}</span><span style=color:#e6db74> [</span><span style=color:#e6db74>${</span>level<span style=color:#e6db74>}</span><span style=color:#e6db74>] [</span>$SCRIPT_NAME<span style=color:#e6db74>] </span><span style=color:#e6db74>${</span>message<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Invoking the function is <code>log "INFO" "Some status"</code> or <code>log "WARN" "Something concerning"</code> etc.</p><h3 id=3-error-checking>3. Error Checking<a hidden class=anchor aria-hidden=true href=#3-error-checking>#</a></h3><p>We have some standard assertion functions which are used by the script when starting up to validate arguments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>assert_not_empty<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local -r arg_name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  local -r arg_value<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> -z <span style=color:#e6db74>&#34;</span>$arg_value<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    log <span style=color:#e6db74>&#34;ERROR&#34;</span> <span style=color:#e6db74>&#34;The value for &#39;</span>$arg_name<span style=color:#e6db74>&#39; cannot be empty&#34;</span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>assert_is_installed<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local -r name<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> ! <span style=color:#66d9ef>$(</span>command -v <span style=color:#e6db74>&#34;</span>$name<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    log <span style=color:#e6db74>&#34;ERROR&#34;</span> <span style=color:#e6db74>&#34;The binary &#39;</span>$name<span style=color:#e6db74>&#39; is required by this script but is not installed or in the system&#39;s PATH.&#34;</span>
</span></span><span style=display:flex><span>    exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h3 id=4-argument-parsing>4. Argument parsing<a hidden class=anchor aria-hidden=true href=#4-argument-parsing>#</a></h3><p>When scripts need to take parameters in, I prefer to use long-flag style, as they are little more readable for people checking invocations again in the future. This function is usually always called <code>run</code>, and is the last function defined, and is invoked immediately after definition, passing in all script arguments (<code>run "$@"</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>run<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  local namespace<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>  local suffix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>  local dry_run<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;false&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> <span style=color:#f92672>[[</span> $# -gt <span style=color:#ae81ff>0</span> <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    local key<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$1<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;</span>$key<span style=color:#e6db74>&#34;</span> in
</span></span><span style=display:flex><span>      --namespace<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        namespace<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        shift
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>      --suffix<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        assert_not_empty <span style=color:#e6db74>&#34;</span>$key<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        suffix<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span>$2<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        shift
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>      --dry-run<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        dry_run<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;true&#34;</span>
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>      --help<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        print_usage
</span></span><span style=display:flex><span>        exit
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>      *<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        log <span style=color:#e6db74>&#34;ERROR&#34;</span> <span style=color:#e6db74>&#34;Unrecognized argument: </span>$key<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        print_usage
</span></span><span style=display:flex><span>        exit <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        ;;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>esac</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shift
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># mandatory flag validation</span>
</span></span><span style=display:flex><span>  assert_not_empty <span style=color:#e6db74>&#34;--namespace&#34;</span> <span style=color:#e6db74>&#34;</span>$namespace<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># make sure tools are installed</span>
</span></span><span style=display:flex><span>  assert_is_installed <span style=color:#e6db74>&#34;vault&#34;</span>
</span></span><span style=display:flex><span>  assert_is_installed <span style=color:#e6db74>&#34;openssl&#34;</span>
</span></span><span style=display:flex><span>  assert_is_installed <span style=color:#e6db74>&#34;jq&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># do the work!</span>
</span></span><span style=display:flex><span>  local -r cert<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>generate_cert <span style=color:#e6db74>&#34;</span>$suffix<span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  store_cert <span style=color:#e6db74>&#34;</span>$namespace<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$cert<span style=color:#e6db74>&#34;</span> <span style=color:#e6db74>&#34;</span>$dry_run<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>run <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span></code></pre></div><p>The validation uses the <code>assert_not_empty</code> function defined above, which is used in two ways: after the <code>while</code> loop to check mandatory values have been filled in, and within the <code>case</code> statement for optional flags values.</p><p>We also use <code>assert_is_installed</code> to validate that utilities we need are installed, such as <code>vault</code>, <code>openssl</code> and <code>jq</code></p><p>The <code>print_usage</code> function is just a set of <code>echo</code> statements giving all the flags, and an example of invokation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>print_usage<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  echo
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Usage: </span>$SCRIPT_NAME<span style=color:#e6db74> [OPTIONS]&#34;</span>
</span></span><span style=display:flex><span>  echo
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;This script creates a new certiticate, and it installs it into the right namespace&#34;</span>
</span></span><span style=display:flex><span>  echo
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Options:&#34;</span>
</span></span><span style=display:flex><span>  echo
</span></span><span style=display:flex><span>  echo -e <span style=color:#e6db74>&#34;  --namespace\tThe namespace to install the certificate in&#34;</span>
</span></span><span style=display:flex><span>  echo -e <span style=color:#e6db74>&#34;  --suffix\tAn optional suffix for the hostname&#34;</span>
</span></span><span style=display:flex><span>  echo -e <span style=color:#e6db74>&#34;  --dry-run\tDon&#39;t install the certificate&#34;</span>
</span></span><span style=display:flex><span>  echo
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Example:&#34;</span>
</span></span><span style=display:flex><span>  echo
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;  </span>$SCRIPT_NAME<span style=color:#e6db74> --namespace test --dry-run&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h2><p>I keep a single template file which has all of this written into it, and new scripts start off with a copy-paste of the template. Could it be <a href=https://en.wikipedia.org/wiki/Don%27t_repeat_yourself>DRY</a>er? Sure, but then I have to deal with dependency management, and it&rsquo;s just not worth the hassle and overhead.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/bash/>bash</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2020/11/01/docker-multistage-containers/><span class=title>« Prev Page</span><br><span>Isolated Docker Multistage Images</span></a>
<a class=next href=https://andydote.co.uk/2020/05/14/docker-layer-sharing/><span class=title>Next Page »</span><br><span>Sharing Docker Layers Between Build Agents</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>