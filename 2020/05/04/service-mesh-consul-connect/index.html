<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Service Mesh with Consul Connect (and Nomad) | Andy Dote</title><meta name=keywords content="microservices,consul,nomad"><meta name=description content="When it comes to implementing a new feature in an application&rsquo;s ecosystem, I don&rsquo;t like spending my innovation tokens unless I have to, so I try not to add new tools to my infrastructure unless I really need them.
This same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don&rsquo;t instantly setup Istio. Not because it&rsquo;s bad - far from it - but because it&rsquo;s extra complexity I would rather avoid, unless I need it."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Service Mesh with Consul Connect (and Nomad)"><meta property="og:description" content="When it comes to implementing a new feature in an application&rsquo;s ecosystem, I don&rsquo;t like spending my innovation tokens unless I have to, so I try not to add new tools to my infrastructure unless I really need them.
This same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don&rsquo;t instantly setup Istio. Not because it&rsquo;s bad - far from it - but because it&rsquo;s extra complexity I would rather avoid, unless I need it."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-05-04T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Service Mesh with Consul Connect (and Nomad)"><meta name=twitter:description content="When it comes to implementing a new feature in an application&rsquo;s ecosystem, I don&rsquo;t like spending my innovation tokens unless I have to, so I try not to add new tools to my infrastructure unless I really need them.
This same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don&rsquo;t instantly setup Istio. Not because it&rsquo;s bad - far from it - but because it&rsquo;s extra complexity I would rather avoid, unless I need it."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Service Mesh with Consul Connect (and Nomad)","item":"https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Service Mesh with Consul Connect (and Nomad)","name":"Service Mesh with Consul Connect (and Nomad)","description":"When it comes to implementing a new feature in an application\u0026rsquo;s ecosystem, I don\u0026rsquo;t like spending my innovation tokens unless I have to, so I try not to add new tools to my infrastructure unless I really need them.\nThis same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don\u0026rsquo;t instantly setup Istio. Not because it\u0026rsquo;s bad - far from it - but because it\u0026rsquo;s extra complexity I would rather avoid, unless I need it.","keywords":["microservices","consul","nomad"],"articleBody":"When it comes to implementing a new feature in an application’s ecosystem, I don’t like spending my innovation tokens unless I have to, so I try not to add new tools to my infrastructure unless I really need them.\nThis same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don’t instantly setup Istio. Not because it’s bad - far from it - but because it’s extra complexity I would rather avoid, unless I need it.\nBut what alternatives are there?\nIn most large systems I have been involved with Consul has been deployed; usually for Service Discovery, Feature Toggles, it’s key-value store, or distributed locking. As Consul has Service Mesh functionality built in, why not use that?\nSo let’s dive into setting up a Consul Connect based Service Mesh.\nImplementing The demo for this is made up of two parts (taken from HashiCorp’s consul demo repo): a counter and a dashboard. The counter listens for HTTP requests and will return the number of requests it’s handled. The dashboard polls the counter and displays the current count.\nAll the source code for the demo is in the Consul Connect Example Repository.\nClone the repository, and run the build script to create the apps:\ngit clone https://github.com/Pondidum/consul-connect-nomad-demo cd consul-connect-nomad-demo ./apps/build.sh Local Run Run the apps locally to prove they work, in two separate terminals:\nPORT=9001 ./apps/bin/counter PORT=9002 ./apps/bin/dashboard Open http://localhost:9002 to see the counter running.\nStart A Cluster Now we have established our apps actually start, we can create a small Consul cluster. I am using my Hashibox to do this, so you’ll need libvirt and Vagrant installed to do this.\nRunning vagrant up will spawn three machines, which will form a Consul cluster, which we can now experiment in. Once it is up and running, we can manually register the two applications into Consul’s service mesh to check that our in cluster communication works.\nFirst, the counter service. The script writes a service definition into consul, which, by specifying the connect stanza, indicates this service is to be included in the service mesh. Once this is done, the counter is started (and sent to the background), and a consul connect proxy is started for this service:\ncurl --request PUT --url http://localhost:8500/v1/agent/service/register \\ --data '{ \"name\": \"counter\", \"port\": 9001, \"connect\": { \"sidecar_service\": {} } }' PORT=9001 /vagrant/apps/bin/counter \u0026 consul connect proxy -sidecar-for counter We can run this script in a new terminal by running this command:\nvagrant ssh one -c '/vagrant/scripts/counter.sh' Finally, we start the dashboard. The script is very similar, in that we write a service definiton into consul, start the service and run a proxy. The only notable difference is the service registation payload itself:\n{ \"name\": \"dashboard\", \"port\": 9002, \"connect\": { \"sidecar_service\": { \"proxy\": { \"upstreams\": [ { \"destination_name\": \"counter\", \"local_bind_port\": 8080 } ] } } } } As before, it registers a service, and on what port it will be listening on, but in the connect stanza, we specify that we want to connect to the counter, and we want to talk to it on localhost:8080.\nIn a new terminal, you can run this script like so:\nvagrant ssh two -c '/vagrant/scripts/dashboard.sh' Now that both are up and running, you can open a browser to the dashboard and see it working: http://two.karhu.xyz:9002. Once you are satisfied, you can stop the services by hitting ctrl+c in both terminals…or try running a second counter or dashboard on the third vagrant machine (vagrant ssh three -c '/vagrant/scripts/dashboard.sh')\nNomad Now that we have seen how to run the services manually let’s see how easy it is to use the service mesh using Nomad.\nThere are two nomad job definitions in the included project, so let’s look at the counter’s first:\njob \"counter\" { datacenters = [\"dc1\"] group \"api\" { count = 3 network { mode = \"bridge\" } service { name = \"count-api\" port = \"9001\" connect { sidecar_service {} } } task \"counter\" { driver = \"exec\" config { command = \"/vagrant/apps/bin/counter\" } env { PORT = 9001 } } } } The network stanza is set to bridge mode, which creates us an isolated network between all the services in the group only. In our case, we will have a single counter service and the proxy.\nThe service stanza is replicating the same functionality we had by writing a service registration into Consul. By specifying the connect part, Nomad knows that it also needs to start a proxy-based on the service stanza’s settings, and will handle starting and stopping this proxy for us.\nThe task \"counter\" block uses the exec driver to run the counter app natively on the host, but docker, java, and others are available too.\nTo run this into our Nomad cluster, we can use the nomad CLI:\nexport NOMAD_ADDR=\"http://one.karhu.xyz:4646\" nomad job run apps/counter/counter.nomad The dashboard’s Nomad job is very similar:\njob \"dashboard\" { datacenters = [\"dc1\"] group \"dashboard\" { network { mode = \"bridge\" port \"http\" { to = 9002 } } service { name = \"count-dashboard\" port = 9002 connect { sidecar_service { proxy { upstreams { destination_name = \"count-api\" local_bind_port = 8080 } } } } } task \"dashboard\" { driver = \"exec\" config { command = \"/vagrant/apps/bin/dashboard\" } env { PORT = \"${NOMAD_PORT_http}\" COUNTING_SERVICE_URL = \"http://${NOMAD_UPSTREAM_ADDR_count_api}\" } } } } The network block this time also specifies that we want to expose our service to the public. As we don’t have a static = 9002 in the port definition, Nomad will assign one at random (this is better! You can avoid port clashes with multiple tasks on the same node), we do however specify that we will map to 9002. The rest of the file can use the Nomad variable NOMAD_PORT_http to get this port number, so we don’t have to copy-paste the number everywhere. Similarly, the sidecar_service stanza exposes a variable called NOMAD_UPSTREAM_ADDR_, so we can use that too for our dashboard task’s environment variable values. This means we should only ever need to specify ports in 1 location in a Nomad file.\nAs with the counter, we can run the job using the CLI:\nnomad job run apps/counter/dashboard.nomad If we want to get the address and port the dashboard is actually running at, it is easiest to go through the UI, but you can also get the information from the console using the Nomad CLI and jq:\nallocation_id=$(nomad alloc status -json | jq -r '.[] | select(.JobID == \"dashboard\") | .ID') nomad alloc status -json \"$allocation_id\" \\ | jq -r '.AllocatedResources.Shared.Networks[0] | ( \"http://\" + .IP + \":\" + (.DynamicPorts[] | select(.Label == \"http\") | .Value | tostring))' Wrapping Up With Consul Connect’s supported APIs, there is great flexibility in how you can implement your service mesh; through definition files, through API requests, or through the container orchestrator directly. Couple this with Consul already being in use in most systems I have been involved with, and hopefully you can see why it makes a great way of having a Service Mesh.\n","wordCount":"1171","inLanguage":"en","datePublished":"2020-05-04T00:00:00Z","dateModified":"2020-05-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Service Mesh with Consul Connect (and Nomad)</h1><div class=post-meta><span title='2020-05-04 00:00:00 +0000 UTC'>May 4, 2020</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>When it comes to implementing a new feature in an application&rsquo;s ecosystem, I <a href=https://mcfunley.com/choose-boring-technology>don&rsquo;t like spending my innovation tokens</a> unless I have to, so I try not to add new tools to my infrastructure unless I <em>really</em> need them.</p><p>This same approach comes when I either want, need, or have been told, to implement a Service Mesh. This means I don&rsquo;t instantly setup <a href=https://istio.io/>Istio</a>. Not because it&rsquo;s bad - far from it - but because it&rsquo;s extra complexity I would rather avoid, unless I need it.</p><p>But what alternatives are there?</p><p>In most large systems I have been involved with <a href=https://www.consul.io>Consul</a> has been deployed; usually for Service Discovery, <a href=/2018/09/06/consul-feature-toggles/>Feature Toggles</a>, it&rsquo;s key-value store, or distributed locking. As Consul has Service Mesh functionality built in, why not use that?</p><p>So let&rsquo;s dive into setting up a <a href=https://www.consul.io/docs/connect/index.html>Consul Connect</a> based Service Mesh.</p><h2 id=implementing>Implementing<a hidden class=anchor aria-hidden=true href=#implementing>#</a></h2><p>The demo for this is made up of two parts (taken from HashiCorp&rsquo;s consul demo repo): a counter and a dashboard. The counter listens for HTTP requests and will return the number of requests it&rsquo;s handled. The dashboard polls the counter and displays the current count.</p><p>All the source code for the demo is in the <a href=https://github.com/Pondidum/consul-connect-nomad-demo>Consul Connect Example Repository</a>.</p><p>Clone the repository, and run the build script to create the apps:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/Pondidum/consul-connect-nomad-demo
</span></span><span style=display:flex><span>cd consul-connect-nomad-demo
</span></span><span style=display:flex><span>./apps/build.sh
</span></span></code></pre></div><h3 id=local-run>Local Run<a hidden class=anchor aria-hidden=true href=#local-run>#</a></h3><p>Run the apps locally to prove they work, in two separate terminals:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>9001</span> ./apps/bin/counter
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>9002</span> ./apps/bin/dashboard
</span></span></code></pre></div><p>Open <code>http://localhost:9002</code> to see the counter running.</p><h3 id=start-a-cluster>Start A Cluster<a hidden class=anchor aria-hidden=true href=#start-a-cluster>#</a></h3><p>Now we have established our apps actually start, we can create a small Consul cluster. I am using my Hashibox to do this, so you&rsquo;ll need libvirt and Vagrant installed to do this.</p><p>Running <code>vagrant up</code> will spawn three machines, which will form a Consul cluster, which we can now experiment in. Once it is up and running, we can manually register the two applications into Consul&rsquo;s service mesh to check that our in cluster communication works.</p><p>First, the counter service. The script writes a service definition into consul, which, by specifying the <code>connect</code> stanza, indicates this service is to be included in the service mesh. Once this is done, the counter is started (and sent to the background), and a consul connect proxy is started for this service:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl --request PUT --url http://localhost:8500/v1/agent/service/register <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --data <span style=color:#e6db74>&#39;{
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;name&#34;: &#34;counter&#34;,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;port&#34;: 9001,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;connect&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>      &#34;sidecar_service&#34;: {}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  }&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>9001</span> /vagrant/apps/bin/counter &amp;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>consul connect proxy -sidecar-for counter
</span></span></code></pre></div><p>We can run this script in a new terminal by running this command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vagrant ssh one -c <span style=color:#e6db74>&#39;/vagrant/scripts/counter.sh&#39;</span>
</span></span></code></pre></div><p>Finally, we start the dashboard. The script is very similar, in that we write a service definiton into consul, start the service and run a proxy. The only notable difference is the service registation payload itself:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;dashboard&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;port&#34;</span>: <span style=color:#ae81ff>9002</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;connect&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;sidecar_service&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;proxy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:#f92672>&#34;upstreams&#34;</span>: [
</span></span><span style=display:flex><span>          { <span style=color:#f92672>&#34;destination_name&#34;</span>: <span style=color:#e6db74>&#34;counter&#34;</span>, <span style=color:#f92672>&#34;local_bind_port&#34;</span>: <span style=color:#ae81ff>8080</span> }
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As before, it registers a service, and on what port it will be listening on, but in the <code>connect</code> stanza, we specify that we want to connect to the <code>counter</code>, and we want to talk to it on <code>localhost:8080</code>.</p><p>In a new terminal, you can run this script like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vagrant ssh two -c <span style=color:#e6db74>&#39;/vagrant/scripts/dashboard.sh&#39;</span>
</span></span></code></pre></div><p>Now that both are up and running, you can open a browser to the dashboard and see it working: <code>http://two.karhu.xyz:9002</code>. Once you are satisfied, you can stop the services by hitting <code>ctrl+c</code> in both terminals&mldr;or try running a second counter or dashboard on the third vagrant machine (<code>vagrant ssh three -c '/vagrant/scripts/dashboard.sh'</code>)</p><h3 id=nomad>Nomad<a hidden class=anchor aria-hidden=true href=#nomad>#</a></h3><p>Now that we have seen how to run the services manually let&rsquo;s see how easy it is to use the service mesh using <a href=https://nomadproject.io>Nomad</a>.</p><p>There are two nomad job definitions in the included project, so let&rsquo;s look at the counter&rsquo;s first:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>job</span> <span style=color:#e6db74>&#34;counter&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>datacenters</span> = [<span style=color:#e6db74>&#34;dc1&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>group</span> <span style=color:#e6db74>&#34;api&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span> = <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>network</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>mode</span> = <span style=color:#e6db74>&#34;bridge&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>service</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;count-api&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>port</span> = <span style=color:#e6db74>&#34;9001&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>connect</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sidecar_service</span> {}
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>task</span> <span style=color:#e6db74>&#34;counter&#34;</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>driver</span> = <span style=color:#e6db74>&#34;exec&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>config</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>command</span> = <span style=color:#e6db74>&#34;/vagrant/apps/bin/counter&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>env</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PORT</span> = <span style=color:#ae81ff>9001</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>network</code> stanza is set to <code>bridge</code> mode, which creates us an isolated network between all the services in the group only. In our case, we will have a single <code>counter</code> service and the proxy.</p><p>The <code>service</code> stanza is replicating the same functionality we had by writing a service registration into Consul. By specifying the <code>connect</code> part, Nomad knows that it also needs to start a proxy-based on the service stanza&rsquo;s settings, and will handle starting and stopping this proxy for us.</p><p>The <code>task "counter"</code> block uses the <code>exec</code> driver to run the counter app natively on the host, but <code>docker</code>, <code>java</code>, and others are available too.</p><p>To run this into our Nomad cluster, we can use the nomad CLI:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export NOMAD_ADDR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://one.karhu.xyz:4646&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nomad job run apps/counter/counter.nomad
</span></span></code></pre></div><p>The dashboard&rsquo;s Nomad job is very similar:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>job</span> <span style=color:#e6db74>&#34;dashboard&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>datacenters</span> = [<span style=color:#e6db74>&#34;dc1&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>group</span> <span style=color:#e6db74>&#34;dashboard&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>network</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>mode</span> = <span style=color:#e6db74>&#34;bridge&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>port</span> <span style=color:#e6db74>&#34;http&#34;</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>to</span>     = <span style=color:#ae81ff>9002</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>service</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>name</span> = <span style=color:#e6db74>&#34;count-dashboard&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>port</span> = <span style=color:#ae81ff>9002</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>connect</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sidecar_service</span> {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>proxy</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>upstreams</span> {
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>destination_name</span> = <span style=color:#e6db74>&#34;count-api&#34;</span>
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>local_bind_port</span>  = <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>task</span> <span style=color:#e6db74>&#34;dashboard&#34;</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>driver</span> = <span style=color:#e6db74>&#34;exec&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>config</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>command</span> = <span style=color:#e6db74>&#34;/vagrant/apps/bin/dashboard&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>env</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>PORT</span> = <span style=color:#e6db74>&#34;${NOMAD_PORT_http}&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>COUNTING_SERVICE_URL</span> = <span style=color:#e6db74>&#34;http://${NOMAD_UPSTREAM_ADDR_count_api}&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>network</code> block this time also specifies that we want to expose our service to the public. As we don&rsquo;t have a <code>static = 9002</code> in the port definition, Nomad will assign one at random (this is better! You can avoid port clashes with multiple tasks on the same node), we do however specify that we will map to <code>9002</code>. The rest of the file can use the Nomad variable <code>NOMAD_PORT_http</code> to get this port number, so we don&rsquo;t have to copy-paste the number everywhere. Similarly, the <code>sidecar_service</code> stanza exposes a variable called <code>NOMAD_UPSTREAM_ADDR_&lt;destination_name></code>, so we can use that too for our dashboard task&rsquo;s environment variable values. This means we should only ever need to specify ports in 1 location in a Nomad file.</p><p>As with the counter, we can run the job using the CLI:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nomad job run apps/counter/dashboard.nomad
</span></span></code></pre></div><p>If we want to get the address and port the dashboard is actually running at, it is easiest to go through the UI, but you can also get the information from the console using the Nomad CLI and jq:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>allocation_id<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>nomad alloc status -json | jq -r <span style=color:#e6db74>&#39;.[] | select(.JobID == &#34;dashboard&#34;) | .ID&#39;</span><span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>nomad alloc status -json <span style=color:#e6db74>&#34;</span>$allocation_id<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  | jq -r <span style=color:#e6db74>&#39;.AllocatedResources.Shared.Networks[0] | ( &#34;http://&#34; + .IP + &#34;:&#34; + (.DynamicPorts[] | select(.Label == &#34;http&#34;) | .Value | tostring))&#39;</span>
</span></span></code></pre></div><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>With Consul Connect&rsquo;s supported APIs, there is great flexibility in how you can implement your service mesh; through definition files, through API requests, or through the container orchestrator directly. Couple this with Consul already being in use in most systems I have been involved with, and hopefully you can see why it makes a great way of having a Service Mesh.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li><li><a href=https://andydote.co.uk/tags/consul/>consul</a></li><li><a href=https://andydote.co.uk/tags/nomad/>nomad</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2020/05/14/docker-layer-sharing/><span class=title>« Prev Page</span><br><span>Sharing Docker Layers Between Build Agents</span></a>
<a class=next href=https://andydote.co.uk/2020/03/15/observability-without-honeycomb/><span class=title>Next Page »</span><br><span>Observability Without Honeycomb</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>