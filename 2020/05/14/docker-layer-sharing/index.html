<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sharing Docker Layers Between Build Agents | Andy Dote</title><meta name=keywords content="docker"><meta name=description content="Recently, I noticed that when we pull a new version of our application&rsquo;s docker container, it fetches all layers, not just the ones that change.
The problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn&rsquo;t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2020/05/14/docker-layer-sharing/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Sharing Docker Layers Between Build Agents"><meta property="og:description" content="Recently, I noticed that when we pull a new version of our application&rsquo;s docker container, it fetches all layers, not just the ones that change.
The problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn&rsquo;t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2020/05/14/docker-layer-sharing/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-05-14T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-14T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sharing Docker Layers Between Build Agents"><meta name=twitter:description content="Recently, I noticed that when we pull a new version of our application&rsquo;s docker container, it fetches all layers, not just the ones that change.
The problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn&rsquo;t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Sharing Docker Layers Between Build Agents","item":"https://andydote.co.uk/2020/05/14/docker-layer-sharing/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sharing Docker Layers Between Build Agents","name":"Sharing Docker Layers Between Build Agents","description":"Recently, I noticed that when we pull a new version of our application\u0026rsquo;s docker container, it fetches all layers, not just the ones that change.\nThe problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn\u0026rsquo;t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build.","keywords":["docker"],"articleBody":"Recently, I noticed that when we pull a new version of our application’s docker container, it fetches all layers, not just the ones that change.\nThe problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn’t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build. We want to cache the other stages of the build too, as the earlier layers don’t change often, and can be quite slow to build.\nWe can achieve this by tweaking how we build our stages, which will also allow some other interesting optimisations.\nThe Dockerfile An example dockerfile is below. There are two stages, builder and prod. In the case we are looking at, both the OS packages and application dependencies rarely change, but can take quite a while to install.\nFROMnode:14.2.0-alpine3.11 AS builderWORKDIR/appRUN apk add --no-cache make gcc g++ pythonCOPY package.json yarn.lock ./RUN yarn install --no-progress --frozen-lockfile \u0026\u0026 \\  yarn cache cleanCOPY ./src ./srcRUN yarn buildFROMnode:14.2.0-alpine3.11 AS prodWORKDIR/appCOPY package.json yarn.lock ./RUN yarn install --production --no-progress --frozen-lockfile \u0026\u0026 \\  yarn cache cleanCOPY --from=builder /app/dist ./distCMD [\"yarn\", \"start\"]The first step is to try and pull both :builder and :latest images. We append || true as the images might not exist yet, and we want the build to pass if they don’t!\ndocker pull app:builder || true docker pull app:latest || true Now that we have the application images locally, we can proceed to building the :builder stage. We tag it twice: once with just app:builder and once with the short-commit that built it.\ndocker build \\  --cache-from=app:builder \\  --target builder \\  -t app:builder-$COMMIT_SHORT \\  -t app:builder \\  . Now that we have built our builder stage, we can use this to do lots of other things which require both dependencies and devDependencies, such as running tests and linters, and we could even distribute these tasks to multiple other machines if we wanted extra parallelism:\ndocker run --rm -it app:builder-$COMMIT_SHORT yarn test docker run --rm -it app:builder-$COMMIT_SHORT yarn test:integration docker run --rm -it app:builder-$COMMIT_SHORT yarn lint Once we are happy with our tests, we can now build the production container, which we do by using the --cache-from directive twice; once with the builder image we just created, and once with the latest version of our application. Note the order of the --cache-from parameters matters; this won’t work if you specify the app:latest before app:builder!\ndocker build \\  --cache-from=app:builder \\  --cache-from=app:latest \\  -t app:$COMMIT_SHORT \\  -t app:latest \\  . Now we can publish everything. We always publish the commit tagged version so that separate branch builds can be fetched and tested, and if the branch is master, we publish both the :builder and :latest tags:\ndocker push app:$COMMIT_SHORT  if [ \"$BRANCH\" == \"master\" ]; then  docker push app:builder  docker push app:latest fi The full build script looks like this:\ndocker pull app:builder || true docker pull app:latest || true  docker build \\  --cache-from=app:builder \\  --target builder \\  -t app:builder-$COMMIT_SHORT \\  -t app:builder \\  .  # run these in parallel docker run --rm -it app:builder-$COMMIT_SHORT yarn test docker run --rm -it app:builder-$COMMIT_SHORT yarn test:integration docker run --rm -it app:builder-$COMMIT_SHORT yarn lint  docker build \\  --cache-from=app:builder \\  --cache-from=app:latest \\  -t app:$COMMIT_SHORT \\  -t app:latest \\  .  docker push app:$COMMIT_SHORT  if [ \"$BRANCH\" == \"master\" ]; then  docker push app:builder  docker push app:latest fi Effects By publishing both our :builder and :latest tags, we can effectively share the layer caches for all build stages across all build agents. As the layers are shared, pulling the images at the beginning of the builds is pretty fast, and the publishes at the end of the build are very, very fast.\nThe real benefit comes with building our monolith, which now only needs a small layer to be pulled on deployment, rather than all of the layers, which speeds up our deployments by minutes per host.\n","wordCount":"668","inLanguage":"en","datePublished":"2020-05-14T00:00:00Z","dateModified":"2020-05-14T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2020/05/14/docker-layer-sharing/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Sharing Docker Layers Between Build Agents</h1><div class=post-meta><span title="2020-05-14 00:00:00 +0000 UTC">May 14, 2020</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>Recently, I noticed that when we pull a new version of our application&rsquo;s docker container, it fetches all layers, not just the ones that change.</p><p>The problem is that we use ephemeral build agents, which means that each version of the application is built using a different agent, so Docker doesn&rsquo;t know how to share the layers used. While we can pull the published container before we run the build, this only helps with the final stage of the build. We want to cache the other stages of the build too, as the earlier layers don&rsquo;t change often, and can be quite slow to build.</p><p>We can achieve this by tweaking how we build our stages, which will also allow some other interesting optimisations.</p><h2 id=the-dockerfile>The Dockerfile<a hidden class=anchor aria-hidden=true href=#the-dockerfile>#</a></h2><p>An example dockerfile is below. There are two stages, <code>builder</code> and <code>prod</code>. In the case we are looking at, both the OS packages and application dependencies rarely change, but can take quite a while to install.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> node:14.2.0-alpine3.11 AS builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> apk add --no-cache make gcc g++ python<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> package.json yarn.lock ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> yarn install --no-progress --frozen-lockfile <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    yarn cache clean<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> ./src ./src<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> yarn build<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> node:14.2.0-alpine3.11 AS prod</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> package.json yarn.lock ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> yarn install --production --no-progress --frozen-lockfile <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    yarn cache clean<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder /app/dist ./dist<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>CMD</span> [<span style=color:#e6db74>&#34;yarn&#34;</span>, <span style=color:#e6db74>&#34;start&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>The first step is to try and pull both <code>:builder</code> and <code>:latest</code> images. We append <code>|| true</code> as the images might not exist yet, and we want the build to pass if they don&rsquo;t!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker pull app:builder <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>docker pull app:latest <span style=color:#f92672>||</span> true
</span></span></code></pre></div><p>Now that we have the application images locally, we can proceed to building the <code>:builder</code> stage. We tag it twice: once with just <code>app:builder</code> and once with the short-commit that built it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cache-from<span style=color:#f92672>=</span>app:builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --target builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:builder-$COMMIT_SHORT <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    .
</span></span></code></pre></div><p>Now that we have built our <code>builder</code> stage, we can use this to do lots of other things which require both <code>dependencies</code> and <code>devDependencies</code>, such as running tests and linters, and we could even distribute these tasks to multiple other machines if we wanted extra parallelism:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --rm -it app:builder-$COMMIT_SHORT yarn test
</span></span><span style=display:flex><span>docker run --rm -it app:builder-$COMMIT_SHORT yarn test:integration
</span></span><span style=display:flex><span>docker run --rm -it app:builder-$COMMIT_SHORT yarn lint
</span></span></code></pre></div><p>Once we are happy with our tests, we can now build the production container, which we do by using the <code>--cache-from</code> directive twice; once with the builder image we just created, and once with the latest version of our application. Note the order of the <code>--cache-from</code> parameters matters; this won&rsquo;t work if you specify the <code>app:latest</code> before <code>app:builder</code>!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker build <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cache-from<span style=color:#f92672>=</span>app:builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cache-from<span style=color:#f92672>=</span>app:latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:$COMMIT_SHORT <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    .
</span></span></code></pre></div><p>Now we can publish everything. We always publish the commit tagged version so that separate branch builds can be fetched and tested, and if the branch is <code>master</code>, we publish both the <code>:builder</code> and <code>:latest</code> tags:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker push app:$COMMIT_SHORT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$BRANCH<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;master&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    docker push app:builder
</span></span><span style=display:flex><span>    docker push app:latest
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>The full build script looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker pull app:builder <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>docker pull app:latest <span style=color:#f92672>||</span> true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker build <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cache-from<span style=color:#f92672>=</span>app:builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --target builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:builder-$COMMIT_SHORT <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># run these in parallel</span>
</span></span><span style=display:flex><span>docker run --rm -it app:builder-$COMMIT_SHORT yarn test
</span></span><span style=display:flex><span>docker run --rm -it app:builder-$COMMIT_SHORT yarn test:integration
</span></span><span style=display:flex><span>docker run --rm -it app:builder-$COMMIT_SHORT yarn lint
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker build <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cache-from<span style=color:#f92672>=</span>app:builder <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cache-from<span style=color:#f92672>=</span>app:latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:$COMMIT_SHORT <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -t app:latest <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    .
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>docker push app:$COMMIT_SHORT
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;</span>$BRANCH<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;master&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    docker push app:builder
</span></span><span style=display:flex><span>    docker push app:latest
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><h2 id=effects>Effects<a hidden class=anchor aria-hidden=true href=#effects>#</a></h2><p>By publishing both our <code>:builder</code> and <code>:latest</code> tags, we can effectively share the layer caches for all build stages across all build agents. As the layers are shared, pulling the images at the beginning of the builds is pretty fast, and the publishes at the end of the build are very, very fast.</p><p>The real benefit comes with building our monolith, which now only needs a small layer to be pulled on deployment, rather than all of the layers, which speeds up our deployments by minutes per host.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/docker/>docker</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2020/08/28/better-bashing-through-technology/><span class=title>« Prev Page</span><br><span>Better BASHing Through Technology</span></a>
<a class=next href=https://andydote.co.uk/2020/05/04/service-mesh-consul-connect/><span class=title>Next Page »</span><br><span>Service Mesh with Consul Connect (and Nomad)</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>