<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shouldly: Why would you assert any other way? | Andy Dote</title>
<meta name=keywords content="c#,nunit,testing,shouldly,assert"><meta name=description content="I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used Shouldly in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit&rsquo;s assertions.
I have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2016/10/09/assertion-style/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Shouldly: Why would you assert any other way?"><meta property="og:description" content="I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used Shouldly in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit&rsquo;s assertions.
I have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2016/10/09/assertion-style/"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-10-09T00:00:00+00:00"><meta property="article:modified_time" content="2016-10-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Shouldly: Why would you assert any other way?"><meta name=twitter:description content="I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used Shouldly in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit&rsquo;s assertions.
I have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Shouldly: Why would you assert any other way?","item":"https://andydote.co.uk/2016/10/09/assertion-style/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shouldly: Why would you assert any other way?","name":"Shouldly: Why would you assert any other way?","description":"I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used Shouldly in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit\u0026rsquo;s assertions.\nI have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!","keywords":["c#","nunit","testing","shouldly","assert"],"articleBody":"I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used Shouldly in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit’s assertions.\nI have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!\nThe rest of this post goes through the different assertion models, and how they differ from each other and, eventually, why everyone should be using Shouldly!\nThe Most Basic var valueOne = \"Something\"; var valueTwo = \"Something else\"; Debug.Assert(valueOne == valueTwo); Debug.Assert(valueOne == valueTwo, $\"{valueOne} should have been {valueTwo}\"); This is an assertion at it’s most basic. It will only assert if the condition is false, and optionally you can specify a 2nd parameter with a message.\nThis has a couple of good points to it. No external dependencies are required, and it is strong typed (as your condition has to compile.) The down sides to this are that it is not very descriptive, and can only be used in Debug compiles (or with the DEBUG constant defined), meaning a Release mode build cannot be tested with this.\nThis also suffers from the descriptiveness problem - an output from this will only have a message saying an assertion failed, rather than anything helpful in figuring out why an assertion failed.\nNUnit’s First Attempt var valueOne = \"Something\"; var valueTwo = \"Something else\"; Assert.AreEqual(valueOne, valueTwo); Assert.AreEqual(valueOne, valueTwo, $\"{valueOne} should have been {valueTwo}\"); This improves on the Most Basic version by working in Release mode builds, and as it only depends on the test framework, it doesn’t add a dependency you didn’t already have.\nThere are two things I dislike about this method: it remains as undescriptive as the first method, and it adds the problem of parameter ambiguity: Which of the two parameters is the expected value, and which is the value under test? You can’t tell without checking the method declaration. While this is a small issue, it can cause headaches when you are trying to debug a test which has started failing, only to discover the assertion being the wrong way around was leading you astray!\nNUnit’s Second Attempt var valueOne = \"Something\"; var valueTwo = \"Something else\"; Assert.That(valueOne, Is.EqualTo(valueTwo)); Assert.That(valueOne, Is.EqualTo(valueTwo), $\"{valueOne} should have been {valueTwo}\"); This is an interesting attempt at readability. On the one hand, it’s very easy to read as a sentence, but it is very wordy, especially if you are wanting to do a Not equals Is.Not.EqualTo(valueTwo).\nThis biggest problem with this however, is the complete loss of strong typing - both arguments are object. This can trip you up when testing things such as Guids - especially if one of the values gets .ToString() on it at some point:\nvar id = Guid.NewGuid(); Assert.That(id.ToString(), Is.EqualTo(id)); Not only will this compile, but when the test fails, unless you are paying close attention to the output, it will look like it should’ve passed, as the only difference is the \" on either side of one of the values.\nShouldly’s Version var valueOne = \"Something\"; var valueTwo = \"Something else\"; valueOne.ShouldBe(valueTwo); valueOne.ShouldBe(valueTwo, () =\u003e \"Custom Message\"); Finally we hit upon the Shouldly library. This assertion library not only solves the code-time issues of strong typing, parameter clarity, and wordiness, it really improves the descriptiveness problem.\nShouldly uses the expression being tested against to create meaningful error messages:\n//nunit Assert.That(map.IndexOfValue(\"boo\"), Is.EqualTo(2)); // -\u003e Expected 2 but was 1 //shouldly map.IndexOfValue(\"boo\").ShouldBe(2); // -\u003e map.IndexOfValue(\"boo\") should be 2 but was 1 This is even more pronounced when you are comparing collections:\nnew[] { 1, 2, 3 }.ShouldBe(new[] { 1, 2, 4 }); Produces the following output\nshould be [1, 2, 4] but was [1, 2, 3] difference [1, 2, *3*] And when comparing strings, not only does it tell you they were different, but provides a visualisation of what was different:\ninput should be \"this is a longer test sentence\" but was \"this is a long test sentence\" difference Difference | | | | | | | | | | | | | | | | | | \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ \\|/ Index | ... 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 Expected Value | ... \\s l o n g e r \\s t e s t \\s s e n t e n c e Actual Value | ... \\s l o n g \\s t e s t \\s s e n t e n c e Finishing So having seen the design time experience and rich output Shouldly gives you, why would you not use it?\n","wordCount":"820","inLanguage":"en","datePublished":"2016-10-09T00:00:00Z","dateModified":"2016-10-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2016/10/09/assertion-style/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Shouldly: Why would you assert any other way?</h1><div class=post-meta>&lt;span title='2016-10-09 00:00:00 +0000 UTC'>October 9, 2016&lt;/span>&amp;nbsp;·&amp;nbsp;4 min</div></header><div class=post-content><p>I like to make my development life as easy as possible - and removing small irritations is a great way of doing this. Having used <a href=http://docs.shouldly-lib.net/v2.4.0/docs>Shouldly</a> in anger for a long time, I have to say I feel a little hamstrung when going back to just using NUnit&rsquo;s assertions.</p><p>I have been known on a couple of projects which use only NUnit assertions, when trying to solve a test failure with array differences, to install Shouldly, fix the test, then remove Shouldly again!</p><p>The rest of this post goes through the different assertion models, and how they differ from each other and, eventually, why everyone should be using Shouldly!</p><h2 id=the-most-basic>The Most Basic<a hidden class=anchor aria-hidden=true href=#the-most-basic>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> valueOne = <span style=color:#e6db74>&#34;Something&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> valueTwo = <span style=color:#e6db74>&#34;Something else&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Debug.Assert(valueOne == valueTwo);
</span></span><span style=display:flex><span>Debug.Assert(valueOne == valueTwo, <span style=color:#e6db74>$&#34;{valueOne} should have been {valueTwo}&#34;</span>);
</span></span></code></pre></div><p>This is an assertion at it&rsquo;s most basic. It will only assert if the condition is false, and optionally you can specify a 2nd parameter with a message.</p><p>This has a couple of good points to it. No external dependencies are required, and it is strong typed (as your condition has to compile.) The down sides to this are that it is not very descriptive, and can only be used in Debug compiles (or with the DEBUG constant defined), meaning a Release mode build cannot be tested with this.</p><p>This also suffers from the descriptiveness problem - an output from this will only have a message saying an assertion failed, rather than anything helpful in figuring out why an assertion failed.</p><h2 id=nunits-first-attempt>NUnit&rsquo;s First Attempt<a hidden class=anchor aria-hidden=true href=#nunits-first-attempt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> valueOne = <span style=color:#e6db74>&#34;Something&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> valueTwo = <span style=color:#e6db74>&#34;Something else&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Assert.AreEqual(valueOne, valueTwo);
</span></span><span style=display:flex><span>Assert.AreEqual(valueOne, valueTwo, <span style=color:#e6db74>$&#34;{valueOne} should have been {valueTwo}&#34;</span>);
</span></span></code></pre></div><p>This improves on the Most Basic version by working in Release mode builds, and as it only depends on the test framework, it doesn&rsquo;t add a dependency you didn&rsquo;t already have.</p><p>There are two things I dislike about this method: it remains as undescriptive as the first method, and it adds the problem of parameter ambiguity: Which of the two parameters is the expected value, and which is the value under test? You can&rsquo;t tell without checking the method declaration. While this is a small issue, it can cause headaches when you are trying to debug a test which has started failing, only to discover the assertion being the wrong way around was leading you astray!</p><h2 id=nunits-second-attempt>NUnit&rsquo;s Second Attempt<a hidden class=anchor aria-hidden=true href=#nunits-second-attempt>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> valueOne = <span style=color:#e6db74>&#34;Something&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> valueTwo = <span style=color:#e6db74>&#34;Something else&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Assert.That(valueOne, Is.EqualTo(valueTwo));
</span></span><span style=display:flex><span>Assert.That(valueOne, Is.EqualTo(valueTwo), <span style=color:#e6db74>$&#34;{valueOne} should have been {valueTwo}&#34;</span>);
</span></span></code></pre></div><p>This is an interesting attempt at readability. On the one hand, it&rsquo;s very easy to read as a sentence, but it is very wordy, especially if you are wanting to do a Not equals <code>Is.Not.EqualTo(valueTwo)</code>.</p><p>This biggest problem with this however, is the complete loss of strong typing - both arguments are <code>object</code>. This can trip you up when testing things such as Guids - especially if one of the values gets <code>.ToString()</code> on it at some point:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> id = Guid.NewGuid();
</span></span><span style=display:flex><span>Assert.That(id.ToString(), Is.EqualTo(id));
</span></span></code></pre></div><p>Not only will this compile, but when the test fails, unless you are paying close attention to the output, it will look like it should&rsquo;ve passed, as the only difference is the <code>"</code> on either side of one of the values.</p><h2 id=shouldlys-version>Shouldly&rsquo;s Version<a hidden class=anchor aria-hidden=true href=#shouldlys-version>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> valueOne = <span style=color:#e6db74>&#34;Something&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> valueTwo = <span style=color:#e6db74>&#34;Something else&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>valueOne.ShouldBe(valueTwo);
</span></span><span style=display:flex><span>valueOne.ShouldBe(valueTwo, () =&gt; <span style=color:#e6db74>&#34;Custom Message&#34;</span>);
</span></span></code></pre></div><p>Finally we hit upon the <a href=http://docs.shouldly-lib.net/v2.4.0/docs>Shouldly</a> library. This assertion library not only solves the code-time issues of strong typing, parameter clarity, and wordiness, it really improves the descriptiveness problem.</p><p>Shouldly uses the expression being tested against to create meaningful error messages:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>//nunit</span>
</span></span><span style=display:flex><span>Assert.That(map.IndexOfValue(<span style=color:#e6db74>&#34;boo&#34;</span>), Is.EqualTo(<span style=color:#ae81ff>2</span>));    <span style=color:#75715e>// -&gt; Expected 2 but was 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//shouldly</span>
</span></span><span style=display:flex><span>map.IndexOfValue(<span style=color:#e6db74>&#34;boo&#34;</span>).ShouldBe(<span style=color:#ae81ff>2</span>);                    <span style=color:#75715e>// -&gt; map.IndexOfValue(&#34;boo&#34;) should be 2 but was 1</span>
</span></span></code></pre></div><p>This is even more pronounced when you are comparing collections:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>new</span>[] { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span> }.ShouldBe(<span style=color:#66d9ef>new</span>[] { <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span> });
</span></span></code></pre></div><p>Produces the following output</p><pre tabindex=0><code>should be
    [1, 2, 4]
but was
    [1, 2, 3]
difference
    [1, 2, *3*]
</code></pre><p>And when comparing strings, not only does it tell you they were different, but provides a visualisation of what was different:</p><pre tabindex=0><code>input
    should be
&#34;this is a longer test sentence&#34;
    but was
&#34;this is a long test sentence&#34;
    difference
Difference     |                                |    |    |    |    |    |    |    |    |    |    |    |    |    |    |    |
               |                               \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/  \|/
Index          | ...  9    10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26   27   28   29
Expected Value | ...  \s   l    o    n    g    e    r    \s   t    e    s    t    \s   s    e    n    t    e    n    c    e
Actual Value   | ...  \s   l    o    n    g    \s   t    e    s    t    \s   s    e    n    t    e    n    c    e
</code></pre><h2 id=finishing>Finishing<a hidden class=anchor aria-hidden=true href=#finishing>#</a></h2><p>So having seen the design time experience and rich output Shouldly gives you, why would you not use it?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/nunit/>nunit</a></li><li><a href=https://andydote.co.uk/tags/testing/>testing</a></li><li><a href=https://andydote.co.uk/tags/shouldly/>shouldly</a></li><li><a href=https://andydote.co.uk/tags/assert/>assert</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2016/12/06/strong-type-all-the-configurations/><span class=title>« Prev Page</span><br><span>Strong Type All The Configurations</span>
</a><a class=next href=https://andydote.co.uk/2016/09/12/nuget-dependencies/><span class=title>Next Page »</span><br><span>Visualising NuGet Dependencies</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>