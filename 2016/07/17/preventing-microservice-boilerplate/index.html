<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Preventing MicroService Boilerplate | Andy Dote</title><meta name=keywords content="c#,microservices,consul,structuremap,kibana,boilerplate"><meta name=description content="One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the Single Project Service and Console method.
What do we do in every service? Initialise Serilog. Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.) Hook/Unhook the AppDomain."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Preventing MicroService Boilerplate"><meta property="og:description" content="One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the Single Project Service and Console method.
What do we do in every service? Initialise Serilog. Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.) Hook/Unhook the AppDomain."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-07-17T00:00:00+00:00"><meta property="article:modified_time" content="2016-07-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Preventing MicroService Boilerplate"><meta name=twitter:description content="One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the Single Project Service and Console method.
What do we do in every service? Initialise Serilog. Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.) Hook/Unhook the AppDomain."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Preventing MicroService Boilerplate","item":"https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Preventing MicroService Boilerplate","name":"Preventing MicroService Boilerplate","description":"One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the Single Project Service and Console method.\nWhat do we do in every service? Initialise Serilog. Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.) Hook/Unhook the AppDomain.","keywords":["c#","microservices","consul","structuremap","kibana","boilerplate"],"articleBody":"One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the Single Project Service and Console method.\nWhat do we do in every service? Initialise Serilog. Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.) Hook/Unhook the AppDomain.Current.UnhandledException handler. Register/UnRegister with Consul. Setup StructureMap, if using an IOC Container. Run as a Console if the Environment.UserInteractive flag is true. Run as a Service otherwise The only task with potential to have variance each time is the setting up of StructureMap, the rest are almost identical every time.\nHow to solve all this repetition? To rectify this, I created a nuget project which encapsulates all of this logic, and allows us to create a Console project with the following startup:\nstatic void Main(string[] args) { ServiceHost.Run(\"TestService\"); } This requires one class implementing the IStartup interface, and there are some optional interfaces which can be implemented too:\npublic class Startup : IStartup, IDisposable { public Startup() { Console.WriteLine(\"starting up\"); } public void Execute(ServiceArgs service) { File.AppendAllLines(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, \"log.txt\"), new[] { \"boot!\" }); while (service.CancelRequested == false) Thread.Sleep(500); } public void Dispose() { Console.WriteLine(\"shutting down\"); } } Optionally, the project can implement two interfaces to control Consul and ElasticSearch configuration:\npublic class Config : ILogConfig, IConsulRegistration { public bool EnableKibana { get; } public Uri LoggingEndpoint { get; } public CatalogRegistration CreateRegistration() { return new CatalogRegistration() { Service = new AgentService { Address = \"http://localhost\", Port = 8005, Service = \"TestService\" }}; } public CatalogDeregistration CreateDeregistration() { return new CatalogDeregistration { ServiceID = \"TestService\" }; } } By implementing these interfaces, the ServiceHost class can use StructureMap to find the implementations (if any) at run time.\nTalking of StructureMap, if we wish to configure the container in the host application, all we need to do is create a class which inherits Registry, and the ServiceHost’s StructureMap configuration will find it.\nHow do we support other tools? Well we could implment some kind of stage configuration steps, so your startup might change to look like this:\nstatic void Main(string[] args) { ServiceHost.Stages(new LoggingStage(), new ConsulStage(), new SuperAwesomeThingStage()); ServiceHost.Run(\"TestService\"); } The reason I haven’t done this is that on the whole, we tend to use the same tools for each job in every service; StructureMap for IOC, Serilog for logging, Consul for discovery. So rather than having to write some boilerplate for every service (e.g. specifying all the stages), I just bake the options in to ServiceHost directly.\nThis means that if you want your own version of this library with different tooling support, you need to write it yourself. As a starting point, I have the code for the ServiceContainer project up on Github.\nIt is not difficult to create new stages for the pipeline - all the different tasks the ServiceHost can perform are implemented in a pseudo Russian-Doll model - they inherit Stage, which looks like this:\npublic abstract class Stage : IDisposable { public IContainer Container { get; set; } public abstract void Execute(); public abstract void Dispose(); } Anything you want to your stage to do before the IStartup.Execute() call is made is done in Execute(), similarly anything to be done afterwards is in Dispose(). For example, the ConsulStage is implemented like so:\npublic class ConsulStage : Stage { public override void Execute() { var registration = Container.TryGetInstance(); if (registration != null) { var client = new ConsulClient(); client.Catalog.Register(registration.CreateRegistration()); } } public override void Dispose() { var registration = Container.TryGetInstance(); if (registration != null) { var client = new ConsulClient(); client.Catalog.Deregister(registration.CreateDeregistration()); } } } Finally you just need to add the stage to the ServiceWrapper constructor:\npublic ServiceWrapper(string name, Type entryPoint) { // snip... _stages = new Stage[] { new LoggingStage(name), new ConsulStage() }; } Get started! That’s all there is to it! Hopefully this gives you a good starting point for de-boilerplating your microservices :)\n","wordCount":"669","inLanguage":"en","datePublished":"2016-07-17T00:00:00Z","dateModified":"2016-07-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Preventing MicroService Boilerplate</h1><div class=post-meta><span title='2016-07-17 00:00:00 +0000 UTC'>July 17, 2016</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>One of the downsides to microservices I have found is that I end up repeating the same blocks of code over and over for each service. Not only that, but the project setup is repetitive, as all the services use the <a href=/2015/08/30/single-project-service-and-console/>Single Project Service and Console</a> method.</p><h1 id=what-do-we-do-in-every-service>What do we do in every service?<a hidden class=anchor aria-hidden=true href=#what-do-we-do-in-every-service>#</a></h1><ul><li>Initialise Serilog.</li><li>Add a Serilog sink to ElasticSearch for Kibana (but only in non-local config.)</li><li>Hook/Unhook the <code>AppDomain.Current.UnhandledException</code> handler.</li><li>Register/UnRegister with Consul.</li><li>Setup StructureMap, if using an IOC Container.</li><li>Run as a Console if the <code>Environment.UserInteractive</code> flag is true.</li><li>Run as a Service otherwise</li></ul><p>The only task with potential to have variance each time is the setting up of StructureMap, the rest are almost identical every time.</p><h1 id=how-to-solve-all-this-repetition>How to solve all this repetition?<a hidden class=anchor aria-hidden=true href=#how-to-solve-all-this-repetition>#</a></h1><p>To rectify this, I created a nuget project which encapsulates all of this logic, and allows us to create a Console project with the following startup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	ServiceHost.Run&lt;Startup&gt;(<span style=color:#e6db74>&#34;TestService&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This requires one class implementing the <code>IStartup</code> interface, and there are some optional interfaces which can be implemented too:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Startup</span> : IStartup, IDisposable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Startup()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>&#34;starting up&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(ServiceArgs service)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		File.AppendAllLines(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, <span style=color:#e6db74>&#34;log.txt&#34;</span>), <span style=color:#66d9ef>new</span>[] { <span style=color:#e6db74>&#34;boot!&#34;</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>while</span> (service.CancelRequested == <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>			Thread.Sleep(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Dispose()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		Console.WriteLine(<span style=color:#e6db74>&#34;shutting down&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Optionally, the project can implement two interfaces to control Consul and ElasticSearch configuration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Config</span> : ILogConfig, IConsulRegistration
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> EnableKibana { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Uri LoggingEndpoint { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> CatalogRegistration CreateRegistration()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CatalogRegistration() { Service = <span style=color:#66d9ef>new</span> AgentService
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			Address = <span style=color:#e6db74>&#34;http://localhost&#34;</span>,
</span></span><span style=display:flex><span>			Port = <span style=color:#ae81ff>8005</span>,
</span></span><span style=display:flex><span>			Service = <span style=color:#e6db74>&#34;TestService&#34;</span>
</span></span><span style=display:flex><span>		}};
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> CatalogDeregistration CreateDeregistration()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> CatalogDeregistration { ServiceID = <span style=color:#e6db74>&#34;TestService&#34;</span> };
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>By implementing these interfaces, the <code>ServiceHost</code> class can use StructureMap to find the implementations (if any) at run time.</p><p>Talking of StructureMap, if we wish to configure the container in the host application, all we need to do is create a class which inherits <code>Registry</code>, and the ServiceHost&rsquo;s StructureMap configuration will find it.</p><h1 id=how-do-we-support-other-tools>How do we support other tools?<a hidden class=anchor aria-hidden=true href=#how-do-we-support-other-tools>#</a></h1><p>Well we could implment some kind of stage configuration steps, so your startup might change to look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	ServiceHost.Stages(<span style=color:#66d9ef>new</span> LoggingStage(), <span style=color:#66d9ef>new</span> ConsulStage(), <span style=color:#66d9ef>new</span> SuperAwesomeThingStage());
</span></span><span style=display:flex><span>	ServiceHost.Run&lt;Startup&gt;(<span style=color:#e6db74>&#34;TestService&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The reason I haven&rsquo;t done this is that on the whole, we tend to use the same tools for each job in every service; StructureMap for IOC, Serilog for logging, Consul for discovery. So rather than having to write some boilerplate for every service (e.g. specifying all the stages), I just bake the options in to <code>ServiceHost</code> directly.</p><p>This means that if you want your own version of this library with different tooling support, you need to write it yourself. As a starting point, I have the code for the <a href=https://github.com/pondidum/ServiceContainer><code>ServiceContainer</code> project up on Github</a>.</p><p>It is not difficult to create new stages for the pipeline - all the different tasks the <code>ServiceHost</code> can perform are implemented in a pseudo Russian-Doll model - they inherit <code>Stage</code>, which looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stage</span> : IDisposable
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IContainer Container { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Execute();
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Dispose();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Anything you want to your stage to do before the <code>IStartup.Execute()</code> call is made is done in <code>Execute()</code>, similarly anything to be done afterwards is in <code>Dispose()</code>. For example, the <code>ConsulStage</code> is implemented like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConsulStage</span> : Stage
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> registration = Container.TryGetInstance&lt;IConsulRegistration&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (registration != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>var</span> client = <span style=color:#66d9ef>new</span> ConsulClient();
</span></span><span style=display:flex><span>			client.Catalog.Register(registration.CreateRegistration());
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Dispose()
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> registration = Container.TryGetInstance&lt;IConsulRegistration&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (registration != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>var</span> client = <span style=color:#66d9ef>new</span> ConsulClient();
</span></span><span style=display:flex><span>			client.Catalog.Deregister(registration.CreateDeregistration());
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally you just need to add the stage to the <code>ServiceWrapper</code> constructor:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c# data-lang=c#><span style=display:flex><span><span style=color:#66d9ef>public</span> ServiceWrapper(<span style=color:#66d9ef>string</span> name, Type entryPoint)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>// snip...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	_stages = <span style=color:#66d9ef>new</span> Stage[]
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>new</span> LoggingStage(name),
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>new</span> ConsulStage()
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=get-started>Get started!<a hidden class=anchor aria-hidden=true href=#get-started>#</a></h1><p>That&rsquo;s all there is to it! Hopefully this gives you a good starting point for de-boilerplating your microservices :)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li><li><a href=https://andydote.co.uk/tags/consul/>consul</a></li><li><a href=https://andydote.co.uk/tags/structuremap/>structuremap</a></li><li><a href=https://andydote.co.uk/tags/kibana/>kibana</a></li><li><a href=https://andydote.co.uk/tags/boilerplate/>boilerplate</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2016/09/12/nuget-dependencies/><span class=title>« Prev Page</span><br><span>Visualising NuGet Dependencies</span></a>
<a class=next href=https://andydote.co.uk/2016/06/09/database-integrations-for-microservices/><span class=title>Next Page »</span><br><span>Database Integrations for MicroServices</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>