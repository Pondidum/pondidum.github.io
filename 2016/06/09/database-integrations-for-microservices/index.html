<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Database Integrations for MicroServices | Andy Dote</title>
<meta name=keywords content="c#,microservices,integration,eventsourcing"><meta name=description content="This is a follow up post after seeing Michal Franc&rsquo;s NDC talk on migrating from Monolithic architectures.
One point raised was that Database Integration points are a terrible idea - and I wholeheartedly agree. However, there can be a number of situations where a Database Integration is the best or only way to achieve the end goal. This can be either technical; say a tool does not support API querying (looking at you SSRS), or cultural; the other team either don&rsquo;t have the willingness, time, or power to learn how to query an API."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2016/06/09/database-integrations-for-microservices/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Database Integrations for MicroServices"><meta property="og:description" content="This is a follow up post after seeing Michal Franc&rsquo;s NDC talk on migrating from Monolithic architectures.
One point raised was that Database Integration points are a terrible idea - and I wholeheartedly agree. However, there can be a number of situations where a Database Integration is the best or only way to achieve the end goal. This can be either technical; say a tool does not support API querying (looking at you SSRS), or cultural; the other team either don&rsquo;t have the willingness, time, or power to learn how to query an API."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2016/06/09/database-integrations-for-microservices/"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-06-09T00:00:00+00:00"><meta property="article:modified_time" content="2016-06-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Database Integrations for MicroServices"><meta name=twitter:description content="This is a follow up post after seeing Michal Franc&rsquo;s NDC talk on migrating from Monolithic architectures.
One point raised was that Database Integration points are a terrible idea - and I wholeheartedly agree. However, there can be a number of situations where a Database Integration is the best or only way to achieve the end goal. This can be either technical; say a tool does not support API querying (looking at you SSRS), or cultural; the other team either don&rsquo;t have the willingness, time, or power to learn how to query an API."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Database Integrations for MicroServices","item":"https://andydote.co.uk/2016/06/09/database-integrations-for-microservices/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Database Integrations for MicroServices","name":"Database Integrations for MicroServices","description":"This is a follow up post after seeing Michal Franc\u0026rsquo;s NDC talk on migrating from Monolithic architectures.\nOne point raised was that Database Integration points are a terrible idea - and I wholeheartedly agree. However, there can be a number of situations where a Database Integration is the best or only way to achieve the end goal. This can be either technical; say a tool does not support API querying (looking at you SSRS), or cultural; the other team either don\u0026rsquo;t have the willingness, time, or power to learn how to query an API.","keywords":["c#","microservices","integration","eventsourcing"],"articleBody":"This is a follow up post after seeing Michal Franc’s NDC talk on migrating from Monolithic architectures.\nOne point raised was that Database Integration points are a terrible idea - and I wholeheartedly agree. However, there can be a number of situations where a Database Integration is the best or only way to achieve the end goal. This can be either technical; say a tool does not support API querying (looking at you SSRS), or cultural; the other team either don’t have the willingness, time, or power to learn how to query an API.\nOne common situation is a reporting team, who either cannot query an API (e.g. they are stuck using SSRS), or don’t want/have time to learn how to query an API.\nThere are two ways which can make a Database Integration an altogether less painful prospect, both with a common starting point: A separate login to the Database, with only readonly access to a very small set of tables and views.\nViews can be used to create a representation of the service’s data in a manner which makes sense to external systems, for example de-normalising tables, or converting integer based enumerations into their string counterparts.\nTables can be used to expose a transformed version of the service’s data, for example a readmodel from an event stream.\nEvent Sourcing source data For example, one of our services uses Event Sourcing. It uses projections to construct readmodels as events are stored (we use the Ledger library, and a SqlServer backend for this.) To provide a Database Integeration point, we have a second set of projections which populate a set of tables specifically for external querying.\nIf the following event was committed to the store:\n{ \"eventType\": \"phoneNumberAdded\", \"aggregateID\": 231231, \"number\": \"01230 232323\", \"type\": \"home\" } The readmodel table, which is just two columns: id:int and json:varchar(max), would get updated to look like this:\nid | json --------+------------------------------------------------- 231231 | { \"id\": 231231, \"name\": \"Andy Dote\", \"phones\": [ { \"type\": \"mobile\", \"number\": \"0712345646\" }, { \"type\": \"home\", \"number\": \"01230 232323\" } ] } The external integration table, which is a denormalised view of the data would get updated to look like this:\nid | name | home_phone | mobile_phone --------+-----------+---------------+---------------------- 231231 | Andy Dote | 01230 232 323 | 07123 456 456 Non-SQL Systems While I have not needed to implement this yet, there is a plan for how to do it: a simple regular job which will pull the data from the service’s main store, transform it, and insert it into the SQL store.\nRelational Systems A relational system can be done in a number of ways:\nIn the same manner as the Non-SQL system: with a periodical job In a similar manner to the Event Sourced system: Updating a second table at the same time as the primary tables Using SQL triggers: on insert, add a row to the integration table etc. I wouldn’t recommend the 3rd option, as you will start ending up with more and more logic living in larger and larger triggers. The important point on all these methods is that the Integration tables are separate from the main tables: you do not want to expose your internal implementation to external consumers.\n","wordCount":"537","inLanguage":"en","datePublished":"2016-06-09T00:00:00Z","dateModified":"2016-06-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2016/06/09/database-integrations-for-microservices/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Database Integrations for MicroServices</h1><div class=post-meta>&lt;span title='2016-06-09 00:00:00 +0000 UTC'>June 9, 2016&lt;/span>&amp;nbsp;·&amp;nbsp;3 min</div></header><div class=post-content><p>This is a follow up post after seeing <a href=https://twitter.com/francmichal>Michal Franc</a>&rsquo;s NDC talk on migrating from Monolithic architectures.</p><p>One point raised was that Database Integration points are a terrible idea - and I wholeheartedly agree. However, there can be a number of situations where a Database Integration is the best or only way to achieve the end goal. This can be either technical; say a tool does not support API querying (looking at you SSRS), or cultural; the other team either don&rsquo;t have the willingness, time, or power to learn how to query an API.</p><p>One common situation is a reporting team, who either cannot query an API (e.g. they are stuck using SSRS), or don&rsquo;t want/have time to learn how to query an API.</p><p>There are two ways which can make a Database Integration an altogether less painful prospect, both with a common starting point: A separate login to the Database, with only readonly access to a very small set of tables and views.</p><p>Views can be used to create a representation of the service&rsquo;s data in a manner which makes sense to external systems, for example de-normalising tables, or converting integer based enumerations into their string counterparts.</p><p>Tables can be used to expose a transformed version of the service&rsquo;s data, for example a readmodel from an event stream.</p><h2 id=event-sourcing-source-data>Event Sourcing source data<a hidden class=anchor aria-hidden=true href=#event-sourcing-source-data>#</a></h2><p>For example, one of our services uses Event Sourcing. It uses projections to construct readmodels as events are stored (we use the <a href=https://www.nuget.org/packages/ledger>Ledger</a> library, and a SqlServer backend for this.) To provide a Database Integeration point, we have a second set of projections which populate a set of tables specifically for external querying.</p><p>If the following event was committed to the store:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;eventType&#34;</span>: <span style=color:#e6db74>&#34;phoneNumberAdded&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;aggregateID&#34;</span>: <span style=color:#ae81ff>231231</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;number&#34;</span>: <span style=color:#e6db74>&#34;01230 232323&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;home&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The readmodel table, which is just two columns: <code>id:int</code> and <code>json:varchar(max)</code>, would get updated to look like this:</p><pre tabindex=0><code>id      | json
--------+-------------------------------------------------
231231  | {
            &#34;id&#34;: 231231,
            &#34;name&#34;: &#34;Andy Dote&#34;,
            &#34;phones&#34;: [
              { &#34;type&#34;: &#34;mobile&#34;, &#34;number&#34;: &#34;0712345646&#34; },
              { &#34;type&#34;: &#34;home&#34;, &#34;number&#34;: &#34;01230 232323&#34; }
            ]
          }
</code></pre><p>The external integration table, which is a denormalised view of the data would get updated to look like this:</p><pre tabindex=0><code>id      | name      | home_phone    | mobile_phone
--------+-----------+---------------+----------------------
231231  | Andy Dote | 01230 232 323 | 07123 456 456
</code></pre><h3 id=non-sql-systems>Non-SQL Systems<a hidden class=anchor aria-hidden=true href=#non-sql-systems>#</a></h3><p>While I have not needed to implement this yet, there is a plan for how to do it: a simple regular job which will pull the data from the service&rsquo;s main store, transform it, and insert it into the SQL store.</p><h3 id=relational-systems>Relational Systems<a hidden class=anchor aria-hidden=true href=#relational-systems>#</a></h3><p>A relational system can be done in a number of ways:</p><ul><li>In the same manner as the Non-SQL system: with a periodical job</li><li>In a similar manner to the Event Sourced system: Updating a second table at the same time as the primary tables</li><li>Using SQL triggers: on insert, add a row to the integration table etc.</li></ul><p>I wouldn&rsquo;t recommend the 3rd option, as you will start ending up with more and more logic living in larger and larger triggers.
The important point on all these methods is that the Integration tables are separate from the main tables: you do not want to expose your internal implementation to external consumers.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li><li><a href=https://andydote.co.uk/tags/integration/>integration</a></li><li><a href=https://andydote.co.uk/tags/eventsourcing/>eventsourcing</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2016/07/17/preventing-microservice-boilerplate/><span class=title>« Prev Page</span><br><span>Preventing MicroService Boilerplate</span>
</a><a class=next href=https://andydote.co.uk/2016/03/19/cqs-with-mediatr/><span class=title>Next Page »</span><br><span>CQS with Mediatr</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>