<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How do you tag docker images? | Andy Dote</title><meta name=keywords content="docker,architecture"><meta name=description content="An interesting question came up at work today: how do you tag your Docker images? In previous projects, I&rsquo;ve always used a short git sha, or sometimes a semver, but with no great consistency.
As luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn&rsquo;t make a lot of sense and, worst of all, it was a manual process."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2021/11/10/docker-tagging/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ea821116adbd94ff8c04bf7745204429750a1079f16951db0415b837fc273249.css integrity="sha256-6oIRFq29lP+MBL93RSBEKXUKEHnxaVHbBBW4N/wnMkk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How do you tag docker images?"><meta property="og:description" content="An interesting question came up at work today: how do you tag your Docker images? In previous projects, I&rsquo;ve always used a short git sha, or sometimes a semver, but with no great consistency.
As luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn&rsquo;t make a lot of sense and, worst of all, it was a manual process."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2021/11/10/docker-tagging/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-11-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-10T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How do you tag docker images?"><meta name=twitter:description content="An interesting question came up at work today: how do you tag your Docker images? In previous projects, I&rsquo;ve always used a short git sha, or sometimes a semver, but with no great consistency.
As luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn&rsquo;t make a lot of sense and, worst of all, it was a manual process."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"How do you tag docker images?","item":"https://andydote.co.uk/2021/11/10/docker-tagging/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How do you tag docker images?","name":"How do you tag docker images?","description":"An interesting question came up at work today: how do you tag your Docker images? In previous projects, I\u0026rsquo;ve always used a short git sha, or sometimes a semver, but with no great consistency.\nAs luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn\u0026rsquo;t make a lot of sense and, worst of all, it was a manual process.","keywords":["docker","architecture"],"articleBody":"An interesting question came up at work today: how do you tag your Docker images? In previous projects, I’ve always used a short git sha, or sometimes a semver, but with no great consistency.\nAs luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn’t make a lot of sense and, worst of all, it was a manual process. One of the things that I push at all clients is documenting all architectural decisions made, in the form of Architecture Decision Records, so I’m reproducing it here, with a few details changed to mask where this happened.\nOne of the most interesting points of this is that I went in with an idea on the right way to do this, and over the course of discussion and review of the document, changed my mind.\nChange Versioning Scheme Status Accepted\nContext Currently, the UI uses a SemVer style version number. However, we have no convention for what kind of modifications constitute a major, minor, or patch change. We also have no processes or people who care specifically about what kind of change it is, just that a new version was deployed.\nThe other problem with using SemVer is that people wait until a branch has been approved, and then make an additional commit with the version number change (as another prod deployment might have happened in the meantime), meaning they need to wait for an additional build before they can deploy.\nNot to mention, it’s possible to accidentally go backwards in numbers if a value was misread or if someone forgets to update the version number in their branch.\nConsidered Options 1. Auto-incrementing integer version On production deployment, we would write a version number to the application. The negative of this approach is not having a version number in pre-production environments, such as test environments.\nWe could generate the number on the build phase (when the container is created), but this means that we might not release versions “in order”, as the order of what feature is deployed to production is not guaranteed, although the need to merge master into your branch would mean a rebuild, so a new version could be generated.\nThis method would also mean gaps in version numbers, as not all builds hit production, which might be a touch confusing.\nAnother issue with this method is that we build multiple containers from the same commit in separate pipelines, so we would need some way to generate a version in both pipelines which would match, which would mean either a function deriving from the commit hash or a service which would calculate and cache version numbers so they could be generated and looked up by multiple pipelines.\nExample Version:\n1870 2. Git (short) sha of the commit On build, write the short (7 char) SHA as the version number. The negative of this approach is not having an easy to understand order of version numbers. However, this scheme means we can easily see exactly which commit is currently running in production (or any environment, for that matter.)\nExample Version:\n84d33bb 3. Build ID from CI System On build, embed the buildID as the version number. The pipeline id is a 24 character string consisting of numbers and letters, so this is functionally similar to Option 2, but with a longer number that doesn’t tie back to a commit.\nAs with Option 1, we would need to decide if this number comes from the build pipeline, or from the deployment pipeline. This also has the same multi-pipeline problem too.\nExample Version:\n611a0be261ddea19dab67c22 4. Datestamp On build, use the current commit’s datestamp as the tag.\nAs long as we keep the resolution of the datestamp large enough, the multiple pipelines needing to generate the same ID shouldn’t be a problem. I guess 1-minute resolution would be enough, although if a rebuild is needed (e.g. flakey internet connection), we would end up with a different datestamp.\nExample Version:\n2021-08-16.13-07 5. Commit Datestamp Similar to Option 4, except we use the commit’s commit date to build the version number. This solves multiple pipelines needing to generate the same tag in parallel, as well as being unique and ordered. The timestamps can also be higher precision than Option 4, as we don’t need to hope that pipelines start at a close enough time.\nThis is how we would generate it:\ntimestamp=$(git show -s --format=%cd --date=\"format:%Y-%m-%d.%H-%M-%S\") Example Version:\n2021-08-16.13-07-34 6. Automatic SemVer On build, calculate the version number using Semantic-Release.\nThis method means that we would need to start enforcing commit message styles, and I am not sure the format that Semantic Release is ideal for us, so it might be better to cover the commit message formatting outside this process.\nThe commit format would be as follows:\n(): │ │ │ │ │ └─⫸ Summary in the present tense. Not capitalized. No period at the end. │ │ │ └─⫸ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core| │ elements|forms|http|language-service|localize|platform-browser| │ platform-browser-dynamic|platform-server|router|service-worker| │ upgrade|zone.js|packaging|changelog|dev-infra|docs-infra|migrations| │ ngcc|ve │ └─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|test Having worked in repositories with this enforced, I would recommend against it, as it causes a lot of frustration (“omg why has my commit been rejected again?!”) and as mentioned in other options, I am not sure semver itself makes sense for our UI (or UI projects in general.)\nWe will still need developers to decide if a given commit is a major/minor/patch.\nExample Version:\n13.4.17 6. Combination: Datestamp + Git On build, use a combination of Option 5 and Option 2 to generate a unique build number.\nThis method had the advantage of the meaning of the date, with the uniqueness of the git commit, but the likelihood of us needing to distinguish two commits made at identical times by their commit sha is unlikely, especially as we require clean merges to master.\nExample Version:\n2021-08-16.13-07-34.84d33bb Chosen Decision Option 5\nWe will also embed other build information as labels in the docker container, such as:\nbranch name pipeline/build number git hash git commit timestamp Consequences No need to tag commits as a released version, but we could automate this if we wanted No need to rebuild for changing the version number No need to remember to change the version number No need to decide on major/minor/patch semantics Gain an understandable version number, with meaning Summary As I said earlier, I went into this process (which I drove) wanting to pick the 2nd option - Short Git Sha, and I came away agreeing that the commit datestamp was the best thing to use.\nNot only was my mind changed in the course of this, but also people who join the project later can check out the ./docs/adr/ and see what options we considered for everything about this project, and how we arrived at the conclusions. It also means I have examples to refer back to when people ask interesting questions at work.\nHow do you tag your containers?\n","wordCount":"1170","inLanguage":"en","datePublished":"2021-11-10T00:00:00Z","dateModified":"2021-11-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2021/11/10/docker-tagging/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>How do you tag docker images?</h1><div class=post-meta><span title='2021-11-10 00:00:00 +0000 UTC'>November 10, 2021</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>An interesting question came up at work today: how do you tag your Docker images? In previous projects, I&rsquo;ve always used a short git sha, or sometimes a semver, but with no great consistency.</p><p>As luck would have it, I had pushed for a change in tagging format at a client not so long ago as the method we were using didn&rsquo;t make a lot of sense and, worst of all, it was a <em>manual</em> process. One of the things that I push at all clients is documenting all architectural decisions made, in the form of <a href=/2019/06/29/architecture-decision-records>Architecture Decision Records</a>, so I&rsquo;m reproducing it here, with a few details changed to mask where this happened.</p><p>One of the most interesting points of this is that I went in with an idea on the right way to do this, and over the course of discussion and review of the document, <em>changed my mind</em>.</p><hr><h2 id=change-versioning-scheme>Change Versioning Scheme<a hidden class=anchor aria-hidden=true href=#change-versioning-scheme>#</a></h2><h3 id=status>Status<a hidden class=anchor aria-hidden=true href=#status>#</a></h3><p>Accepted</p><h3 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h3><p>Currently, the UI uses a <a href=https://semver.org/>SemVer</a> style version number. However, we have no convention for what kind of modifications constitute a major, minor, or patch change. We also have no processes or people who care specifically about what kind of change it is, just that a new version was deployed.</p><p>The other problem with using SemVer is that people wait until a branch has been approved, and then make an additional commit with the version number change (as another prod deployment might have happened in the meantime), meaning they need to wait for an additional build before they can deploy.</p><p>Not to mention, it&rsquo;s possible to accidentally go backwards in numbers if a value was misread or if someone forgets to update the version number in their branch.</p><h3 id=considered-options>Considered Options<a hidden class=anchor aria-hidden=true href=#considered-options>#</a></h3><h4 id=1-auto-incrementing-integer-version>1. Auto-incrementing integer version<a hidden class=anchor aria-hidden=true href=#1-auto-incrementing-integer-version>#</a></h4><p>On production deployment, we would write a version number to the application. The negative of this approach is not having a version number in pre-production environments, such as test environments.</p><p>We could generate the number on the build phase (when the container is created), but this means that we might not release versions &ldquo;in order&rdquo;, as the order of what feature is deployed to production is not guaranteed, although the need to merge <code>master</code> into your branch would mean a rebuild, so a new version could be generated.</p><p>This method would also mean gaps in version numbers, as not all builds hit production, which might be a touch confusing.</p><p>Another issue with this method is that we build multiple containers from the same commit in separate pipelines, so we would need some way to generate a version in both pipelines which would match, which would mean either a function deriving from the commit hash or a service which would calculate and cache version numbers so they could be generated and looked up by multiple pipelines.</p><p>Example Version:</p><pre tabindex=0><code>1870
</code></pre><h4 id=2-git-short-sha-of-the-commit>2. Git (short) sha of the commit<a hidden class=anchor aria-hidden=true href=#2-git-short-sha-of-the-commit>#</a></h4><p>On build, write the short (7 char) SHA as the version number. The negative of this approach is not having an easy to understand order of version numbers. However, this scheme means we can easily see exactly which commit is currently running in production (or any environment, for that matter.)</p><p>Example Version:</p><pre tabindex=0><code>84d33bb
</code></pre><h4 id=3-build-id-from-ci-system>3. Build ID from CI System<a hidden class=anchor aria-hidden=true href=#3-build-id-from-ci-system>#</a></h4><p>On build, embed the buildID as the version number. The pipeline id is a 24 character string consisting of numbers and letters, so this is functionally similar to <a href=#2-git-short-sha-of-the-commit>Option 2</a>, but with a longer number that doesn&rsquo;t tie back to a commit.</p><p>As with <a href=#1-auto-incrementing-integer-version>Option 1</a>, we would need to decide if this number comes from the build pipeline, or from the deployment pipeline. This also has the same multi-pipeline problem too.</p><p>Example Version:</p><pre tabindex=0><code>611a0be261ddea19dab67c22
</code></pre><h4 id=4-datestamp>4. Datestamp<a hidden class=anchor aria-hidden=true href=#4-datestamp>#</a></h4><p>On build, use the current commit&rsquo;s datestamp as the tag.</p><p>As long as we keep the resolution of the datestamp large enough, the multiple pipelines needing to generate the same ID shouldn&rsquo;t be a problem. I guess 1-minute resolution would be enough, although if a rebuild is needed (e.g. flakey internet connection), we would end up with a different datestamp.</p><p>Example Version:</p><pre tabindex=0><code>2021-08-16.13-07
</code></pre><h4 id=5-commit-datestamp>5. Commit Datestamp<a hidden class=anchor aria-hidden=true href=#5-commit-datestamp>#</a></h4><p>Similar to <a href=#4-datestamp>Option 4</a>, except we use the commit&rsquo;s commit date to build the version number. This solves multiple pipelines needing to generate the same tag in parallel, as well as being unique and ordered. The timestamps can also be higher precision than <a href=#4-datestamp>Option 4</a>, as we don&rsquo;t need to hope that pipelines start at a close enough time.</p><p>This is how we would generate it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>timestamp<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>git show -s --format<span style=color:#f92672>=</span>%cd --date<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;format:%Y-%m-%d.%H-%M-%S&#34;</span><span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>Example Version:</p><pre tabindex=0><code>2021-08-16.13-07-34
</code></pre><h4 id=6-automatic-semver>6. Automatic SemVer<a hidden class=anchor aria-hidden=true href=#6-automatic-semver>#</a></h4><p>On build, calculate the version number using <a href=https://github.com/semantic-release/semantic-release>Semantic-Release</a>.</p><p>This method means that we would need to start enforcing commit message styles, and I am not sure the format that Semantic Release is ideal for us, so it might be better to cover the commit message formatting outside this process.</p><p>The commit format would be as follows:</p><pre tabindex=0><code>&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;
│       │             │
│       │             └─⫸ Summary in the present tense. Not capitalized. No period at the end.
│       │
│       └─⫸ Commit Scope: animations|bazel|benchpress|common|compiler|compiler-cli|core|
│                          elements|forms|http|language-service|localize|platform-browser|
│                          platform-browser-dynamic|platform-server|router|service-worker|
│                          upgrade|zone.js|packaging|changelog|dev-infra|docs-infra|migrations|
│                          ngcc|ve
│
└─⫸ Commit Type: build|ci|docs|feat|fix|perf|refactor|test
</code></pre><p>Having worked in repositories with this enforced, I would recommend against it, as it causes a lot of frustration (&ldquo;omg <em>why</em> has my commit been rejected again?!&rdquo;) and as mentioned in other options, I am not sure semver itself makes sense for our UI (or UI projects in general.)</p><p>We will still need developers to decide if a given commit is a major/minor/patch.</p><p>Example Version:</p><pre tabindex=0><code>13.4.17
</code></pre><h4 id=6-combination-datestamp--git>6. Combination: Datestamp + Git<a hidden class=anchor aria-hidden=true href=#6-combination-datestamp--git>#</a></h4><p>On build, use a combination of <a href=#5-commit-datestamp>Option 5</a> and <a href=#2-git-short-sha-of-the-commit>Option 2</a> to generate a unique build number.</p><p>This method had the advantage of the meaning of the date, with the uniqueness of the git commit, but the likelihood of us needing to distinguish two commits made at identical times by their commit sha is unlikely, especially as we require clean merges to master.</p><p>Example Version:</p><pre tabindex=0><code>2021-08-16.13-07-34.84d33bb
</code></pre><h3 id=chosen-decision>Chosen Decision<a hidden class=anchor aria-hidden=true href=#chosen-decision>#</a></h3><p><a href=#5-commit-datestamp>Option 5</a></p><p>We will also embed other build information as labels in the docker container, such as:</p><ul><li>branch name</li><li>pipeline/build number</li><li>git hash</li><li>git commit timestamp</li></ul><h3 id=consequences>Consequences<a hidden class=anchor aria-hidden=true href=#consequences>#</a></h3><ul><li>No need to tag commits as a released version, but we could automate this if we wanted</li><li>No need to rebuild for changing the version number</li><li>No need to remember to change the version number</li><li>No need to decide on major/minor/patch semantics</li><li>Gain an understandable version number, with meaning</li></ul><hr><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>As I said earlier, I went into this process (which I drove) wanting to pick the 2nd option - Short Git Sha, and I came away agreeing that the commit datestamp was the best thing to use.</p><p>Not only was my mind changed in the course of this, but also people who join the project later can check out the <code>./docs/adr/</code> and see what options we considered for everything about this project, and how we arrived at the conclusions. It also means I have examples to refer back to when people ask interesting questions at work.</p><p>How do <em>you</em> tag your containers?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/docker/>docker</a></li><li><a href=https://andydote.co.uk/tags/architecture/>architecture</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2021/11/22/nomad-operator-pattern/><span class=title>« Prev Page</span><br><span>The Operator Pattern in Nomad</span></a>
<a class=next href=https://andydote.co.uk/2021/06/02/os-cpus-and-kubernetes/><span class=title>Next Page »</span><br><span>The Problem with CPUs and Kubernetes</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>