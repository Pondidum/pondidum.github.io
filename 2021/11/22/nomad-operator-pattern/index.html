<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Operator Pattern in Nomad | Andy Dote</title><meta name=keywords content="infrastructure,nomad,kubernetes"><meta name=description content="The Operator Pattern from Kubernetes is an excellent way of handling tasks in a cluster in an automated way, for example, provisioning applications, running backups, requesting certificates, and injecting chaos testing.
As a Nomad user, I wanted to do something similar for my clusters, so I set about seeing how it would be possible. It turns out; it is much easier than I expected! While Nomad doesn&rsquo;t support the idea of Custom Resource Definitions, we can achieve an operator by utilising a regular Nomad job and the nomad HTTP API."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2021/11/22/nomad-operator-pattern/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="The Operator Pattern in Nomad"><meta property="og:description" content="The Operator Pattern from Kubernetes is an excellent way of handling tasks in a cluster in an automated way, for example, provisioning applications, running backups, requesting certificates, and injecting chaos testing.
As a Nomad user, I wanted to do something similar for my clusters, so I set about seeing how it would be possible. It turns out; it is much easier than I expected! While Nomad doesn&rsquo;t support the idea of Custom Resource Definitions, we can achieve an operator by utilising a regular Nomad job and the nomad HTTP API."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2021/11/22/nomad-operator-pattern/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-11-22T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Operator Pattern in Nomad"><meta name=twitter:description content="The Operator Pattern from Kubernetes is an excellent way of handling tasks in a cluster in an automated way, for example, provisioning applications, running backups, requesting certificates, and injecting chaos testing.
As a Nomad user, I wanted to do something similar for my clusters, so I set about seeing how it would be possible. It turns out; it is much easier than I expected! While Nomad doesn&rsquo;t support the idea of Custom Resource Definitions, we can achieve an operator by utilising a regular Nomad job and the nomad HTTP API."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"The Operator Pattern in Nomad","item":"https://andydote.co.uk/2021/11/22/nomad-operator-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Operator Pattern in Nomad","name":"The Operator Pattern in Nomad","description":"The Operator Pattern from Kubernetes is an excellent way of handling tasks in a cluster in an automated way, for example, provisioning applications, running backups, requesting certificates, and injecting chaos testing.\nAs a Nomad user, I wanted to do something similar for my clusters, so I set about seeing how it would be possible. It turns out; it is much easier than I expected! While Nomad doesn\u0026rsquo;t support the idea of Custom Resource Definitions, we can achieve an operator by utilising a regular Nomad job and the nomad HTTP API.","keywords":["infrastructure","nomad","kubernetes"],"articleBody":"The Operator Pattern from Kubernetes is an excellent way of handling tasks in a cluster in an automated way, for example, provisioning applications, running backups, requesting certificates, and injecting chaos testing.\nAs a Nomad user, I wanted to do something similar for my clusters, so I set about seeing how it would be possible. It turns out; it is much easier than I expected! While Nomad doesn’t support the idea of Custom Resource Definitions, we can achieve an operator by utilising a regular Nomad job and the nomad HTTP API.\nThe Setup We’re going to build an automated backup operator! We’ll use the Nomad Streaming API to watch for jobs being registered and deregistered. If a job has some metadata for auto backup, we’ll create (or update) a backup job. If a job is deregistered or doesn’t have any auto backup metadata, we’ll try to delete a backup job if it exists.\nThe complete source code is available in the Nomad-Operator repo on my GitHub.\nConsuming the Nomad Streaming API The Nomad Go API library makes it easy to consume the streaming API, handling all the details, such as deserialisation for us.\nThe client is created with no additional parameters, as the Address and SecretID will be populated from environment variables automatically (NOMAD_ADDR and NOMAD_TOKEN respectively):\nclient, err := api.NewClient(\u0026api.Config{}) if err != nil {  return err } As we want to only listen to jobs that have been modified after our application deploys, we need to query what the current job index is at startup:\nvar index uint64 = 0 if _, meta, err := client.Jobs().List(nil); err == nil {  index = meta.LastIndex } Next, we use the EventStream API and subscribe to all job event types (in practice, this means JobRegistered, JobDeregistered, and JobBatchDeregistered):\ntopics := map[api.Topic][]string{  api.TopicJob: {\"*\"}, }  eventsClient := client.EventStream() eventCh, err := eventsClient.Stream(ctx, topics, index, \u0026api.QueryOptions{}) if err != nil {  return err } The Stream(...) call itself returns a channel which we can loop over forever consuming events, ignoring the heartbeat events:\nfor {  select {  case ctx.Done():  return nil   case event := eventCh:   if event.IsHeartbeat() {  continue  }   c.handleEvent(event)  } } Finally, this operator only cares about jobs being registered and deregistered, so we loop through all the events and only handle the JobRegistered and JobDeregistered events:\nfor _, e := range event.Events {   if e.Type != \"JobRegistered\" \u0026\u0026 e.Type != \"JobDeregistered\" {  return  }   job, err := e.Job()  if err != nil {  return  }   c.onJob(e.Type, job) } Handling Jobs When we see jobs, we need to handle a few different cases:\n Jobs which are backup jobs themselves should be ignored Jobs without backup settings should have their backup job removed (if it exists) Jobs with backup settings should have their job created (or updated if it exists) Deregistered jobs should have their backup job removed (if it exists)  We’re using the job level meta stanza in the .nomad files for our settings, which looks something like this:\ntask \"server\" {  meta {  auto-backup = true  backup-schedule = \"@daily\"  backup-target-db = \"postgres\"  } } func (b *Backup) OnJob(eventType string, job *api.Job) {   if strings.HasPrefix(*job.ID, \"backup-\") {  return  }   backupID := \"backup-\" + *job.ID  settings, enabled := b.parseMeta(job.Meta)   if eventType == \"JobDeregistered\" {  b.tryRemoveBackupJob(backupID)  return  }   if !enabled {  b.tryRemoveBackupJob(backupID)  return  }   b.createBackupJob(backupID, settings) } Attempting to remove the job is straightforward as we don’t care if it fails - it could be that the job doesn’t exist, or is already stopped, or any other number of reasons, so we can use the Deregister() call and discard the output:\nfunc (b *Backup) tryRemoveBackupJob(jobID string) {  b.client.Jobs().Deregister(jobID, false, \u0026api.WriteOptions{}) } Creating the backup job involves rendering a go template of the nomad file we will use, and then calling Register to submit the job to Nomad. We’re using the fact that our backup IDs are stable, so re-running the same backup ID will replace the job with a new version.\nfunc (b *Backup) createBackupJob(id string, s settings) error {   t, err := template.New(\"\").Delims(\"[[\", \"]]\").Parse(backupHcl)  if err != nil {  return err  }   var buffer bytes.Buffer  if err := t.Execute(\u0026buffer, s); err != nil {  return err  }   backup, err := jobspec.Parse(\u0026buffer)  if err != nil {  return err  }   _, _, err = b.client.Jobs().Register(backup, nil)  return err } The nomad file is embedded using the Go embed package to store the .nomad file in the binary, so we still have a single artefact to deploy:\n//go:embed backup.nomad var backupHcl string And the backup.nomad file itself is a go template with custom delimiters ([[ and ]]) for fields, as the .nomad file, can contain {{ }} when using the inbuilt templating for populating secrets, amongst other things:\njob \"[[ .JobID ]]\" {  datacenters = [\"dc1\"]   type = \"batch\"   periodic {  cron = \"[[ .Schedule ]]\"  prohibit_overlap = true  }   group \"backup\" {   task \"backup\" {  driver = \"docker\"   config {  image = \"alpine:latest\"  command = \"echo\"  args = [ \"backing up [[ .SourceJobID ]]'s [[ .TargetDB ]] database\" ]  }   env {  PGHOST = \"postgres.service.consul\"  PGDATABASE = \"[[ .TargetDB ]]\"  AWS_REGION = \"eu-west-1\"  }  }  } } Testing (Manual) The great thing about developing against Nomad is that testing is straightforward. We can start a local copy by running nomad agent -dev, and then run our application locally to check it works properly, before needing to package it up into a Docker container and deploying it to a real cluster. It also doesn’t need to be packaged in a container for Nomad; we could use Isolated Exec or Raw Exec too.)\nThere is a start.sh script in the repository which will use tmux to start 3 terminals, one to run a Nomad agent in dev mode (nomad agent -dev), one to build and run the operator (go build \u0026\u0026 ./operator), and one to register and deregister nomad jobs.\nWhen all is ready, submit the example job with the following command:\nnomad job run example.nomad Will cause the following output in the operator’s terminal:\n== JobRegistered: example (pending)... Registering backup job Backup created: backup-example -- Done == JobRegistered: backup-example (running)... Job is a backup, skipping We can also check the Nomad UI, running on http://localhost:4646, which shows our two jobs:\nNote how the example job is a service, which continuously runs, and the backup-example is a periodic job, scheduled to run daily.\nRemoving the example job with the following command:\nnomad job stop example This will be seen by the operator, which will remove the backup job:\n== JobDeregistered: example (running)... Trying to remove a backup, if any == JobDeregistered: backup-example (dead)... Job is a backup, skipping Note how it also sees the backup-example job being deregistered and ignores it as, in our case, backups don’t have backups!\nTesting (Automated) We can also write automated tests in two ways for this operator; Tests that run against a saved or synthetic event stream, and tests that work in the same way as the manual test; start Nomad, run a test suite; stop Nomad.\nReading from a file of known events, we can test the handleEvent function directly:\nseenEvents := []string{}  c := NewConsumer(nil, func(eventType string, job *api.Job) {  seenEvents = append(seenEvents, eventType) })  for _, line := range strings.Split(eventsJson, \"\\n\") {  var events api.Events  json.Unmarshal([]byte(line), \u0026events)   c.handleEvent(\u0026events) }  assert.Len(t, seenEvents, 2) assert.Equal(t, []string{\"JobRegistered\", \"JobDeregistered\"}, seenEvents) } The other way of testing is running a nomad instance in dev mode next to the application and registering jobs to it. Usually, when doing this, I would start the Nomad application before running the tests and then stop it after, to save the time of waiting for Nomad to start between each test:\nwait := make(chan bool, 1)  client, err := api.NewClient(\u0026api.Config{}) assert.NoError(t, err)  seenJobID := \"\" c := NewConsumer(client, func(eventType string, job *api.Job) {  seenJobID = *job.ID  wait  true })  go c.Start()  //register a job job, err := jobspec.Parse(strings.NewReader(withBackupHcl)) assert.NoError(t, err)  client.Jobs().Register(job, \u0026api.WriteOptions{})  // block until the job handler has run once wait  assert.Equal(t, *job.ID, seenJobID) As this is running against a real copy of Nomad, we need to wait for jobs to be registered and only stop our test once things have been processed; hence we use a bool channel to block until our job handler has seen a job.\nIn a real test suite, you would need to make the job handler filter to the specific job it is looking for; as this would prevent shared state issues (currently this will stop after any job is seen), and thus allow you to run the tests in parallel.\nDeployment No operator pattern would be complete without pushing the operator itself into the Nomad cluster, and while we could just run the binary directly in Nomad (utilising the Artifact Stanza and Isolated Exec), its probably easier to create a docker container.\nWe have a single Dockerfile with a multistage build so that our output container only contains the binary itself, rather than all the layers and intermediate artefacts from the build process:\nFROMgolang:1.16.10-alpine3.14 as builderWORKDIR/appCOPY go.mod go.sum ./RUN go mod downloadCOPY . ./RUN go buildFROMalpine:3.14 as outputCOPY --from=builder /app/operator /usr/local/bin/operatorOnce the container is built and tagged:\ndocker build -t operator:local . We can verify it works as intended by running the container directly; --net=host is passed to the run command so that the operator can connect to Nomad on localhost:4646, rather than having to pass in our host IP through an environment variable. If you want to do this, add -e NOMAD_ADDR=http://SOME_IP_OR_HOST:4646 to the docker run command:\ndocker run --rm -it --net=host operator:local Assuming we’re happy, we can run the Operator container in our local Nomad instance without pushing it:\ntask \"operator\" {  driver = \"docker\"   config {  image = \"operator:latest\"  }   template {  data = {{ with secret \"nomad/creds/operator-job\" }} NOMAD_TOKEN={{ .Data.secret_id | toJSON }} {{ end }} EOF  destination = \"secrets/db.env\"  env = true  }   env {  NOMAD_ADDR = \"nomad.service.consul\"  } } Wrapping Up The Operator Pattern is a great way to handle everyday tasks that a cluster operator would normally, and I have used it to handle things like automatic backups, certificate generation (at least until Vault supports LetEncrypt), and job cleanup (for example, developer branch builds only stay in the cluster for 3 days.)\n","wordCount":"1702","inLanguage":"en","datePublished":"2021-11-22T00:00:00Z","dateModified":"2021-11-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2021/11/22/nomad-operator-pattern/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>The Operator Pattern in Nomad</h1><div class=post-meta><span title="2021-11-22 00:00:00 +0000 UTC">November 22, 2021</span>&nbsp;·&nbsp;8 min</div></header><div class=post-content><p>The <a href=https://kubernetes.io/docs/concepts/extend-kubernetes/operator/>Operator Pattern</a> from Kubernetes is an excellent way of handling tasks in a cluster in an automated way, for example, provisioning applications, running backups, requesting certificates, and injecting chaos testing.</p><p>As a Nomad user, I wanted to do something similar for my clusters, so I set about seeing how it would be possible. It turns out; it is much easier than I expected! While Nomad doesn&rsquo;t support the idea of Custom Resource Definitions, we can achieve an operator by utilising a regular Nomad job and the nomad HTTP API.</p><h2 id=the-setup>The Setup<a hidden class=anchor aria-hidden=true href=#the-setup>#</a></h2><p>We&rsquo;re going to build an automated backup operator! We&rsquo;ll use the <a href=https://www.nomadproject.io/api-docs/events>Nomad Streaming API</a> to watch for jobs being registered and deregistered. If a job has some metadata for auto backup, we&rsquo;ll create (or update) a backup job. If a job is deregistered or doesn&rsquo;t have any auto backup metadata, we&rsquo;ll try to delete a backup job if it exists.</p><p>The complete source code is available in the <a href=https://github.com/Pondidum/nomad-operator>Nomad-Operator</a> repo on my GitHub.</p><h2 id=consuming-the-nomad-streaming-api>Consuming the Nomad Streaming API<a hidden class=anchor aria-hidden=true href=#consuming-the-nomad-streaming-api>#</a></h2><p>The <a href=https://pkg.go.dev/github.com/hashicorp/nomad/api>Nomad Go API library</a> makes it easy to consume the streaming API, handling all the details, such as deserialisation for us.</p><p>The client is created with no additional parameters, as the <code>Address</code> and <code>SecretID</code> will be populated from environment variables automatically (<code>NOMAD_ADDR</code> and <code>NOMAD_TOKEN</code> respectively):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>NewClient</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Config</span>{})
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As we want to only listen to jobs that have been modified after our application deploys, we need to query what the current job index is at startup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>index</span> <span style=color:#66d9ef>uint64</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>meta</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Jobs</span>().<span style=color:#a6e22e>List</span>(<span style=color:#66d9ef>nil</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>index</span> = <span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>LastIndex</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we use the <code>EventStream</code> API and subscribe to all job event types (in practice, this means <code>JobRegistered</code>, <code>JobDeregistered</code>, and <code>JobBatchDeregistered</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>topics</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Topic</span>][]<span style=color:#66d9ef>string</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>TopicJob</span>: {<span style=color:#e6db74>&#34;*&#34;</span>},
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>eventsClient</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>EventStream</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>eventCh</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>eventsClient</span>.<span style=color:#a6e22e>Stream</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>topics</span>, <span style=color:#a6e22e>index</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>QueryOptions</span>{})
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>Stream(...)</code> call itself returns a channel which we can loop over forever consuming events, ignoring the heartbeat events:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Done</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>event</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>eventCh</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>IsHeartbeat</span>() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>handleEvent</span>(<span style=color:#a6e22e>event</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, this operator only cares about jobs being registered and deregistered, so we loop through all the events and only handle the <code>JobRegistered</code> and <code>JobDeregistered</code> events:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>Events</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;JobRegistered&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;JobDeregistered&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>job</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Job</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>onJob</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>job</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=handling-jobs>Handling Jobs<a hidden class=anchor aria-hidden=true href=#handling-jobs>#</a></h2><p>When we see jobs, we need to handle a few different cases:</p><ul><li>Jobs which are backup jobs themselves should be ignored</li><li>Jobs without backup settings should have their backup job removed (if it exists)</li><li>Jobs with backup settings should have their job created (or updated if it exists)</li><li>Deregistered jobs should have their backup job removed (if it exists)</li></ul><p>We&rsquo;re using the job level <code>meta</code> stanza in the <code>.nomad</code> files for our settings, which looks something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-hcl data-lang=hcl><span style=display:flex><span><span style=color:#66d9ef>task</span> <span style=color:#e6db74>&#34;server&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>meta</span> {
</span></span><span style=display:flex><span>    auto-backup <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    backup-schedule <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;@daily&#34;</span>
</span></span><span style=display:flex><span>    backup-target-db <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;postgres&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Backup</span>) <span style=color:#a6e22e>OnJob</span>(<span style=color:#a6e22e>eventType</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>job</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Job</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#e6db74>&#34;backup-&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>backupID</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;backup-&#34;</span> <span style=color:#f92672>+</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>ID</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>settings</span>, <span style=color:#a6e22e>enabled</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>parseMeta</span>(<span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>Meta</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>eventType</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;JobDeregistered&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tryRemoveBackupJob</span>(<span style=color:#a6e22e>backupID</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>enabled</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tryRemoveBackupJob</span>(<span style=color:#a6e22e>backupID</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>createBackupJob</span>(<span style=color:#a6e22e>backupID</span>, <span style=color:#a6e22e>settings</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Attempting to remove the job is straightforward as we don&rsquo;t care if it fails - it could be that the job doesn&rsquo;t exist, or is already stopped, or any other number of reasons, so we can use the <code>Deregister()</code> call and discard the output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Backup</span>) <span style=color:#a6e22e>tryRemoveBackupJob</span>(<span style=color:#a6e22e>jobID</span> <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Jobs</span>().<span style=color:#a6e22e>Deregister</span>(<span style=color:#a6e22e>jobID</span>, <span style=color:#66d9ef>false</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>WriteOptions</span>{})
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Creating the backup job involves rendering a go template of the nomad file we will use, and then calling <code>Register</code> to submit the job to Nomad. We&rsquo;re using the fact that our backup IDs are stable, so re-running the same backup ID will replace the job with a new version.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>b</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Backup</span>) <span style=color:#a6e22e>createBackupJob</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>s</span> <span style=color:#a6e22e>settings</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>template</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;&#34;</span>).<span style=color:#a6e22e>Delims</span>(<span style=color:#e6db74>&#34;[[&#34;</span>, <span style=color:#e6db74>&#34;]]&#34;</span>).<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>backupHcl</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buffer</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Execute</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buffer</span>, <span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>backup</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>jobspec</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buffer</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Jobs</span>().<span style=color:#a6e22e>Register</span>(<span style=color:#a6e22e>backup</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The nomad file is embedded using the Go <a href=https://pkg.go.dev/embed>embed</a> package to store the <code>.nomad</code> file in the binary, so we still have a single artefact to deploy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//go:embed backup.nomad
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>backupHcl</span> <span style=color:#66d9ef>string</span>
</span></span></code></pre></div><p>And the <code>backup.nomad</code> file itself is a go template with custom delimiters (<code>[[</code> and <code>]]</code>) for fields, as the <code>.nomad</code> file, can contain <code>{{ }}</code> when using the inbuilt templating for populating secrets, amongst other things:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>job <span style=color:#e6db74>&#34;[[ .JobID ]]&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  datacenters <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;dc1&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;batch&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  periodic <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    cron             <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;[[ .Schedule ]]&#34;</span>
</span></span><span style=display:flex><span>    prohibit_overlap <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  group <span style=color:#e6db74>&#34;backup&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    task <span style=color:#e6db74>&#34;backup&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      driver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;docker&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      config <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        image   <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;alpine:latest&#34;</span>
</span></span><span style=display:flex><span>        command <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;echo&#34;</span>
</span></span><span style=display:flex><span>        args    <span style=color:#f92672>=</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;backing up [[ .SourceJobID ]]&#39;s [[ .TargetDB ]] database&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      env <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        PGHOST     <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;postgres.service.consul&#34;</span>
</span></span><span style=display:flex><span>        PGDATABASE <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;[[ .TargetDB ]]&#34;</span>
</span></span><span style=display:flex><span>        AWS_REGION <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;eu-west-1&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=testing-manual>Testing (Manual)<a hidden class=anchor aria-hidden=true href=#testing-manual>#</a></h2><p>The great thing about developing against Nomad is that testing is straightforward. We can start a local copy by running <code>nomad agent -dev</code>, and then run our application locally to check it works properly, <em>before</em> needing to package it up into a Docker container and deploying it to a real cluster. It also doesn&rsquo;t need to be packaged in a container for Nomad; we could use <a href=https://www.nomadproject.io/docs/drivers/exec>Isolated Exec</a> or <a href=https://www.nomadproject.io/docs/drivers/raw_exec>Raw Exec</a> too.)</p><p>There is a <code>start.sh</code> script in the repository which will use <code>tmux</code> to start 3 terminals, one to run a Nomad agent in dev mode (<code>nomad agent -dev</code>), one to build and run the operator (<code>go build && ./operator</code>), and one to register and deregister nomad jobs.</p><p>When all is ready, submit the example job with the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nomad job run example.nomad
</span></span></code></pre></div><p>Will cause the following output in the operator&rsquo;s terminal:</p><pre tabindex=0><code>==&gt; JobRegistered: example (pending)...
    Registering backup job
    Backup created: backup-example
--&gt; Done
==&gt; JobRegistered: backup-example (running)...
    Job is a backup, skipping
</code></pre><p>We can also check the Nomad UI, running on http://localhost:4646, which shows our two jobs:</p><p><img loading=lazy src=/images/nomad-backup-jobs.png alt="nomad jobs showing the example service and the backup periodic job"></p><p>Note how the <code>example</code> job is a <code>service</code>, which continuously runs, and the <code>backup-example</code> is a <code>periodic</code> job, scheduled to run daily.</p><p>Removing the example job with the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>nomad job stop example
</span></span></code></pre></div><p>This will be seen by the operator, which will remove the backup job:</p><pre tabindex=0><code>==&gt; JobDeregistered: example (running)...
    Trying to remove a backup, if any
==&gt; JobDeregistered: backup-example (dead)...
    Job is a backup, skipping
</code></pre><p>Note how it also sees the <code>backup-example</code> job being deregistered and ignores it as, in our case, backups don&rsquo;t have backups!</p><h2 id=testing-automated>Testing (Automated)<a hidden class=anchor aria-hidden=true href=#testing-automated>#</a></h2><p>We can also write automated tests in two ways for this operator; Tests that run against a saved or synthetic event stream, and tests that work in the same way as the manual test; start Nomad, run a test suite; stop Nomad.</p><p>Reading from a file of known events, we can test the <code>handleEvent</code> function directly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>seenEvents</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewConsumer</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>eventType</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>job</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Job</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>seenEvents</span> = append(<span style=color:#a6e22e>seenEvents</span>, <span style=color:#a6e22e>eventType</span>)
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>line</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>eventsJson</span>, <span style=color:#e6db74>&#34;\n&#34;</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>events</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Events</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>([]byte(<span style=color:#a6e22e>line</span>), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>events</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>handleEvent</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>events</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Len</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>seenEvents</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, []<span style=color:#66d9ef>string</span>{<span style=color:#e6db74>&#34;JobRegistered&#34;</span>, <span style=color:#e6db74>&#34;JobDeregistered&#34;</span>}, <span style=color:#a6e22e>seenEvents</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The other way of testing is running a nomad instance in dev mode next to the application and registering jobs to it. Usually, when doing this, I would start the Nomad application before running the tests and then stop it after, to save the time of waiting for Nomad to start between each test:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>wait</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>client</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>NewClient</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Config</span>{})
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>seenJobID</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewConsumer</span>(<span style=color:#a6e22e>client</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>eventType</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>job</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>Job</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>seenJobID</span> = <span style=color:#f92672>*</span><span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>ID</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>wait</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Start</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//register a job
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>job</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>jobspec</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>withBackupHcl</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>NoError</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Jobs</span>().<span style=color:#a6e22e>Register</span>(<span style=color:#a6e22e>job</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>WriteOptions</span>{})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// block until the job handler has run once
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>wait</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>job</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>seenJobID</span>)
</span></span></code></pre></div><p>As this is running against a real copy of Nomad, we need to wait for jobs to be registered and only stop our test once things have been processed; hence we use a <code>bool</code> channel to block until our job handler has seen a job.</p><p>In a real test suite, you would need to make the job handler filter to the specific job it is looking for; as this would prevent shared state issues (currently this will stop after <em>any</em> job is seen), and thus allow you to run the tests in parallel.</p><h2 id=deployment>Deployment<a hidden class=anchor aria-hidden=true href=#deployment>#</a></h2><p>No operator pattern would be complete without pushing the operator itself into the Nomad cluster, and while we <em>could</em> just run the binary directly in Nomad (utilising the <a href=https://www.nomadproject.io/docs/job-specification/artifact>Artifact Stanza</a> and <a href=https://www.nomadproject.io/docs/drivers/exec>Isolated Exec</a>), its probably easier to create a docker container.</p><p>We have a single <code>Dockerfile</code> with a multistage build so that our output container only contains the binary itself, rather than all the layers and intermediate artefacts from the build process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> golang:1.16.10-alpine3.14 as builder</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> go.mod go.sum ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go mod download<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> . ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> go build<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> alpine:3.14 as output</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>builder /app/operator /usr/local/bin/operator<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>Once the container is built and tagged:</p><pre tabindex=0><code>docker build -t operator:local .
</code></pre><p>We can verify it works as intended by running the container directly; <code>--net=host</code> is passed to the <code>run</code> command so that the operator can connect to Nomad on <code>localhost:4646</code>, rather than having to pass in our host IP through an environment variable. If you want to do this, add <code>-e NOMAD_ADDR=http://SOME_IP_OR_HOST:4646</code> to the <code>docker run</code> command:</p><pre tabindex=0><code>docker run --rm -it --net=host operator:local
</code></pre><p>Assuming we&rsquo;re happy, we can run the Operator container in our local Nomad instance without pushing it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>task <span style=color:#e6db74>&#34;operator&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  driver <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;docker&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  config <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    image <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;operator:latest&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  template <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    data <span style=color:#f92672>=</span> <span style=color:#e6db74>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {{ with secret &#34;nomad/creds/operator-job&#34; }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    NOMAD_TOKEN={{ .Data.secret_id  | toJSON }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    {{ end }}
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>    destination <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;secrets/db.env&#34;</span>
</span></span><span style=display:flex><span>    env <span style=color:#f92672>=</span> true
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  env <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    NOMAD_ADDR <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nomad.service.consul&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>The Operator Pattern is a great way to handle everyday tasks that a cluster operator would normally, and I have used it to handle things like automatic backups, certificate generation (at least until Vault supports LetEncrypt), and job cleanup (for example, developer branch builds only stay in the cluster for 3 days.)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/infrastructure/>infrastructure</a></li><li><a href=https://andydote.co.uk/tags/nomad/>nomad</a></li><li><a href=https://andydote.co.uk/tags/kubernetes/>kubernetes</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2022/04/23/nginx-dns/><span class=title>« Prev Page</span><br><span>An NGINX and DNS based outage</span></a>
<a class=next href=https://andydote.co.uk/2021/11/10/docker-tagging/><span class=title>Next Page »</span><br><span>How do you tag docker images?</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>