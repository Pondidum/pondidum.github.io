<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Adding Observability to Vault | Andy Dote</title>
<meta name=keywords content="observability,honeycomb,opentelemetry,infrastructure,vault"><meta name=description content="One of the things I like to do when setting up a Vault cluster is to visualise all the operations Vault is performing, which helps see usage patterns changing, whether there are lots of failed requests coming in, and what endpoints are receiving the most traffic.
While Vault has a lot of data available in Prometheus telemetry, the kind of information I am after is best taken from the Audit backend."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2021/05/27/vault-observe/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Adding Observability to Vault"><meta property="og:description" content="One of the things I like to do when setting up a Vault cluster is to visualise all the operations Vault is performing, which helps see usage patterns changing, whether there are lots of failed requests coming in, and what endpoints are receiving the most traffic.
While Vault has a lot of data available in Prometheus telemetry, the kind of information I am after is best taken from the Audit backend."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2021/05/27/vault-observe/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-05-27T00:00:00+00:00"><meta property="article:modified_time" content="2021-05-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Adding Observability to Vault"><meta name=twitter:description content="One of the things I like to do when setting up a Vault cluster is to visualise all the operations Vault is performing, which helps see usage patterns changing, whether there are lots of failed requests coming in, and what endpoints are receiving the most traffic.
While Vault has a lot of data available in Prometheus telemetry, the kind of information I am after is best taken from the Audit backend."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Adding Observability to Vault","item":"https://andydote.co.uk/2021/05/27/vault-observe/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Adding Observability to Vault","name":"Adding Observability to Vault","description":"One of the things I like to do when setting up a Vault cluster is to visualise all the operations Vault is performing, which helps see usage patterns changing, whether there are lots of failed requests coming in, and what endpoints are receiving the most traffic.\nWhile Vault has a lot of data available in Prometheus telemetry, the kind of information I am after is best taken from the Audit backend.","keywords":["observability","honeycomb","opentelemetry","infrastructure","vault"],"articleBody":"One of the things I like to do when setting up a Vault cluster is to visualise all the operations Vault is performing, which helps see usage patterns changing, whether there are lots of failed requests coming in, and what endpoints are receiving the most traffic.\nWhile Vault has a lot of data available in Prometheus telemetry, the kind of information I am after is best taken from the Audit backend. Setting up an audit backend for Vault is reasonably easy - it supports three methods of communication: file, socket and syslog. For this application, I use a Unix socket and a small daemon running on the same machine as the Vault instance to send the data to a tracing system.\nThe Goal Write a small application that receives audit events and writes traces (spans) to an observability tool. In this case, I am implementing both Honeycomb and Zipkin via OpenTelemetry.\nThe code is available on Github, and the most interesting parts are covered in the rest of this blog post.\nReceiving and Processing Messages ln, _ := net.Listen(\"unix\", \"/tmp/observe.sock\") conn, _ := ln.Accept() for { message, _ := bufio.NewReader(conn).ReadBytes('\\n') // do something with the message } We only need to do minimal processing of the data for this application before sending it on to Honeycomb or Zipkin. As the messages contain nested objects, we need to flatten the object hierarchy for easier viewing in spans. So instead of this:\n{ \"request\": { \"operation\": \"update\", \"namespace\": { \"id\": \"root\" }, \"path\": \"sys/audit/socket\", \"data\": { \"local\": false } } } We want to send this:\n{ \"request.operation\": \"update\", \"request.namespace.id\": \"root\", \"request.path\": \"sys/audit/socket\", \"request.data.local\": false } We also want to get a few strongly typed pieces of data out of the message, too, such as the type (request or response) and the request’s id, which is in both messages and can be used to group the spans.\nTo save us from deserialising the json twice, we can do the following:\ndeserialize into a map[string]interface{} create a flattened version of the event using the flatten library turn the map into a typed struct using the mapstructure library // 1 deserialize event := map[string]interface{}{} if err := json.Unmarshal(message, \u0026event); err != nil { return err } // 2 flatten flat, err := flatten.Flatten(event, \"\", flatten.DotStyle) if err != nil { return err } // 3 type typed := Event{} if err := mapstructure.Decode(event, \u0026typed); err != nil { return err } Now that we have our flattened version and our typed version of the message, we can forward it to our span processors. There are two implementations (3 if you count stdout), so let’s look at them one at a time.\nHoneycomb To send the spans to Honeycomb, I am using their lower-level library libhoney-go, rather than the more usual beeline as I don’t need all the context propagation or automatic ID generation.\nFor the first version of this application, just sending the two events to Honeycomb linked together is enough; however, both spans will show 0ms durations. We’ll fix this problem for both Honeycomb and OpenTelemetry later.\nTo link our spans together properly, I use the .Request.ID property from the event as the trace.trace_id; it’s already a guid and is the same for both the request and response events. Then, for a request event, I make it the parent span by using the .Request.ID again, but this time as the trace.span_id. Finally, for the response event, I set the trace.parent_id to the .Request.ID, and generate a random value for the trace.span_id field.\nLastly, I loop through the flattened version of the event, adding each key-value pair to the event’s attributes and finally send the event.\nev := libhoney.NewEvent() ev.AddField(\"trace.trace_id\", typed.Request.ID) if typed.Type == \"request\" { ev.AddField(\"trace.span_id\", typed.Request.ID) } else { ev.AddField(\"trace.parent_id\", typed.Request.ID) ev.AddField(\"trace.span_id\", generateSpanID()) } ev.AddField(\"service_name\", \"vault\") ev.AddField(\"name\", typed.Type) for key, val := range event { ev.AddField(key, val) } ev.Send() Zipkin / OpenTelemetry The process for sending via OpenTelemetry is reasonably similar; we start a new span, copy the flattened structure into the span’s attributed and call End(), making the TracerProvider send the span to our configured backends (Zipkin in this case.)\nid, _ := uuid.Parse(typed.Request.ID) ctx := context.WithValue(context.Background(), \"request_id\", id) tr := otel.GetTracerProvider().Tracer(\"main\") ctx, span := tr.Start(ctx, typed.Type, trace.WithSpanKind(trace.SpanKindServer)) for key, value := range event { span.SetAttributes(attribute.KeyValue{ Key: attribute.Key(key), Value: attribute.StringValue(fmt.Sprintf(\"%v\", value)), }) } if typed.Error != \"\" { span.SetStatus(codes.Error, typed.Error) } span.End() The hard part was figuring out how to feed the .Request.ID into the Tracer as the TraceID, which was achieved by configuring OpenTelemetry with a custom ID generator that would use the request_id property of the current context:\ntype Generator struct{} func (g *Generator) NewIDs(ctx context.Context) (trace.TraceID, trace.SpanID) { val := ctx.Value(\"request_id\").(uuid.UUID) tid := trace.TraceID{} req, _ := val.MarshalText() copy(tid[:], req) sid := trace.SpanID{} rand.Read(sid[:]) return tid, sid } I am sure more copying and allocation is happening in this method than necessary, but it is good enough for now. Configuring it for use by OpenTelemetry is straightforward; it just needs adding to the NewTracerProvider call by wrapping it with trace.WithIDGenerator():\nexporter, _ := zipkin.NewRawExporter( \"http://localhost:9411/api/v2/spans\", zipkin.WithSDKOptions(sdktrace.WithSampler(sdktrace.AlwaysSample())), ) processor := sdktrace.NewSimpleSpanProcessor(exporter) tp := sdktrace.NewTracerProvider( sdktrace.WithSpanProcessor(processor), sdktrace.WithResource(resource.NewWithAttributes( semconv.ServiceNameKey.String(\"vault-observe\"), )), sdktrace.WithIDGenerator(\u0026Generator{}), ) otel.SetTracerProvider(tp) Testing To verify that it works, I have a single docker-compose.yml file which sets up a Vault instance in dev mode, and a Zipkin instance. It mounts the current working directory into the Vault container as /sockets to share the socket file between the host and the container.\nversion: \"3.9\" services: vault: image: vault:latest cap_add: - IPC_LOCK volumes: - \"./:/sockets:rw\" ports: - \"8200:8200\" environment: VAULT_DEV_ROOT_TOKEN_ID: \"vault\" zipkin: image: openzipkin/zipkin-slim ports: - \"9411:9411\" Running the application along with the docker container is now as follows:\ngo build docker-compose up -d ./vault-observe --zipkin --socket-path observe.sock In another terminal, you can now enable the new audit backend and send some requests so we can look at them in Zipkin:\nexport VAULT_ADDR=\"http://localhost:8200\" export VAULT_TOKEN=\"vault\" vault audit enable socket address=/sockets/observe.sock socket_type=unix vault secrets enable -version=2 kv vault kv put /secrets/test name=andy vault kv get /secrets/test Running in Production There are a few things you should be aware of, running this in production:\nThis must not be your only audit backend: Vault will fail requests if they are not successfully written to at least one audit backend if any are enabled. There is the possibility of losing data if the vault-observe process stops Improvements As I am using this for keeping an eye on request durations and patterns in behaviour, capturing the actual time it takes for Vault to handle a request would be pretty valuable. So instead of processing both events, I will keep just the timestamp from the request, and then when the response event comes in, look up the timestamp and calculate the duration.\nAs I don’t want an ever-expanding list of timestamps in memory, I use an automatically expiring cache so keep them for around 10 seconds, as no request to Vault should be that slow!\nrequests := cache.New(10*time.Second, 1*time.Minute) for { err := processMessage(requests, conn, sender) if err != nil \u0026\u0026 err != io.EOF { fmt.Println(err) } } The processMessage function now handles the request and response messages separately. The request just inserts the event’s time property into the cache, and exists:\nif typed.Type == \"request\" { requests.Set(typed.Request.ID, typed.Time, cache.DefaultExpiration) return nil } The response version pulls the time back out of the cache and stores it into the event itself - it’s then up to the sender if it wants to use the value or not.\nif typed.Type == \"response\" { if x, found := requests.Get(typed.Request.ID); found { typed.StartTime = x.(time.Time) requests.Delete(typed.Request.ID) } else { return fmt.Errorf(\"No request found in the cache for %s\", typed.Request.ID) } } In the Honeycomb sender, we can remove all the parenting logic; we only need to set the Timestamp and duration_ms fields to get the duration showing correctly:\nduration := typed.Time.Sub(typed.StartTime).Milliseconds() ev := libhoney.NewEvent() ev.Timestamp = typed.StartTime ev.AddField(\"duration_ms\", duration) ev.AddField(\"trace.trace_id\", typed.Request.ID) ev.AddField(\"trace.span_id\", typed.Request.ID) For the OpenTelemetry sender, we can add a trace.WithTimestamp() call to both the Start() and End() calls so use our events’ timestamps:\nctx := context.WithValue(context.Background(), \"request_id\", id) tr := otel.GetTracerProvider().Tracer(\"main\") ctx, span := tr.Start(ctx, typed.Type, trace.WithSpanKind(trace.SpanKindServer), trace.WithTimestamp(typed.StartTime)) // ... span.End(trace.WithTimestamp(typed.Time)) ","wordCount":"1361","inLanguage":"en","datePublished":"2021-05-27T00:00:00Z","dateModified":"2021-05-27T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2021/05/27/vault-observe/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Adding Observability to Vault</h1><div class=post-meta>&lt;span title='2021-05-27 00:00:00 +0000 UTC'>May 27, 2021&lt;/span>&amp;nbsp;·&amp;nbsp;7 min</div></header><div class=post-content><p>One of the things I like to do when setting up a Vault cluster is to visualise all the operations Vault is performing, which helps see usage patterns changing, whether there are lots of failed requests coming in, and what endpoints are receiving the most traffic.</p><p>While Vault has a lot of data available in Prometheus telemetry, the kind of information I am after is best taken from the Audit backend. Setting up an audit backend for Vault is reasonably easy - it supports three methods of communication: file, socket and syslog. For this application, I use a Unix socket and a small daemon running on the same machine as the Vault instance to send the data to a tracing system.</p><h2 id=the-goal>The Goal<a hidden class=anchor aria-hidden=true href=#the-goal>#</a></h2><p>Write a small application that receives audit events and writes traces (spans) to an observability tool. In this case, I am implementing both Honeycomb and Zipkin via OpenTelemetry.</p><p>The <a href=https://github.com/Pondidum/vault-observe>code is available on Github</a>, and the most interesting parts are covered in the rest of this blog post.</p><h2 id=receiving-and-processing-messages>Receiving and Processing Messages<a hidden class=anchor aria-hidden=true href=#receiving-and-processing-messages>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ln</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;unix&#34;</span>, <span style=color:#e6db74>&#34;/tmp/observe.sock&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ln</span>.<span style=color:#a6e22e>Accept</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>message</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>conn</span>).<span style=color:#a6e22e>ReadBytes</span>(<span style=color:#e6db74>&#39;\n&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// do something with the message
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>We only need to do minimal processing of the data for this application before sending it on to Honeycomb or Zipkin. As the messages contain nested objects, we need to flatten the object hierarchy for easier viewing in spans. So instead of this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;operation&#34;</span>: <span style=color:#e6db74>&#34;update&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;namespace&#34;</span>: { <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#e6db74>&#34;root&#34;</span> },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;path&#34;</span>: <span style=color:#e6db74>&#34;sys/audit/socket&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;data&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;local&#34;</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We want to send this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request.operation&#34;</span>: <span style=color:#e6db74>&#34;update&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request.namespace.id&#34;</span>: <span style=color:#e6db74>&#34;root&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request.path&#34;</span>: <span style=color:#e6db74>&#34;sys/audit/socket&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request.data.local&#34;</span>: <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We also want to get a few strongly typed pieces of data out of the message, too, such as the <code>type</code> (<code>request</code> or <code>response</code>) and the request&rsquo;s <code>id</code>, which is in both messages and can be used to group the spans.</p><p>To save us from deserialising the json twice, we can do the following:</p><ol><li>deserialize into a <code>map[string]interface{}</code></li><li>create a flattened version of the event using the <a href=https://pkg.go.dev/github.com/jeremywohl/flatten>flatten</a> library</li><li>turn the map into a typed struct using the <a href=https://pkg.go.dev/github.com/mitchellh/mapstructure>mapstructure</a> library</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 1 deserialize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>event</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>message</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>event</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2 flatten
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>flat</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>flatten</span>.<span style=color:#a6e22e>Flatten</span>(<span style=color:#a6e22e>event</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>flatten</span>.<span style=color:#a6e22e>DotStyle</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 3 type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>typed</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Event</span>{}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mapstructure</span>.<span style=color:#a6e22e>Decode</span>(<span style=color:#a6e22e>event</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>typed</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now that we have our flattened version and our typed version of the message, we can forward it to our span processors. There are two implementations (3 if you count <code>stdout</code>), so let&rsquo;s look at them one at a time.</p><h2 id=honeycomb>Honeycomb<a hidden class=anchor aria-hidden=true href=#honeycomb>#</a></h2><p>To send the spans to Honeycomb, I am using their lower-level library <a href=https://pkg.go.dev/github.com/honeycombio/libhoney-go>libhoney-go</a>, rather than the more usual <a href=https://pkg.go.dev/github.com/honeycombio/beeline-go>beeline</a> as I don&rsquo;t need all the <code>context</code> propagation or automatic ID generation.</p><p>For the first version of this application, just sending the two events to Honeycomb linked together is enough; however, both spans will show 0ms durations. We&rsquo;ll fix this problem for both Honeycomb and OpenTelemetry later.</p><p>To link our spans together properly, I use the <code>.Request.ID</code> property from the event as the <code>trace.trace_id</code>; it&rsquo;s already a guid and is the same for both the request and response events. Then, for a <code>request</code> event, I make it the parent span by using the <code>.Request.ID</code> again, but this time as the <code>trace.span_id</code>. Finally, for the <code>response</code> event, I set the <code>trace.parent_id</code> to the <code>.Request.ID</code>, and generate a random value for the <code>trace.span_id</code> field.</p><p>Lastly, I loop through the flattened version of the event, adding each key-value pair to the event&rsquo;s attributes and finally send the event.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ev</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>libhoney</span>.<span style=color:#a6e22e>NewEvent</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;trace.trace_id&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;request&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;trace.span_id&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;trace.parent_id&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;trace.span_id&#34;</span>, <span style=color:#a6e22e>generateSpanID</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;service_name&#34;</span>, <span style=color:#e6db74>&#34;vault&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Type</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>event</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Send</span>()
</span></span></code></pre></div><h2 id=zipkin--opentelemetry>Zipkin / OpenTelemetry<a hidden class=anchor aria-hidden=true href=#zipkin--opentelemetry>#</a></h2><p>The process for sending via OpenTelemetry is reasonably similar; we start a new span, copy the flattened structure into the span&rsquo;s attributed and call <code>End()</code>, making the TracerProvider send the span to our configured backends (Zipkin in this case.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>Parse</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#e6db74>&#34;request_id&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>tr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>otel</span>.<span style=color:#a6e22e>GetTracerProvider</span>().<span style=color:#a6e22e>Tracer</span>(<span style=color:#e6db74>&#34;main&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>WithSpanKind</span>(<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>SpanKindServer</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>event</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>SetAttributes</span>(<span style=color:#a6e22e>attribute</span>.<span style=color:#a6e22e>KeyValue</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Key</span>:   <span style=color:#a6e22e>attribute</span>.<span style=color:#a6e22e>Key</span>(<span style=color:#a6e22e>key</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Value</span>: <span style=color:#a6e22e>attribute</span>.<span style=color:#a6e22e>StringValue</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%v&#34;</span>, <span style=color:#a6e22e>value</span>)),
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Error</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>SetStatus</span>(<span style=color:#a6e22e>codes</span>.<span style=color:#a6e22e>Error</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Error</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>()
</span></span></code></pre></div><p>The hard part was figuring out how to feed the <code>.Request.ID</code> into the Tracer as the TraceID, which was achieved by configuring OpenTelemetry with a custom ID generator that would use the <code>request_id</code> property of the current <code>context</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Generator</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Generator</span>) <span style=color:#a6e22e>NewIDs</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>) (<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>TraceID</span>, <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>SpanID</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>val</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ctx</span>.<span style=color:#a6e22e>Value</span>(<span style=color:#e6db74>&#34;request_id&#34;</span>).(<span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>UUID</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>TraceID</span>{}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>req</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>val</span>.<span style=color:#a6e22e>MarshalText</span>()
</span></span><span style=display:flex><span>  copy(<span style=color:#a6e22e>tid</span>[:], <span style=color:#a6e22e>req</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>SpanID</span>{}
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>rand</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>sid</span>[:])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tid</span>, <span style=color:#a6e22e>sid</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I am sure more copying and allocation is happening in this method than necessary, but it is good enough for now. Configuring it for use by OpenTelemetry is straightforward; it just needs adding to the <code>NewTracerProvider</code> call by wrapping it with <code>trace.WithIDGenerator()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>exporter</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>zipkin</span>.<span style=color:#a6e22e>NewRawExporter</span>(
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;http://localhost:9411/api/v2/spans&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>zipkin</span>.<span style=color:#a6e22e>WithSDKOptions</span>(<span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>WithSampler</span>(<span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>AlwaysSample</span>())),
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>processor</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>NewSimpleSpanProcessor</span>(<span style=color:#a6e22e>exporter</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>tp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>NewTracerProvider</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>WithSpanProcessor</span>(<span style=color:#a6e22e>processor</span>),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>WithResource</span>(<span style=color:#a6e22e>resource</span>.<span style=color:#a6e22e>NewWithAttributes</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>semconv</span>.<span style=color:#a6e22e>ServiceNameKey</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;vault-observe&#34;</span>),
</span></span><span style=display:flex><span>  )),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sdktrace</span>.<span style=color:#a6e22e>WithIDGenerator</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Generator</span>{}),
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>otel</span>.<span style=color:#a6e22e>SetTracerProvider</span>(<span style=color:#a6e22e>tp</span>)
</span></span></code></pre></div><h2 id=testing>Testing<a hidden class=anchor aria-hidden=true href=#testing>#</a></h2><p>To verify that it works, I have a single <code>docker-compose.yml</code> file which sets up a Vault instance in dev mode, and a Zipkin instance. It mounts the current working directory into the Vault container as <code>/sockets</code> to share the socket file between the host and the container.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>version</span>: <span style=color:#e6db74>&#34;3.9&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>services</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>vault</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>vault:latest</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>cap_add</span>:
</span></span><span style=display:flex><span>      - <span style=color:#ae81ff>IPC_LOCK</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumes</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;./:/sockets:rw&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;8200:8200&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>environment</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>VAULT_DEV_ROOT_TOKEN_ID</span>: <span style=color:#e6db74>&#34;vault&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>zipkin</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>openzipkin/zipkin-slim</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>      - <span style=color:#e6db74>&#34;9411:9411&#34;</span>
</span></span></code></pre></div><p>Running the application along with the docker container is now as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go build
</span></span><span style=display:flex><span>docker-compose up -d
</span></span><span style=display:flex><span>./vault-observe --zipkin --socket-path observe.sock
</span></span></code></pre></div><p>In another terminal, you can now enable the new audit backend and send some requests so we can look at them in Zipkin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_ADDR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>
</span></span><span style=display:flex><span>export VAULT_TOKEN<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vault&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault audit enable socket address<span style=color:#f92672>=</span>/sockets/observe.sock socket_type<span style=color:#f92672>=</span>unix
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault secrets enable -version<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span> kv
</span></span><span style=display:flex><span>vault kv put /secrets/test name<span style=color:#f92672>=</span>andy
</span></span><span style=display:flex><span>vault kv get /secrets/test
</span></span></code></pre></div><h2 id=running-in-production>Running in Production<a hidden class=anchor aria-hidden=true href=#running-in-production>#</a></h2><p>There are a few things you should be aware of, running this in production:</p><ul><li>This <em>must not</em> be your only audit backend: Vault will fail requests if they are not successfully written to at least one audit backend if any are enabled.</li><li>There is the possibility of losing data if the <code>vault-observe</code> process stops</li></ul><h2 id=improvements>Improvements<a hidden class=anchor aria-hidden=true href=#improvements>#</a></h2><p>As I am using this for keeping an eye on request durations and patterns in behaviour, capturing the actual time it takes for Vault to handle a request would be pretty valuable. So instead of processing both events, I will keep just the timestamp from the <code>request</code>, and then when the <code>response</code> event comes in, look up the timestamp and calculate the duration.</p><p>As I don&rsquo;t want an ever-expanding list of timestamps in memory, I use an <a href=https://pkg.go.dev/github.com/patrickmn/go-cache>automatically expiring cache</a> so keep them for around 10 seconds, as no request to Vault should be that slow!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>requests</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cache</span>.<span style=color:#a6e22e>New</span>(<span style=color:#ae81ff>10</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>, <span style=color:#ae81ff>1</span><span style=color:#f92672>*</span><span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Minute</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>processMessage</span>(<span style=color:#a6e22e>requests</span>, <span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>sender</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>EOF</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>processMessage</code> function now handles the <code>request</code> and <code>response</code> messages separately. The <code>request</code> just inserts the event&rsquo;s <code>time</code> property into the cache, and exists:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;request&#34;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>requests</span>.<span style=color:#a6e22e>Set</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Time</span>, <span style=color:#a6e22e>cache</span>.<span style=color:#a6e22e>DefaultExpiration</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>response</code> version pulls the time back out of the cache and stores it into the event itself - it&rsquo;s then up to the sender if it wants to use the value or not.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;response&#34;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>found</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>requests</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>); <span style=color:#a6e22e>found</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>StartTime</span> = <span style=color:#a6e22e>x</span>.(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>requests</span>.<span style=color:#a6e22e>Delete</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;No request found in the cache for %s&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the Honeycomb sender, we can remove all the parenting logic; we only need to set the <code>Timestamp</code> and <code>duration_ms</code> fields to get the duration showing correctly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>duration</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Time</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>StartTime</span>).<span style=color:#a6e22e>Milliseconds</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>libhoney</span>.<span style=color:#a6e22e>NewEvent</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>Timestamp</span> = <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>StartTime</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;duration_ms&#34;</span>, <span style=color:#a6e22e>duration</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;trace.trace_id&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ev</span>.<span style=color:#a6e22e>AddField</span>(<span style=color:#e6db74>&#34;trace.span_id&#34;</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Request</span>.<span style=color:#a6e22e>ID</span>)
</span></span></code></pre></div><p>For the OpenTelemetry sender, we can add a <code>trace.WithTimestamp()</code> call to both the <code>Start()</code> and <code>End()</code> calls so use our events&rsquo; timestamps:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>WithValue</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#e6db74>&#34;request_id&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>tr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>otel</span>.<span style=color:#a6e22e>GetTracerProvider</span>().<span style=color:#a6e22e>Tracer</span>(<span style=color:#e6db74>&#34;main&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Type</span>, <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>WithSpanKind</span>(<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>SpanKindServer</span>), <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>WithTimestamp</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>StartTime</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>(<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>WithTimestamp</span>(<span style=color:#a6e22e>typed</span>.<span style=color:#a6e22e>Time</span>))
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/observability/>observability</a></li><li><a href=https://andydote.co.uk/tags/honeycomb/>honeycomb</a></li><li><a href=https://andydote.co.uk/tags/opentelemetry/>opentelemetry</a></li><li><a href=https://andydote.co.uk/tags/infrastructure/>infrastructure</a></li><li><a href=https://andydote.co.uk/tags/vault/>vault</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2021/06/02/os-cpus-and-kubernetes/><span class=title>« Prev Page</span><br><span>The Problem with CPUs and Kubernetes</span>
</a><a class=next href=https://andydote.co.uk/2021/03/12/nodejs-opentelemetry-newrelic/><span class=title>Next Page »</span><br><span>Getting NodeJS OpenTelemetry data into NewRelic</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>