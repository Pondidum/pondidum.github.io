<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Task Chaining and the Pipeline Operator | Andy Dote</title><meta name=keywords content="c#"><meta name=description content="Since I have been trying to learn a functional language (Elixir), I have noticed how grating it is when in C# I need to call a few methods in a row, passing the results of one to the next.
The bit that really grates is that it reads backwards, i.e. the rightmost function call is invoked first, and the left hand one last, like so:
await WriteJsonFile(await QueueParts(await ConvertToModel(await ReadBsxFile(record)))); In Elixir (or F# etc."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/02/20/task-chainging-pipeline-operator/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Task Chaining and the Pipeline Operator"><meta property="og:description" content="Since I have been trying to learn a functional language (Elixir), I have noticed how grating it is when in C# I need to call a few methods in a row, passing the results of one to the next.
The bit that really grates is that it reads backwards, i.e. the rightmost function call is invoked first, and the left hand one last, like so:
await WriteJsonFile(await QueueParts(await ConvertToModel(await ReadBsxFile(record)))); In Elixir (or F# etc."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/02/20/task-chainging-pipeline-operator/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-02-20T00:00:00+00:00"><meta property="article:modified_time" content="2018-02-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Task Chaining and the Pipeline Operator"><meta name=twitter:description content="Since I have been trying to learn a functional language (Elixir), I have noticed how grating it is when in C# I need to call a few methods in a row, passing the results of one to the next.
The bit that really grates is that it reads backwards, i.e. the rightmost function call is invoked first, and the left hand one last, like so:
await WriteJsonFile(await QueueParts(await ConvertToModel(await ReadBsxFile(record)))); In Elixir (or F# etc."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Task Chaining and the Pipeline Operator","item":"https://andydote.co.uk/2018/02/20/task-chainging-pipeline-operator/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Task Chaining and the Pipeline Operator","name":"Task Chaining and the Pipeline Operator","description":"Since I have been trying to learn a functional language (Elixir), I have noticed how grating it is when in C# I need to call a few methods in a row, passing the results of one to the next.\nThe bit that really grates is that it reads backwards, i.e. the rightmost function call is invoked first, and the left hand one last, like so:\nawait WriteJsonFile(await QueueParts(await ConvertToModel(await ReadBsxFile(record)))); In Elixir (or F# etc.","keywords":["c#"],"articleBody":"Since I have been trying to learn a functional language (Elixir), I have noticed how grating it is when in C# I need to call a few methods in a row, passing the results of one to the next.\nThe bit that really grates is that it reads backwards, i.e. the rightmost function call is invoked first, and the left hand one last, like so:\nawait WriteJsonFile(await QueueParts(await ConvertToModel(await ReadBsxFile(record)))); In Elixir (or F# etc.) you can write this in the following way:\nvar task = record  | await ReadBsxFile  | await ConvertToModel  | await QueueParts  | await WriteJsonFile While there are proposals for the forward pipe operator to be added to C# being discussed, it doesn’t look like it will happen in the near future.\nSomething close to this is Linq, and at first, I tried to work out a way to write the pipeline for a single object using the Select statement, something like this:\nawait record  .Select(ReadBsxFile)  .Select(ConvertToModel)  .Select(QueueParts)  .Select(WriteJsonFile); The problem with this is that Linq doesn’t play well with async code - you end up needing to call .Result on each task selected…which is a Bad Thing to do.\nI realised that as it’s just Tasks I really care about, I might be able to write some extension methods to accomplish something similar. I ended up with 3 extensions: one to start a chain from a value, and two to allow either Task to be chained, or a Task:\npublic static class TaskExtensions {  public static async Task Start(this TIn value, Func next)  {  return await next(value);  }   public static async Task Then(this Task current, Func next)  {  return await next(await current);  }   public static async Task Then(this Task current, Funcnext)  {  await next(await current);  } } This can be used to take a single value, and “pipeline” it through a bunch of async methods:\nvar task = record  .Start(ReadBsxFile)  .Then(ConvertToModel)  .Then(QueueParts)  .Then(WriteJsonFile); One of the nice things about this is that if I want to add another method in the middle of my chain, as long as it’s input and output types fit, it can just be inserted or added to the chain:\nvar task = record  .Start(ReadBsxFile)  .Then(ConvertToModel)  .Then(InspectModelForRedundancies)  .Then(QueueParts)  .Then(WriteJsonFile)  .Then(DeleteBsxFile); You can see a real use of this in my BsxProcessor Lambda.\nThis is one of the great things about learning other programming languages: even if you don’t use them on a daily basis, they can really give you insight into different ways of doing things, doubly so if they are a different style of language.\n","wordCount":"431","inLanguage":"en","datePublished":"2018-02-20T00:00:00Z","dateModified":"2018-02-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/02/20/task-chainging-pipeline-operator/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Task Chaining and the Pipeline Operator</h1><div class=post-meta><span title="2018-02-20 00:00:00 +0000 UTC">February 20, 2018</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>Since I have been trying to learn a functional language (Elixir), I have noticed how grating it is when in C# I need to call a few methods in a row, passing the results of one to the next.</p><p>The bit that really grates is that it reads backwards, i.e. the rightmost function call is invoked first, and the left hand one last, like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>await</span> WriteJsonFile(<span style=color:#66d9ef>await</span> QueueParts(<span style=color:#66d9ef>await</span> ConvertToModel(<span style=color:#66d9ef>await</span> ReadBsxFile(record))));
</span></span></code></pre></div><p>In Elixir (or F# etc.) you can write this in the following way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> task = <span style=color:#66d9ef>record</span>
</span></span><span style=display:flex><span>    |&gt; <span style=color:#66d9ef>await</span> ReadBsxFile
</span></span><span style=display:flex><span>    |&gt; <span style=color:#66d9ef>await</span> ConvertToModel
</span></span><span style=display:flex><span>    |&gt; <span style=color:#66d9ef>await</span> QueueParts
</span></span><span style=display:flex><span>    |&gt; <span style=color:#66d9ef>await</span> WriteJsonFile
</span></span></code></pre></div><p>While there are proposals for the <a href=https://github.com/dotnet/csharplang/issues/74>forward pipe operator</a> to be added to C# being discussed, it doesn&rsquo;t look like it will happen in the near future.</p><p>Something close to this is Linq, and at first, I tried to work out a way to write the pipeline for a single object using the <code>Select</code> statement, something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#66d9ef>record</span>
</span></span><span style=display:flex><span>    .Select(ReadBsxFile)
</span></span><span style=display:flex><span>    .Select(ConvertToModel)
</span></span><span style=display:flex><span>    .Select(QueueParts)
</span></span><span style=display:flex><span>    .Select(WriteJsonFile);
</span></span></code></pre></div><p>The problem with this is that Linq doesn&rsquo;t play well with async code - you end up needing to call <code>.Result</code> on each task selected&mldr;which is a <a href=http://blog.stephencleary.com/2012/07/dont-block-on-async-code.html>Bad</a> <a href=https://msdn.microsoft.com/en-us/magazine/jj991977.aspx>Thing</a> to do.</p><p>I realised that as it&rsquo;s just <code>Task</code>s I really care about, I might be able to write some extension methods to accomplish something similar. I ended up with 3 extensions: one to start a chain from a value, and two to allow either <code>Task&lt;T></code> to be chained, or a <code>Task</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskExtensions</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> Task&lt;TOut&gt; Start&lt;TIn, TOut&gt;(<span style=color:#66d9ef>this</span> TIn <span style=color:#66d9ef>value</span>, Func&lt;TIn, Task&lt;TOut&gt;&gt; next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> next(<span style=color:#66d9ef>value</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> Task&lt;TOut&gt; Then&lt;TIn, TOut&gt;(<span style=color:#66d9ef>this</span> Task&lt;TIn&gt; current, Func&lt;TIn, Task&lt;TOut&gt;&gt; next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> next(<span style=color:#66d9ef>await</span> current);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> Task Then&lt;TIn&gt;(<span style=color:#66d9ef>this</span> Task&lt;TIn&gt; current, Func&lt;TIn, Task&gt; next)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> next(<span style=color:#66d9ef>await</span> current);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This can be used to take a single value, and &ldquo;pipeline&rdquo; it through a bunch of async methods:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> task = <span style=color:#66d9ef>record</span>
</span></span><span style=display:flex><span>    .Start(ReadBsxFile)
</span></span><span style=display:flex><span>    .Then(ConvertToModel)
</span></span><span style=display:flex><span>    .Then(QueueParts)
</span></span><span style=display:flex><span>    .Then(WriteJsonFile);
</span></span></code></pre></div><p>One of the nice things about this is that if I want to add another method in the middle of my chain, as long as it&rsquo;s input and output types fit, it can just be inserted or added to the chain:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> task = <span style=color:#66d9ef>record</span>
</span></span><span style=display:flex><span>    .Start(ReadBsxFile)
</span></span><span style=display:flex><span>    .Then(ConvertToModel)
</span></span><span style=display:flex><span>    .Then(InspectModelForRedundancies)
</span></span><span style=display:flex><span>    .Then(QueueParts)
</span></span><span style=display:flex><span>    .Then(WriteJsonFile)
</span></span><span style=display:flex><span>    .Then(DeleteBsxFile);
</span></span></code></pre></div><p>You can see a real use of this in my <a href=https://github.com/Pondidum/BrickRecon/blob/master/projects/BsxProcessor/src/BsxProcessor/RecordHandler.cs#L24>BsxProcessor Lambda</a>.</p><p>This is one of the great things about learning other programming languages: even if you don&rsquo;t use them on a daily basis, they can really give you insight into different ways of doing things, doubly so if they are a different style of language.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/02/26/test-expressiveness/><span class=title>« Prev Page</span><br><span>Test Expressiveness</span></a>
<a class=next href=https://andydote.co.uk/2017/12/09/tweaking-process-remove-errors/><span class=title>Next Page »</span><br><span>Tweaking Processes to Remove Errors</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>