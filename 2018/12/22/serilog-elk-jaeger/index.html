<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Code-free tracing with LogStash and Jaeger | Andy Dote</title><meta name=keywords content="jaeger,logstash,microservices,infrastructure"><meta name=description content="I wanted to show request charts (similar to the network tab in firefox) for requests across our microservices but wanted to do so in the least invasive way possible.
We already use LogStash to collect logs from multiple hosts (via FileBeat) and forward them on to ElasticSearch, so perhaps I can do something to also output from LogStash to a tracing service.
There are a number of tracing services available (AppDash, Jaeger, Zipkin), but unfortunately LogStash doesn&rsquo;t have plugins for any of them or for OpenTracing."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/12/22/serilog-elk-jaeger/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4ac25d88867f6882d86478d9b478a3d3efa1ed9e18f0bc5e432812301516cb28.css integrity="sha256-SsJdiIZ/aILYZHjZtHij0++h7Z4Y8LxeQygSMBUWyyg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Code-free tracing with LogStash and Jaeger"><meta property="og:description" content="I wanted to show request charts (similar to the network tab in firefox) for requests across our microservices but wanted to do so in the least invasive way possible.
We already use LogStash to collect logs from multiple hosts (via FileBeat) and forward them on to ElasticSearch, so perhaps I can do something to also output from LogStash to a tracing service.
There are a number of tracing services available (AppDash, Jaeger, Zipkin), but unfortunately LogStash doesn&rsquo;t have plugins for any of them or for OpenTracing."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/12/22/serilog-elk-jaeger/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-12-22T00:00:00+00:00"><meta property="article:modified_time" content="2018-12-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Code-free tracing with LogStash and Jaeger"><meta name=twitter:description content="I wanted to show request charts (similar to the network tab in firefox) for requests across our microservices but wanted to do so in the least invasive way possible.
We already use LogStash to collect logs from multiple hosts (via FileBeat) and forward them on to ElasticSearch, so perhaps I can do something to also output from LogStash to a tracing service.
There are a number of tracing services available (AppDash, Jaeger, Zipkin), but unfortunately LogStash doesn&rsquo;t have plugins for any of them or for OpenTracing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Code-free tracing with LogStash and Jaeger","item":"https://andydote.co.uk/2018/12/22/serilog-elk-jaeger/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Code-free tracing with LogStash and Jaeger","name":"Code-free tracing with LogStash and Jaeger","description":"I wanted to show request charts (similar to the network tab in firefox) for requests across our microservices but wanted to do so in the least invasive way possible.\nWe already use LogStash to collect logs from multiple hosts (via FileBeat) and forward them on to ElasticSearch, so perhaps I can do something to also output from LogStash to a tracing service.\nThere are a number of tracing services available (AppDash, Jaeger, Zipkin), but unfortunately LogStash doesn\u0026rsquo;t have plugins for any of them or for OpenTracing.","keywords":["jaeger","logstash","microservices","infrastructure"],"articleBody":"I wanted to show request charts (similar to the network tab in firefox) for requests across our microservices but wanted to do so in the least invasive way possible.\nWe already use LogStash to collect logs from multiple hosts (via FileBeat) and forward them on to ElasticSearch, so perhaps I can do something to also output from LogStash to a tracing service.\nThere are a number of tracing services available (AppDash, Jaeger, Zipkin), but unfortunately LogStash doesn’t have plugins for any of them or for OpenTracing. I picked Jaeger, as it seemed to be the easiest to get up and running, and also had a “Zipkin compatible” API too if you didn’t want to use the Jaeger one.\nSetting up and running Jaeger in a production environment is way out of scope for this post, but for testing, I am just using the all-in-one Docker container:\ndocker run -d --nameron jaeger \\ -e COLLECTOR_ZIPKIN_HTTP_PORT=9411 \\ -p 5775:5775/udp \\ -p 6831:6831/udp \\ -p 6832:6832/udp \\ -p 5778:5778 \\ -p 16686:16686 \\ -p 14268:14268 \\ -p 9411:9411 \\ jaegertracing/all-in-one The tracing APIs work in roughly the same way: all traces have the same traceid, and are sub-divided into spans. Spans have a unique id and can have a parent (span) id set. The trouble with sending data from LogStash is that I don’t have any parent IDs available. Well, at least without going and adding it to all our applications, and I’m not sure how I would want to propagate it correctly either.\nSo the first question is: can I push multiple spans without any parent IDs, and have it plot them as I would expect.\nIs span.parentid required? As the HTTP API documentation seems to be non-existent (other than “there is one!”), and most of the other docs mention the Thrift API, I decided to use that to test the theory. The Jaeger C# client library has a nice API to use, but I wanted to manually specify things (e.g. traceid, spanid, etc.) and the API has no way to do that, as pretty much everything is marked as internal.\nInstead, I cloned the client repository, and added a test (which had access to all the internals I wanted):\npublic class Scratch { private readonly HttpSender _sender; private readonly Tracer _tracer; private readonly TraceId _id; public Scratch(ITestOutputHelper output) { _sender = new HttpSender(\"http://localhost:14268/api/traces\"); _tracer = new Tracer.Builder(\"FirstService\").Build(); _id = TraceId.NewUniqueId(false); output.WriteLine(_id.ToString()); } [Fact] public async Task Send() { var start = DateTime.UtcNow; await Create(start, start.AddSeconds(5)); await Create(start, start.AddSeconds(3)); await Create(start.AddSeconds(5), start.AddSeconds(10)); await Create(start.AddSeconds(10), start.AddSeconds(20)); await Create(start, start.AddSeconds(20)); await _sender.FlushAsync(CancellationToken.None); } private async Task Create(DateTime start, DateTimeOffset finish) { var context = new SpanContext(_id, SpanId.NewUniqueId(), new SpanId(0), SpanContextFlags.None); var span = new Span(_tracer, \"test\", context, start, new Dictionary\u003cstring, object\u003e(), null); span.Finish(finish); await _sender.AppendAsync(span, CancellationToken.None); } } The graph rendered how I hoped, proving that I don’t need to set the span’s parentid for everything with the same traceid to work correctly!\nHow to generate a consistent TraceID? All our services pass along or generate a correlationID for each request, so my idea here was to do some conversion to put it in the traceid, which is an int64. Our correlationIDs are guids, which internally is an int128, so I figured I would take the least significant 8 bytes and use that. This can be done in C# like so:\nvar correlationID = Guid.NewGuid(); var traceID = new TraceId(BitConverter.ToInt64(correlationID.ToByteArray(), 8)); I noticed, however, that the TraceID structure in the Jaeger client can take two values: int64 low and int64 high, so I can use the entire correlationid.\nHow to ship from LogStash? After reading through the LogStash Output Plugins docs it looked like there were three possible ways to ship the events to Jaeger: writing a command line app; invoked through either exec or pipe, writing a LogStash plugin, or doing something with the http output.\nCLI adaptor The idea of this method would be to write a CLI app which takes an event from LogStash and then sends it to Jaeger using the Thrift API. The app itself could be invoked using the exec or pipe outputs. I didn’t want to use this method for a few reasons:\nDevelopment: The Jaeger client has things I need hidden from the public surface, such as being able to specify the traceid, rather than generating a new one each time, so I would either have to reimplement the classes I need, use reflection to instantiate things, or try opening Pull Requests to expose more internals of the library.\nMaintenance: I’d rather not have yet another thing to maintain if I can avoid it, not to mention all the additional things like repository location, build agents, etc.\nDeployment: Our LogStash box is a plain Ubuntu box with nothing other than Java and LogStash installed on it. As I would probably end up using C# to write the app, I’d need to add even more dependencies.\nThroughput: Jaeger (and the others) support sending traces in batches for better efficiency. Writing an app which supported that would involve writing the batching and caching, and the likelihood is I would mess it up, and increase the chances of lost messages.\nLogStash plugin Basically has the same problems as above, with the addition of me needing to learn enough about Java to build something reliable, and as this is a test and no one else in my team really knows Java either, so I ruled this out.\nHttp? The Jaeger collector process can also expose a Zipkin compatible API, and while the documentation for that API is also terrible, I was able to find a Pull Request on Github with some structure defined. I figured I could do most of this directly with LogStash’s configuration DSL, assuming I can: generate a uuid (logstash-filter-uuid plugin), and remove all extra stuff from the post body (logstash-filter-prune).\nBuilding the LogStash message The first step of my configuration is based on what we need to do to Serilog messages to make them a bit nicer in Kibana:\nPre-processing json { source =\u003e \"message\" } date { match =\u003e [ \"Timestamp\", \"ISO8601\", \"yyyy-MM-dd'T'HH:mm:ss.SSSSSSSZZ\"] target =\u003e \"@timestamp\" } mutate { rename =\u003e { \"[Properties][ApplicationName]\" =\u003e \"ApplicationName\" \"[Properties][CorrelationId]\" =\u003e \"CorrelationId\" \"[Properties][SourceContext]\" =\u003e \"Context\" \"[Properties][TimedOperationElapsedInMs]\" =\u003e \"TimeElapsed\" } } The json block tells LogStash that everything in the message property is a json object, rather than a string.\nThe date block extracts the time the message was recorded by the application and writes it to the special @timestamp field. This is a good idea as due to queuing, and processing times, the time the message was written and the time it was processed by LogStash will be different.\nLastly, the mutate block is moving a bunch of fields out of the message properties, and up to the top level of the object. We query by things like ApplicationName a lot, and it’s nice not to have to write Properties.ApplicationName:blahblah all the time.\nSplitting Our messages contain a lot of data which for the purposes of tracing, we just don’t care about. Not only is it a waste of bandwidth to send all the data to Jaeger, but also there could be clashing fields, and if we ever decide to use a hosted version of Jaeger, I don’t want to be sending them all the data either.\nSo how do we remove everything from the message, but still keep it in the message for the other outputs?\nLogStash has an interesting filter called clone. What it does is copy the message as many times as you specify, and then runs the remaining part of the pipeline once per message, including the original message. In code, this just looks like this:\nclone { clones =\u003e [ \"jaeger\" ] } If we wanted to split the message more times, we can just add more types to the clones array; there will be one extra message produced for each entry in the array, which will also be added to the message as the type property so we can filter on it later.\nWe don’t want to send the type field itself to Jaeger (or ElasticSeach), so we move it from the message to the @metadata object, which doesn’t get passed to outputs.\nmutate { rename =\u003e { \"type\" =\u003e \"[@metadata][type]\" } } To handle the messages differently, we can just use an if statement on the @metadata.type property:\nif [@metadata][type] == \"jaeger\" { # do stuff to the jaeger message } else { # process the original message } Building the Http Payload The hardest part of getting this to work was handling the dates. Jaeger specifies that timestamps should come in microseconds since epoch, and duration should be in microseconds also. We need to use the ruby filter so we can run some code to do this, rather than using an inbuilt filter primitive.\nThe duration is easy enough, as we report TimeElapsed in milliseconds:\nruby { code =\u003e \"event.set('duration', (event.get('TimeElapsed') * 1000).floor)\" } To handle the timestamp we need to convert it to epoch milliseconds. We can get the fractional seconds since the epoch by calling to_f on the @timestamp field, and then multiply by 1000 a couple of times to express it as microseconds. We also floor it to remove the leftover fraction:\nruby { code =\u003e \"event.set('timestamp', (event.get('@timestamp').to_f * 1000 * 1000).floor)\" } This on its own will work, but it won’t be right. We report log entries when an operation completes, which means our timestamp is the finish of the event, not the start. To solve this, we subtract the duration off the timestamp:\nruby { code =\u003e \"event.set('timestamp', (event.get('@timestamp').to_f * 1000 * 1000).floor - event.get('duration'))\" } Next, we need to create our span id. We need to generate a random id, consisting of letters and numbers, so the easiest way is to generate a uuid, and then tweak it to fit the Jaeger/Zipkin format. To do that we need to install the logstash-filter-uuid plugin:\n/usr/share/logstash/bin/logstash-plugin install logstash-filter-uuid There are a few things we need to do to generate a valid span id (for Jaeger):\ngenerate a uuid remove the dashes make it lowercase trim it to 16 chars We use four filters to achieve this:\nuuid { target =\u003e \"id\" } mutate { gsub =\u003e [ \"id\", \"-\", \"\" ] lowercase =\u003e [ \"id\" ] } mutate { gsub =\u003e [ \"id\", \"(^.{1,16}).*$\", \"\\1\"] } The reason we specify the mutate twice is that order of the same operation (gsub in this case) is not guaranteed within a mutate block.\nNext up we need to tweak the traceid from a guid to a uuid:\nmutate { gsub =\u003e [ \"traceid\", \"-\", \"\" ] lowercase =\u003e [ \"traceid\" ] } Next, we can populate some other context into the message, by renaming the other fields we want. I discovered most of the fields and their formats from a combination of the thrift dtos and the this pull request.\nmutate { rename =\u003e { \"CorrelationId\" =\u003e \"traceid\" \"Context\" =\u003e \"name\" \"ApplicationName\" =\u003e \"[localEndpoint][serviceName]\" } } Finally, we want to trim all the other properties from our message, which we can do by using the logstash-filter-prune plugin:\nprune { whitelist_names =\u003e [ \"id\", \"traceid\", \"name\", \"timestamp\", \"duration\", \"localEndpoint\" ] } mutate { remove_field =\u003e [ \"@timestamp\" ] } We have to explicitly remove the @timestamp property as the prune plugin seems to ignore it (it also ignores the @metadata property).\nThe complete filter code can be made a little more efficient by combining several of the mutate blocks, provided we keep things in the right order, as follows:\nruby { code =\u003e \"event.set('duration', (event.get('TimeElapsed') * 1000).floor)\" } ruby { code =\u003e \"event.set('timestamp', (event.get('@timestamp').to_f * 1000 * 1000).floor - event.get('duration'))\" } uuid { target =\u003e \"id\" } mutate { rename =\u003e { \"CorrelationId\" =\u003e \"traceid\" \"Context\" =\u003e \"name\" \"ApplicationName\" =\u003e \"[localEndpoint][serviceName]\" } remove_field =\u003e [ \"@timestamp\" ] } mutate { gsub =\u003e [ \"id\", \"-\", \"\" ] gsub =\u003e [ \"traceid\", \"-\", \"\" ] lowercase =\u003e [ \"traceid\", \"id\" ] } mutate { gsub =\u003e [ \"id\", \"(^.{1,16}).*$\", \"\\1\"] } prune { whitelist_names =\u003e [ \"id\", \"traceid\", \"name\", \"timestamp\", \"duration\", \"localEndpoint\" ] } Publishing to Jaeger When publishing to the Jaeger API, you have to send it an array of json objects. To achieve this in the http output plugin, we can enable the format =\u003e json_batch, which will cause the HTTP client to buffer some events and then send them all at once. So more efficiency, and no extra code on our part.\nTo help make testing easier, I publish to two different HTTP endpoints: the Jaeger docker container running on my host machine, and to a Request Logger Bin; where I can inspect the response if something is reported as a failure by Jaeger, and replay it (via the Insomnia REST client) and check error messages returned from Jaeger.\noutput { if [@metadata][type] == \"jaeger\" { http { url =\u003e \"http://192.168.0.115:9411/api/v2/spans\" format =\u003e \"json_batch\" http_method =\u003e \"post\" } http { url =\u003e \"http://requestloggerbin.herokuapp.com/bin/ff3da5b2-ec57-4611-ada8-b360ab38830c\" format =\u003e \"json_batch\" http_method =\u003e \"post\" } } else { # normal message handling: elasticsearch etc. stdout { codec =\u003e rubydebug } } } I also used LogStash’s log output by tailing the log file:\ntail -f /var/log/logstash/logstash-plain.log Eventually, I had a working LogStash configuration and can view application traces in Jaeger.\nProblems One thing I cannot figure out how to do is sending the tags property to Jaeger. The Zipkin (and OpenTracing) APIs specify tags to be an object, e.g.\n{ \"traceid\": \"1ee98d32185e41faba146c151ce8e27d\", \"id\": \"8377a6dae87947d7\", \"timestamp\": 1545321238784000, \"duration\": 409000, \"localEndpoint\": { \"serviceName\": \"PersonInformationService\" }, \"name\": \"SomeOperation\", \"tags\": { \"CorrelationID\": \"1ee98d32-185e-41fa-ba14-6c151ce8e27d\", \"db.name\": \"test-blahblah\" } } But LogStash wants the tags property to be an array of strings, and even using the remove_field on tags and then manually populating it doesn’t work. Currently, I don’t need anything in the tags, but it would be nice to have it working. I should ask on the Elastic forums perhaps.\nWrapping Up This post turned out to be a lot longer than I was expecting, but hopefully, it was interesting. Next time I’ll try and go through how I do testing of immutable infrastructure, as well as local development of the base images.\n","wordCount":"2364","inLanguage":"en","datePublished":"2018-12-22T00:00:00Z","dateModified":"2018-12-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/12/22/serilog-elk-jaeger/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Code-free tracing with LogStash and Jaeger</h1><div class=post-meta><span title='2018-12-22 00:00:00 +0000 UTC'>December 22, 2018</span>&nbsp;·&nbsp;12 min</div></header><div class=post-content><p>I wanted to show request charts (similar to the network tab in firefox) for requests across our microservices but wanted to do so in the least invasive way possible.</p><p><img loading=lazy src=firefox-network-timeline.png alt="Firefox network timeline"></p><p>We already use <a href=https://www.elastic.co/products/logstash>LogStash</a> to collect logs from multiple hosts (via <a href=https://www.elastic.co/products/beats/filebeat>FileBeat</a>) and forward them on to <a href=https://www.elastic.co/products/elasticsearch>ElasticSearch</a>, so perhaps I can do something to also output from LogStash to a tracing service.</p><p><img loading=lazy src=logstash-jaeger.png alt="app to filebeat to logstash to elasticsearch and opentracing"></p><p>There are a number of tracing services available (<a href=https://github.com/sourcegraph/appdash>AppDash</a>, <a href=https://www.jaegertracing.io/>Jaeger</a>, <a href=https://zipkin.io/>Zipkin</a>), but unfortunately LogStash doesn&rsquo;t have plugins for any of them or for <a href=https://opentracing.io/>OpenTracing</a>. I picked Jaeger, as it seemed to be the easiest to get up and running, and also had a &ldquo;Zipkin compatible&rdquo; API too if you didn&rsquo;t want to use the Jaeger one.</p><p>Setting up and running Jaeger in a production environment is way out of scope for this post, but for testing, I am just using the all-in-one Docker container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -d --nameron jaeger <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e COLLECTOR_ZIPKIN_HTTP_PORT<span style=color:#f92672>=</span><span style=color:#ae81ff>9411</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 5775:5775/udp <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 6831:6831/udp <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 6832:6832/udp <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 5778:5778 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 16686:16686 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 14268:14268 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 9411:9411 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  jaegertracing/all-in-one
</span></span></code></pre></div><p>The tracing APIs work in roughly the same way: all traces have the same <code>traceid</code>, and are sub-divided into spans. Spans have a unique id and can have a parent (span) id set. The trouble with sending data from LogStash is that I don&rsquo;t have any parent IDs available. Well, at least without going and adding it to all our applications, and I&rsquo;m not sure how I would want to propagate it correctly either.</p><p>So the first question is: can I push multiple spans without any parent IDs, and have it plot them as I would expect.</p><h2 id=is-spanparentid-required>Is span.parentid required?<a hidden class=anchor aria-hidden=true href=#is-spanparentid-required>#</a></h2><p>As the HTTP API documentation seems to be non-existent (other than &ldquo;there is one!&rdquo;), and most of the other docs mention the Thrift API, I decided to use that to test the theory. The <a href=https://github.com/jaegertracing/jaeger-client-csharp>Jaeger C# client</a> library has a nice API to use, but I wanted to manually specify things (e.g. <code>traceid</code>, <code>spanid</code>, etc.) and the API has no way to do that, as pretty much everything is marked as <code>internal</code>.</p><p>Instead, I cloned the client repository, and added a test (which had access to all the internals I wanted):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Scratch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> HttpSender _sender;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Tracer _tracer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> TraceId _id;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Scratch(ITestOutputHelper output)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _sender = <span style=color:#66d9ef>new</span> HttpSender(<span style=color:#e6db74>&#34;http://localhost:14268/api/traces&#34;</span>);
</span></span><span style=display:flex><span>        _tracer = <span style=color:#66d9ef>new</span> Tracer.Builder(<span style=color:#e6db74>&#34;FirstService&#34;</span>).Build();
</span></span><span style=display:flex><span>        _id = TraceId.NewUniqueId(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        output.WriteLine(_id.ToString());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [Fact]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Send()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> start = DateTime.UtcNow;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Create(start, start.AddSeconds(<span style=color:#ae81ff>5</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Create(start, start.AddSeconds(<span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Create(start.AddSeconds(<span style=color:#ae81ff>5</span>), start.AddSeconds(<span style=color:#ae81ff>10</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Create(start.AddSeconds(<span style=color:#ae81ff>10</span>), start.AddSeconds(<span style=color:#ae81ff>20</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> Create(start, start.AddSeconds(<span style=color:#ae81ff>20</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _sender.FlushAsync(CancellationToken.None);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> Task Create(DateTime start, DateTimeOffset finish)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> context = <span style=color:#66d9ef>new</span> SpanContext(_id, SpanId.NewUniqueId(), <span style=color:#66d9ef>new</span> SpanId(<span style=color:#ae81ff>0</span>), SpanContextFlags.None);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> span = <span style=color:#66d9ef>new</span> Span(_tracer, <span style=color:#e6db74>&#34;test&#34;</span>, context, start, <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>object</span>&gt;(), <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>        span.Finish(finish);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> _sender.AppendAsync(span, CancellationToken.None);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The graph rendered how I hoped, proving that I don&rsquo;t need to set the span&rsquo;s <code>parentid</code> for everything with the same <code>traceid</code> to work correctly!</p><h2 id=how-to-generate-a-consistent-traceid>How to generate a consistent TraceID?<a hidden class=anchor aria-hidden=true href=#how-to-generate-a-consistent-traceid>#</a></h2><p>All our services pass along or generate a <code>correlationID</code> for each request, so my idea here was to do some conversion to put it in the <code>traceid</code>, which is an <code>int64</code>. Our <code>correlationID</code>s are guids, which internally is an <code>int128</code>, so I figured I would take the least significant 8 bytes and use that. This can be done in C# like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> correlationID = Guid.NewGuid();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> traceID = <span style=color:#66d9ef>new</span> TraceId(BitConverter.ToInt64(correlationID.ToByteArray(), <span style=color:#ae81ff>8</span>));
</span></span></code></pre></div><p>I noticed, however, that the <code>TraceID</code> structure in the Jaeger client can take two values: <code>int64 low</code> and <code>int64 high</code>, so I can use the entire <code>correlationid</code>.</p><h2 id=how-to-ship-from-logstash>How to ship from LogStash?<a hidden class=anchor aria-hidden=true href=#how-to-ship-from-logstash>#</a></h2><p>After reading through the LogStash <a href=https://www.elastic.co/guide/en/logstash/current/output-plugins.html>Output Plugins docs</a> it looked like there were three possible ways to ship the events to Jaeger: writing a command line app; invoked through either <code>exec</code> or <code>pipe</code>, writing a LogStash plugin, or doing something with the <code>http</code> output.</p><h3 id=cli-adaptor>CLI adaptor<a hidden class=anchor aria-hidden=true href=#cli-adaptor>#</a></h3><p>The idea of this method would be to write a CLI app which takes an event from LogStash and then sends it to Jaeger using the Thrift API. The app itself could be invoked using the <code>exec</code> or <code>pipe</code> outputs. I didn&rsquo;t want to use this method for a few reasons:</p><p><strong>Development:</strong> The Jaeger client has things I need hidden from the public surface, such as being able to specify the <code>traceid</code>, rather than generating a new one each time, so I would either have to reimplement the classes I need, use reflection to instantiate things, or try opening Pull Requests to expose more internals of the library.</p><p><strong>Maintenance:</strong> I&rsquo;d rather not have yet another thing to maintain if I can avoid it, not to mention all the additional things like repository location, build agents, etc.</p><p><strong>Deployment:</strong> Our LogStash box is a plain Ubuntu box with nothing other than Java and LogStash installed on it. As I would probably end up using C# to write the app, I&rsquo;d need to add even more dependencies.</p><p><strong>Throughput:</strong> Jaeger (and the others) support sending traces in batches for better efficiency. Writing an app which supported that would involve writing the batching and caching, and the likelihood is I would mess it up, and increase the chances of lost messages.</p><h3 id=logstash-plugin>LogStash plugin<a hidden class=anchor aria-hidden=true href=#logstash-plugin>#</a></h3><p>Basically has the same problems as above, with the addition of me needing to learn enough about Java to build something reliable, and as this is a test and no one else in my team really knows Java either, so I ruled this out.</p><h3 id=http>Http?<a hidden class=anchor aria-hidden=true href=#http>#</a></h3><p>The Jaeger collector process can also expose a Zipkin compatible API, and while the documentation for that API is also terrible, I was able to find a <a href=https://github.com/openzipkin/zipkin/issues/1499>Pull Request on Github</a> with some structure defined. I figured I could do most of this directly with LogStash&rsquo;s configuration DSL, assuming I can: generate a uuid (<code>logstash-filter-uuid</code> plugin), and remove all extra stuff from the post body (<code>logstash-filter-prune</code>).</p><h2 id=building-the-logstash-message>Building the LogStash message<a hidden class=anchor aria-hidden=true href=#building-the-logstash-message>#</a></h2><p>The first step of my configuration is based on what we need to do to <a href=https://github.com/serilog/serilog>Serilog</a> messages to make them a bit nicer in Kibana:</p><h3 id=pre-processing>Pre-processing<a hidden class=anchor aria-hidden=true href=#pre-processing>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>json {
</span></span><span style=display:flex><span>    source <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;message&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>date {
</span></span><span style=display:flex><span>    match <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;Timestamp&#34;</span>, <span style=color:#e6db74>&#34;ISO8601&#34;</span>, <span style=color:#e6db74>&#34;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSSSSSZZ&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    target <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;@timestamp&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    rename <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[Properties][ApplicationName]&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;ApplicationName&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[Properties][CorrelationId]&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;CorrelationId&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[Properties][SourceContext]&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;Context&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;[Properties][TimedOperationElapsedInMs]&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;TimeElapsed&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>json</code> block tells LogStash that everything in the <code>message</code> property is a json object, rather than a string.</p><p>The <code>date</code> block extracts the time the message was recorded by the application and writes it to the special <code>@timestamp</code> field. This is a good idea as due to queuing, and processing times, the time the message was written and the time it was processed by LogStash will be different.</p><p>Lastly, the <code>mutate</code> block is moving a bunch of fields out of the message properties, and up to the top level of the object. We query by things like <code>ApplicationName</code> a lot, and it&rsquo;s nice not to have to write <code>Properties.ApplicationName:blahblah</code> all the time.</p><h3 id=splitting>Splitting<a hidden class=anchor aria-hidden=true href=#splitting>#</a></h3><p>Our messages contain a lot of data which for the purposes of tracing, we just don&rsquo;t care about. Not only is it a waste of bandwidth to send all the data to Jaeger, but also there could be clashing fields, and if we ever decide to use a hosted version of Jaeger, I don&rsquo;t want to be sending them all the data either.</p><p>So how do we remove everything from the message, but still keep it in the message for the other outputs?</p><p>LogStash has an interesting filter called <code>clone</code>. What it does is copy the message as many times as you specify, and then runs the remaining part of the pipeline once per message, including the original message. In code, this just looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>clone {
</span></span><span style=display:flex><span>    clones <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;jaeger&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we wanted to split the message more times, we can just add more types to the <code>clones</code> array; there will be one extra message produced for each entry in the array, which will also be added to the message as the <code>type</code> property so we can filter on it later.</p><p>We don&rsquo;t want to send the <code>type</code> field itself to Jaeger (or ElasticSeach), so we move it from the message to the <code>@metadata</code> object, which doesn&rsquo;t get passed to outputs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    rename <span style=color:#f92672>=&gt;</span> { <span style=color:#e6db74>&#34;type&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;[@metadata][type]&#34;</span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To handle the messages differently, we can just use an <code>if</code> statement on the <code>@metadata.type</code> property:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span>@metadata<span style=color:#f92672>][</span>type<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;jaeger&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e># do stuff to the jaeger message</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e># process the original message</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=building-the-http-payload>Building the Http Payload<a hidden class=anchor aria-hidden=true href=#building-the-http-payload>#</a></h3><p>The hardest part of getting this to work was handling the dates. Jaeger specifies that timestamps should come in <strong>micro</strong>seconds since epoch, and duration should be in microseconds also. We need to use the <code>ruby</code> filter so we can run some code to do this, rather than using an inbuilt filter primitive.</p><p>The <code>duration</code> is easy enough, as we report <code>TimeElapsed</code> in milliseconds:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>ruby {
</span></span><span style=display:flex><span>    code <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;event.set(&#39;duration&#39;, (event.get(&#39;TimeElapsed&#39;) * 1000).floor)&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To handle the timestamp we need to convert it to epoch milliseconds. We can get the fractional seconds since the epoch by calling <a href=https://ruby-doc.org/core-1.9.3/Time.html#method-i-to_f><code>to_f</code></a> on the <code>@timestamp</code> field, and then multiply by <code>1000</code> a couple of times to express it as microseconds. We also <code>floor</code> it to remove the leftover fraction:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>ruby {
</span></span><span style=display:flex><span>    code <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;event.set(&#39;timestamp&#39;, (event.get(&#39;@timestamp&#39;).to_f * 1000 * 1000).floor)&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This on its own will work, but it <strong>won&rsquo;t be right</strong>. We report log entries when an operation completes, which means our timestamp is the finish of the event, not the start. To solve this, we subtract the duration off the timestamp:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>ruby {
</span></span><span style=display:flex><span>    code <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;event.set(&#39;timestamp&#39;, (event.get(&#39;@timestamp&#39;).to_f * 1000 * 1000).floor - event.get(&#39;duration&#39;))&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we need to create our span id. We need to generate a random id, consisting of letters and numbers, so the easiest way is to generate a <code>uuid</code>, and then tweak it to fit the Jaeger/Zipkin format. To do that we need to install the <code>logstash-filter-uuid</code> plugin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/usr/share/logstash/bin/logstash-plugin install logstash-filter-uuid
</span></span></code></pre></div><p>There are a few things we need to do to generate a valid span id (for Jaeger):</p><ol><li>generate a uuid</li><li>remove the dashes</li><li>make it lowercase</li><li>trim it to 16 chars</li></ol><p>We use four filters to achieve this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>uuid {
</span></span><span style=display:flex><span>    target <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;id&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    gsub <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;-&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    lowercase <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    gsub <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;(^.{1,16}).*$&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\1</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The reason we specify the <code>mutate</code> twice is that order of the same operation (<code>gsub</code> in this case) is not guaranteed within a <code>mutate</code> block.</p><p>Next up we need to tweak the <code>traceid</code> from a guid to a uuid:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    gsub <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;traceid&#34;</span>, <span style=color:#e6db74>&#34;-&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    lowercase <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;traceid&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we can populate some other context into the message, by renaming the other fields we want. I discovered most of the fields and their formats from a combination of the <a href=https://github.com/jaegertracing/jaeger-idl/blob/master/thrift/zipkincore.thrift>thrift dtos</a> and the <a href=https://github.com/openzipkin/zipkin/issues/1499>this pull request</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    rename <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CorrelationId&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;traceid&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Context&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;ApplicationName&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;[localEndpoint][serviceName]&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, we want to trim all the other properties from our message, which we can do by using the <code>logstash-filter-prune</code> plugin:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>prune {
</span></span><span style=display:flex><span>    whitelist_names <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;traceid&#34;</span>, <span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;timestamp&#34;</span>, <span style=color:#e6db74>&#34;duration&#34;</span>, <span style=color:#e6db74>&#34;localEndpoint&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    remove_field <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;@timestamp&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We have to explicitly remove the <code>@timestamp</code> property as the prune plugin seems to ignore it (it also ignores the <code>@metadata</code> property).</p><p>The complete filter code can be made a little more efficient by combining several of the <code>mutate</code> blocks, provided we keep things in the right order, as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>ruby {
</span></span><span style=display:flex><span>    code <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;event.set(&#39;duration&#39;, (event.get(&#39;TimeElapsed&#39;) * 1000).floor)&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ruby {
</span></span><span style=display:flex><span>    code <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;event.set(&#39;timestamp&#39;, (event.get(&#39;@timestamp&#39;).to_f * 1000 * 1000).floor - event.get(&#39;duration&#39;))&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uuid {
</span></span><span style=display:flex><span>    target <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;id&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    rename <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;CorrelationId&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;traceid&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;Context&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;ApplicationName&#34;</span> <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;[localEndpoint][serviceName]&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    remove_field <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;@timestamp&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    gsub <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;-&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    gsub <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;traceid&#34;</span>, <span style=color:#e6db74>&#34;-&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    lowercase <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;traceid&#34;</span>, <span style=color:#e6db74>&#34;id&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mutate {
</span></span><span style=display:flex><span>    gsub <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;(^.{1,16}).*$&#34;</span>, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\1</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>prune {
</span></span><span style=display:flex><span>    whitelist_names <span style=color:#f92672>=&gt;</span> <span style=color:#f92672>[</span> <span style=color:#e6db74>&#34;id&#34;</span>, <span style=color:#e6db74>&#34;traceid&#34;</span>, <span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;timestamp&#34;</span>, <span style=color:#e6db74>&#34;duration&#34;</span>, <span style=color:#e6db74>&#34;localEndpoint&#34;</span> <span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=publishing-to-jaeger>Publishing to Jaeger<a hidden class=anchor aria-hidden=true href=#publishing-to-jaeger>#</a></h3><p>When publishing to the Jaeger API, you have to send it an array of json objects. To achieve this in the <code>http</code> output plugin, we can enable the <code>format => json_batch</code>, which will cause the HTTP client to buffer some events and then send them all at once. So more efficiency, and no extra code on our part.</p><p>To help make testing easier, I publish to two different HTTP endpoints: the Jaeger docker container running on my host machine, and to a <a href=http://requestloggerbin.herokuapp.com/>Request Logger Bin</a>; where I can inspect the response if something is reported as a failure by Jaeger, and replay it (via the <a href=https://insomnia.rest/>Insomnia</a> REST client) and check error messages returned from Jaeger.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>output {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span>@metadata<span style=color:#f92672>][</span>type<span style=color:#f92672>]</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;jaeger&#34;</span> {
</span></span><span style=display:flex><span>        http {
</span></span><span style=display:flex><span>            url <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;http://192.168.0.115:9411/api/v2/spans&#34;</span>
</span></span><span style=display:flex><span>            format <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;json_batch&#34;</span>
</span></span><span style=display:flex><span>            http_method <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;post&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        http {
</span></span><span style=display:flex><span>            url <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;http://requestloggerbin.herokuapp.com/bin/ff3da5b2-ec57-4611-ada8-b360ab38830c&#34;</span>
</span></span><span style=display:flex><span>            format <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;json_batch&#34;</span>
</span></span><span style=display:flex><span>            http_method <span style=color:#f92672>=&gt;</span> <span style=color:#e6db74>&#34;post&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e># normal message handling: elasticsearch etc.</span>
</span></span><span style=display:flex><span>        stdout { codec <span style=color:#f92672>=&gt;</span> rubydebug }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I also used LogStash&rsquo;s log output by tailing the log file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -f /var/log/logstash/logstash-plain.log
</span></span></code></pre></div><p>Eventually, I had a working LogStash configuration and can view application traces in Jaeger.</p><h2 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h2><p>One thing I cannot figure out how to do is sending the <code>tags</code> property to Jaeger. The Zipkin (and OpenTracing) APIs specify tags to be an object, e.g.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;traceid&#34;</span>: <span style=color:#e6db74>&#34;1ee98d32185e41faba146c151ce8e27d&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#e6db74>&#34;8377a6dae87947d7&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;timestamp&#34;</span>: <span style=color:#ae81ff>1545321238784000</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;duration&#34;</span>: <span style=color:#ae81ff>409000</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;localEndpoint&#34;</span>: { <span style=color:#f92672>&#34;serviceName&#34;</span>: <span style=color:#e6db74>&#34;PersonInformationService&#34;</span> },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;SomeOperation&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;tags&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;CorrelationID&#34;</span>: <span style=color:#e6db74>&#34;1ee98d32-185e-41fa-ba14-6c151ce8e27d&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;db.name&#34;</span>: <span style=color:#e6db74>&#34;test-blahblah&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But LogStash wants the <code>tags</code> property to be an array of strings, and even using the <code>remove_field</code> on <code>tags</code> and then manually populating it doesn&rsquo;t work. Currently, I don&rsquo;t <em>need</em> anything in the tags, but it would be nice to have it working. I should ask on the Elastic forums perhaps.</p><h2 id=wrapping-up>Wrapping Up<a hidden class=anchor aria-hidden=true href=#wrapping-up>#</a></h2><p>This post turned out to be a lot longer than I was expecting, but hopefully, it was interesting. Next time I&rsquo;ll try and go through how I do testing of immutable infrastructure, as well as local development of the base images.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/jaeger/>jaeger</a></li><li><a href=https://andydote.co.uk/tags/logstash/>logstash</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li><li><a href=https://andydote.co.uk/tags/infrastructure/>infrastructure</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2019/01/01/immutable-infra/><span class=title>« Prev Page</span><br><span>Testing Immutable Infrastructure</span></a>
<a class=next href=https://andydote.co.uk/2018/12/16/against-semver/><span class=title>Next Page »</span><br><span>Against SemVer</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>