<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Locking Vault Down with Policies | Andy Dote</title><meta name=keywords content="vault,security,microservices"><meta name=description content="The final part of my Vault miniseries focuses on permissioning, which is provided by Vault&rsquo;s Policies.
As everything in Vault is represented as a path, the policies DSL (Domain Specific Language) just needs to apply permissions to paths to lock things down. For example, to allow all operations on the cubbyhole secret engine, we would define this policy:
path &#34;cubbyhole/*&#34; { capabilities = [&#34;create&#34;, &#34;read&#34;, &#34;update&#34;, &#34;delete&#34;, &#34;list&#34;] } Vault comes with a default policy which allows token operations (such as looking up its own token info, releasing and renewing tokens), and cubbyhole access."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/06/23/vault-locking-it-down-with-policies/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ea821116adbd94ff8c04bf7745204429750a1079f16951db0415b837fc273249.css integrity="sha256-6oIRFq29lP+MBL93RSBEKXUKEHnxaVHbBBW4N/wnMkk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Locking Vault Down with Policies"><meta property="og:description" content="The final part of my Vault miniseries focuses on permissioning, which is provided by Vault&rsquo;s Policies.
As everything in Vault is represented as a path, the policies DSL (Domain Specific Language) just needs to apply permissions to paths to lock things down. For example, to allow all operations on the cubbyhole secret engine, we would define this policy:
path &#34;cubbyhole/*&#34; { capabilities = [&#34;create&#34;, &#34;read&#34;, &#34;update&#34;, &#34;delete&#34;, &#34;list&#34;] } Vault comes with a default policy which allows token operations (such as looking up its own token info, releasing and renewing tokens), and cubbyhole access."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/06/23/vault-locking-it-down-with-policies/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-06-23T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-23T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Locking Vault Down with Policies"><meta name=twitter:description content="The final part of my Vault miniseries focuses on permissioning, which is provided by Vault&rsquo;s Policies.
As everything in Vault is represented as a path, the policies DSL (Domain Specific Language) just needs to apply permissions to paths to lock things down. For example, to allow all operations on the cubbyhole secret engine, we would define this policy:
path &#34;cubbyhole/*&#34; { capabilities = [&#34;create&#34;, &#34;read&#34;, &#34;update&#34;, &#34;delete&#34;, &#34;list&#34;] } Vault comes with a default policy which allows token operations (such as looking up its own token info, releasing and renewing tokens), and cubbyhole access."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Locking Vault Down with Policies","item":"https://andydote.co.uk/2018/06/23/vault-locking-it-down-with-policies/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Locking Vault Down with Policies","name":"Locking Vault Down with Policies","description":"The final part of my Vault miniseries focuses on permissioning, which is provided by Vault\u0026rsquo;s Policies.\nAs everything in Vault is represented as a path, the policies DSL (Domain Specific Language) just needs to apply permissions to paths to lock things down. For example, to allow all operations on the cubbyhole secret engine, we would define this policy:\npath \u0026#34;cubbyhole/*\u0026#34; { capabilities = [\u0026#34;create\u0026#34;, \u0026#34;read\u0026#34;, \u0026#34;update\u0026#34;, \u0026#34;delete\u0026#34;, \u0026#34;list\u0026#34;] } Vault comes with a default policy which allows token operations (such as looking up its own token info, releasing and renewing tokens), and cubbyhole access.","keywords":["vault","security","microservices"],"articleBody":"The final part of my Vault miniseries focuses on permissioning, which is provided by Vault’s Policies.\nAs everything in Vault is represented as a path, the policies DSL (Domain Specific Language) just needs to apply permissions to paths to lock things down. For example, to allow all operations on the cubbyhole secret engine, we would define this policy:\npath \"cubbyhole/*\" { capabilities = [\"create\", \"read\", \"update\", \"delete\", \"list\"] } Vault comes with a default policy which allows token operations (such as looking up its own token info, releasing and renewing tokens), and cubbyhole access.\nLet’s combine the last two posts (Managing Postgres Connection Strings with Vault and Secure Communication with Vault) and create a Policy which will allow the use of generated database credentials. If you want more details on the how/why of the set up phase, see those two posts.\nSetup First, we’ll create two containers which will get removed on exit - a Postgres one and a Vault one. Vault is being started in dev mode, so we don’t need to worry about init and unsealing it.\ndocker run --rm -d -p 5432:5432 -e 'POSTGRES_PASSWORD=postgres' postgres:alpine docker run --rm -d -p 8200:8200 --cap-add=IPC_LOCK -e VAULT_DEV_ROOT_TOKEN_ID=vault vault Next, we’ll create our Postgres user account which Vault will use to create temporary credentials:\npsql --username postgres --dbname postgres psql\u003e create role VaultAdmin with Login password 'vault' CreateRole; psql\u003e grant connect on database postgres to vaultadmin; Let’s also configure the environment to talk to Vault as an administrator, and enable the two Vault plugins we’ll need:\nexport VAULT_ADDR=\"http://localhost:8200\" export VAULT_TOKEN=\"vault\" vault auth enable approle vault secrets enable database We’ll also set up our database secret engine, and configure database roll creation:\nvault write database/config/postgres_demo \\ plugin_name=postgresql-database-plugin \\ allowed_roles=\"default\" \\ connection_url=\"postgresql://{{username}}:{{password}}@10.0.75.1:5432/postgres?sslmode=disable\" \\ username=\"VaultAdmin\" \\ password=\"vault\" vault write database/roles/reader \\ db_name=postgres_demo \\ creation_statements=\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \\ GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\" \\ default_ttl=\"10m\" \\ max_ttl=\"1h\" Creating a Policy First, we need to create the policy. This can be supplied inline on the command line, but reading from a file means it can be source-controlled, and you something readable too!\nWhile the filename doesn’t need to match the policy name, it helps make it a bit clearer if it does match, so we’ll call this file postgres-connector.hcl.\n# vault read database/creds/reader path \"database/creds/reader\" { capabilities = [\"read\"] } We can then register this policy into Vault. The write documentation indicates that you need to prefix the file path with @, but that doesn’t work for me:\nvault policy write postgres-connector postgres-connector.hcl Setup AppRoles As before, we’ll create a demo_app role for our application to use to get a token. However this time, we’ll specify the policies field, and pass it in both default and our custom postgres-connector role.\nvault write auth/approle/role/demo_app \\ policies=\"postgres-connector,default\" When we generate our client token using the secret_id and role_id, we’ll get a token which can create database credentials, as well as access the cubbyhole.\nThe final part of being an admin user for this is to generate and save the secret_id and role_id:\nvault write -f -field=secret_id auth/approle/role/demo_app/secret-id vault read -field=role_id auth/approle/role/demo_app/role-id Creating a Token and Accessing the Database Opening a new command line window, we need to generate our client token. Take the two id’s output from the admin window, and use them in the following code block:\nexport VAULT_ADDR=\"http://localhost:8200\" SECRET_ID=\"\" # from the 'admin' window! ROLE_ID=\"\" # from the 'admin' window! export VAULT_TOKEN=$(curl -X POST --data \"{ \\\"role_id\\\":\\\"$ROLE_ID\\\", \\\"secret_id\\\":\\\"$SECRET_ID\\\" }\" $VAULT_ADDR/v1/auth/approle/login | jq -r .auth.client_token) Now we have a client token, we can generate a database connection:\nvault read database/creds/reader # Key Value # --- ----- # lease_id database/creds/reader/dc2ae2b6-c709-0e2f-49a6-36b45aa84490 # lease_duration 10m # lease_renewable true # password A1a-1kAiN0gqU07BE39N # username v-approle-reader-incldNFPhixc1Kj25Rar-1529764057 Which can also be renewed:\nvault lease renew database/creds/reader/dc2ae2b6-c709-0e2f-49a6-36b45aa84490 # Key Value # --- ----- # lease_id database/creds/reader/dc2ae2b6-c709-0e2f-49a6-36b45aa84490 # lease_duration 10m # lease_renewable true However, if we try to write to the database roles, we get an error:\nvault write database/roles/what dbname=postgres_demo # Error writing data to database/roles/what: Error making API request. # # URL: PUT http://localhost:8200/v1/database/roles/what # Code: 403. Errors: # # * permission denied Summary It is also a good idea to have separate fine-grained policies, which can then be grouped up against separate AppRoles, allowing each AppRole to have just the permissions it needs. For example, you could have the following Policies:\npostgres-connection postgres-admin rabbitmq-connection kafka-consumer You would then have several AppRoles defined which could use different Policies:\nApp1: rabbitmq-connection, postgres-connection App2: kafka-consumer, rabbitmq-connection App3: postgres-admin Which helps encourage you to have separate AppRoles for each of your applications!\nFinally, the Vault website has a guide on how to do this too…which I only found after writing this! At least what I wrote seems to match up with their guide pretty well, other than I also use AppRole authentication (and so should you!)\n","wordCount":"812","inLanguage":"en","datePublished":"2018-06-23T00:00:00Z","dateModified":"2018-06-23T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/06/23/vault-locking-it-down-with-policies/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Locking Vault Down with Policies</h1><div class=post-meta><span title='2018-06-23 00:00:00 +0000 UTC'>June 23, 2018</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>The final part of my Vault miniseries focuses on permissioning, which is provided by Vault&rsquo;s <a href=https://www.vaultproject.io/docs/concepts/policies.html>Policies</a>.</p><p>As everything in Vault is represented as a path, the policies DSL (Domain Specific Language) just needs to apply permissions to paths to lock things down. For example, to allow all operations on the <code>cubbyhole</code> secret engine, we would define this policy:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>path <span style=color:#e6db74>&#34;cubbyhole/*&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;create&#34;</span>, <span style=color:#e6db74>&#34;read&#34;</span>, <span style=color:#e6db74>&#34;update&#34;</span>, <span style=color:#e6db74>&#34;delete&#34;</span>, <span style=color:#e6db74>&#34;list&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Vault comes with a default policy which allows token operations (such as looking up its own token info, releasing and renewing tokens), and cubbyhole access.</p><p>Let&rsquo;s combine the last two posts (<a href=2018/06/17/secret-management-vault-postgres-connection/>Managing Postgres Connection Strings with Vault</a> and <a href=/2018/06/22/vault-secure-communication/>Secure Communication with Vault</a>) and create a Policy which will allow the use of generated database credentials. If you want more details on the how/why of the set up phase, see those two posts.</p><h2 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h2><p>First, we&rsquo;ll create two containers which will get removed on exit - a Postgres one and a Vault one. Vault is being started in <code>dev</code> mode, so we don&rsquo;t need to worry about init and unsealing it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run --rm -d -p 5432:5432 -e <span style=color:#e6db74>&#39;POSTGRES_PASSWORD=postgres&#39;</span> postgres:alpine
</span></span><span style=display:flex><span>docker run --rm -d -p 8200:8200 --cap-add<span style=color:#f92672>=</span>IPC_LOCK -e VAULT_DEV_ROOT_TOKEN_ID<span style=color:#f92672>=</span>vault vault
</span></span></code></pre></div><p>Next, we&rsquo;ll create our Postgres user account which Vault will use to create temporary credentials:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>psql --username postgres --dbname postgres
</span></span><span style=display:flex><span>psql&gt; create role VaultAdmin with Login password <span style=color:#e6db74>&#39;vault&#39;</span> CreateRole;
</span></span><span style=display:flex><span>psql&gt; grant connect on database postgres to vaultadmin;
</span></span></code></pre></div><p>Let&rsquo;s also configure the environment to talk to Vault as an administrator, and enable the two Vault plugins we&rsquo;ll need:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_ADDR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>
</span></span><span style=display:flex><span>export VAULT_TOKEN<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vault&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault auth enable approle
</span></span><span style=display:flex><span>vault secrets enable database
</span></span></code></pre></div><p>We&rsquo;ll also set up our database secret engine, and configure database roll creation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write database/config/postgres_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    plugin_name<span style=color:#f92672>=</span>postgresql-database-plugin <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    allowed_roles<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;default&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    connection_url<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;postgresql://{{username}}:{{password}}@10.0.75.1:5432/postgres?sslmode=disable&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    username<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;VaultAdmin&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    password<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vault&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vault write database/roles/reader <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    db_name<span style=color:#f92672>=</span>postgres_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    creation_statements<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;CREATE ROLE \&#34;{{name}}\&#34; WITH LOGIN PASSWORD &#39;{{password}}&#39; VALID UNTIL &#39;{{expiration}}&#39;; \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        GRANT SELECT ON ALL TABLES IN SCHEMA public TO \&#34;{{name}}\&#34;;&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    default_ttl<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;10m&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    max_ttl<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1h&#34;</span>
</span></span></code></pre></div><h2 id=creating-a-policy>Creating a Policy<a hidden class=anchor aria-hidden=true href=#creating-a-policy>#</a></h2><p>First, we need to create the policy. This can be supplied inline on the command line, but reading from a file means it can be source-controlled, and you something readable too!</p><p>While the filename doesn&rsquo;t need to match the policy name, it helps make it a bit clearer if it does match, so we&rsquo;ll call this file <code>postgres-connector.hcl</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># vault read database/creds/reader</span>
</span></span><span style=display:flex><span>path <span style=color:#e6db74>&#34;database/creds/reader&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    capabilities <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#e6db74>&#34;read&#34;</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>We can then register this policy into Vault. The <code>write</code> documentation indicates that you need to prefix the file path with <code>@</code>, but that doesn&rsquo;t work for me:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault policy write postgres-connector postgres-connector.hcl
</span></span></code></pre></div><h2 id=setup-approles>Setup AppRoles<a hidden class=anchor aria-hidden=true href=#setup-approles>#</a></h2><p>As before, we&rsquo;ll create a <code>demo_app</code> role for our application to use to get a token. However this time, we&rsquo;ll specify the <code>policies</code> field, and pass it in both <code>default</code> and our custom <code>postgres-connector</code> role.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write auth/approle/role/demo_app <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    policies<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;postgres-connector,default&#34;</span>
</span></span></code></pre></div><p>When we generate our client token using the <code>secret_id</code> and <code>role_id</code>, we&rsquo;ll get a token which can create database credentials, as well as access the cubbyhole.</p><p>The final part of being an <strong>admin</strong> user for this is to generate and save the <code>secret_id</code> and <code>role_id</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write -f -field<span style=color:#f92672>=</span>secret_id auth/approle/role/demo_app/secret-id
</span></span><span style=display:flex><span>vault read -field<span style=color:#f92672>=</span>role_id auth/approle/role/demo_app/role-id
</span></span></code></pre></div><h2 id=creating-a-token-and-accessing-the-database>Creating a Token and Accessing the Database<a hidden class=anchor aria-hidden=true href=#creating-a-token-and-accessing-the-database>#</a></h2><p>Opening a new command line window, we need to generate our client token. Take the two id&rsquo;s output from the admin window, and use them in the following code block:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_ADDR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>
</span></span><span style=display:flex><span>SECRET_ID<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># from the &#39;admin&#39; window!</span>
</span></span><span style=display:flex><span>ROLE_ID<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span> <span style=color:#75715e># from the &#39;admin&#39; window!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export VAULT_TOKEN<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>curl -X POST --data <span style=color:#e6db74>&#34;{ \&#34;role_id\&#34;:\&#34;</span>$ROLE_ID<span style=color:#e6db74>\&#34;, \&#34;secret_id\&#34;:\&#34;</span>$SECRET_ID<span style=color:#e6db74>\&#34; }&#34;</span> $VAULT_ADDR/v1/auth/approle/login | jq  -r .auth.client_token<span style=color:#66d9ef>)</span>
</span></span></code></pre></div><p>Now we have a client token, we can generate a database connection:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault read database/creds/reader
</span></span><span style=display:flex><span><span style=color:#75715e># Key                Value</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ---                -----</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lease_id           database/creds/reader/dc2ae2b6-c709-0e2f-49a6-36b45aa84490</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lease_duration     10m</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lease_renewable    true</span>
</span></span><span style=display:flex><span><span style=color:#75715e># password           A1a-1kAiN0gqU07BE39N</span>
</span></span><span style=display:flex><span><span style=color:#75715e># username           v-approle-reader-incldNFPhixc1Kj25Rar-1529764057</span>
</span></span></code></pre></div><p>Which can also be renewed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault lease renew database/creds/reader/dc2ae2b6-c709-0e2f-49a6-36b45aa84490
</span></span><span style=display:flex><span><span style=color:#75715e># Key                Value</span>
</span></span><span style=display:flex><span><span style=color:#75715e># ---                -----</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lease_id           database/creds/reader/dc2ae2b6-c709-0e2f-49a6-36b45aa84490</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lease_duration     10m</span>
</span></span><span style=display:flex><span><span style=color:#75715e># lease_renewable    true</span>
</span></span></code></pre></div><p>However, if we try to write to the database roles, we get an error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write database/roles/what dbname<span style=color:#f92672>=</span>postgres_demo
</span></span><span style=display:flex><span><span style=color:#75715e># Error writing data to database/roles/what: Error making API request.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># URL: PUT http://localhost:8200/v1/database/roles/what</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Code: 403. Errors:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#</span>
</span></span><span style=display:flex><span><span style=color:#75715e># * permission denied</span>
</span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>It is also a good idea to have separate fine-grained policies, which can then be grouped up against separate AppRoles, allowing each AppRole to have just the permissions it needs. For example, you could have the following Policies:</p><ul><li>postgres-connection</li><li>postgres-admin</li><li>rabbitmq-connection</li><li>kafka-consumer</li></ul><p>You would then have several AppRoles defined which could use different Policies:</p><ul><li>App1: rabbitmq-connection, postgres-connection</li><li>App2: kafka-consumer, rabbitmq-connection</li><li>App3: postgres-admin</li></ul><p>Which helps encourage you to have separate AppRoles for each of your applications!</p><p>Finally, the Vault website has a <a href=https://www.vaultproject.io/guides/secret-mgmt/dynamic-secrets.html>guide</a> on how to do this too&mldr;which I only found after writing this! At least what I wrote seems to match up with their guide pretty well, other than I also use <code>AppRole</code> authentication (and so should you!)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/vault/>vault</a></li><li><a href=https://andydote.co.uk/tags/security/>security</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/08/07/managing-consul-appsettings/><span class=title>« Prev Page</span><br><span>Managing AppSettings in Consul</span></a>
<a class=next href=https://andydote.co.uk/2018/06/22/vault-secure-communication/><span class=title>Next Page »</span><br><span>Secure Communication with Vault</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>