<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Secure Communication with Vault | Andy Dote</title><meta name=keywords content="vault,security,microservices"><meta name=description content="I think Vault by Hashicorp is a great product - I particularly love how you can do dynamic secret generation (e.g for database connections). But how do you validate that the application requesting the secret is allowed to perform that action? How do you know it&rsquo;s not someone or something impersonating your application?
While musing this at an airport the other day, my colleague Patrik sent me a link to a StackOverflow post about this very question"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/06/22/vault-secure-communication/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Secure Communication with Vault"><meta property="og:description" content="I think Vault by Hashicorp is a great product - I particularly love how you can do dynamic secret generation (e.g for database connections). But how do you validate that the application requesting the secret is allowed to perform that action? How do you know it&rsquo;s not someone or something impersonating your application?
While musing this at an airport the other day, my colleague Patrik sent me a link to a StackOverflow post about this very question"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/06/22/vault-secure-communication/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Secure Communication with Vault"><meta name=twitter:description content="I think Vault by Hashicorp is a great product - I particularly love how you can do dynamic secret generation (e.g for database connections). But how do you validate that the application requesting the secret is allowed to perform that action? How do you know it&rsquo;s not someone or something impersonating your application?
While musing this at an airport the other day, my colleague Patrik sent me a link to a StackOverflow post about this very question"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Secure Communication with Vault","item":"https://andydote.co.uk/2018/06/22/vault-secure-communication/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Secure Communication with Vault","name":"Secure Communication with Vault","description":"I think Vault by Hashicorp is a great product - I particularly love how you can do dynamic secret generation (e.g for database connections). But how do you validate that the application requesting the secret is allowed to perform that action? How do you know it\u0026rsquo;s not someone or something impersonating your application?\nWhile musing this at an airport the other day, my colleague Patrik sent me a link to a StackOverflow post about this very question","keywords":["vault","security","microservices"],"articleBody":"I think Vault by Hashicorp is a great product - I particularly love how you can do dynamic secret generation (e.g for database connections). But how do you validate that the application requesting the secret is allowed to perform that action? How do you know it’s not someone or something impersonating your application?\nWhile musing this at an airport the other day, my colleague Patrik sent me a link to a StackOverflow post about this very question\nThe summary is this:\n Use an AppRole rather than a plain token Bake the RoleID into your application Provide a SecretID from the environment Combine both to get a token from Vault on startup Periodically renew said token.  Or, in picture form:\nSo let’s see how we can go about doing this.\n0. Setup Vault This time we will use Vault in dev mode, which means that it starts unsealed, and we can specify the root token as something simple. On the downside, there is no persistence; restarting the container gives you a blank slate. If you would prefer to use Vault with persistent storage, see Section 2 of the previous post:\ndocker run \\  -d --rm \\  --name vault_demo \\  --cap-add=IPC_LOCK \\  -e VAULT_DEV_ROOT_TOKEN_ID=vault \\  -p 8200:8200 \\  vault As in the previous article, we’ll export the VAULT_TOKEN and VAULT_ADDR variables so we can use the Vault CLI:\nexport VAULT_ADDR=\"http://localhost:8200\" export VAULT_TOKEN=\"vault\" For our last setup step, we need to enable the AppRole auth method:\nvault auth enable approle 1. Create A Role Creating a role has many parameters you can specify, but for our demo_app role, we are going to skip most of them, just providing token_ttl and token_max_ttl.\nvault write auth/approle/role/demo_app \\  token_ttl=20m \\  token_max_ttl=1h 2. Request A Secret ID Vault has two modes of working, called Push and Pull. Push mode is when you generate the secret_id yourself and store it against the role. Pull mode is when you request Vault to generate the secret_id against the role and return it to you. I favour the Pull model, as it is one less thing to worry about (how to generate a secure secret_id.)\nWe have to specify the -force (shorthand -f) as we are writing a secret which has no key-value pairs, and as we are using the CLI, I have specified -field=secret_id which changes the command to only output the secret_id’s value, rather than the whole object.\nexport SECRET_ID=$(vault write -f -field=secret_id auth/approle/role/demo_app/secret-id)  echo $SECRET_ID # 119439b3-4eec-5e5b-ce85-c1d00f046234 3. Write Secret ID to Environment This step would be done by another process, such as Terraform when provisioning your environment, or Spinnaker when deploying your containers.\nAs we are just using the CLI, we can pretend that $SECRET_ID represents the value stored in the environment.\n4. Fetch Role ID Next, assuming the role of the developer writing an app, we need fetch the role_id, for our demo_app role. As with fetching the secret_id, we specify the -field=role_id so we only get that part of the response printed:\nvault read -field=role_id auth/approle/role/demo_app/role-id # 723d66af-3ddd-91c0-7b35-1ee51a30c5b8 5. Embed Role ID in Code We’re on the CLI, and have saved the role_id into the $ROLE_ID variable, so nothing more to do here!\nLet’s create a simple C# Console app to demo this with:\ndotnet new console --name VaultDemo dotnet new sln --name VaultDemo dotnet sln add VaultDemo/VaultDemo.csproj dotnet add VaultDemo/VaultDemo.csproj package VaultSharp We also installed the VaultSharp NuGet package, which takes care of doing the client token fetching for you - but we will go through what this is doing internally later!\nclass Program {  private const string RoleID = \"723d66af-3ddd-91c0-7b35-1ee51a30c5b8\";   static async Task Main(string[] args)  {  var auth = new AppRoleAuthenticationInfo(  RoleID,  Environment.GetEnvironmentVariable(\"SECRET_ID\")  );   var client = VaultClientFactory.CreateVaultClient(  new Uri(\"http://localhost:8200\"),  auth  );   await client.CubbyholeWriteSecretAsync(\"test/path\", new Dictionarystring, object  {  { \"Name\", \"I'm a secret Name!\" }  });   var secrets = await client.CubbyholeReadSecretAsync(\"test/path\");  Console.WriteLine(secrets.Data[\"Name\"]);  } } 6. Deploy! As we’re running locally, nothing to do here, but if you want, imagine that you created a docker container or baked an AMI and deployed it to the cloud or something!\n7. Run / On Start As we’ve already saved the SECRET_ID into an environment variable, we can just run the application:\ndotnet run --project VaultDemo/VaultDemo.csproj # I'm a secret Name! So what did the application do? When run, the application used both the role_id from the constant and the secret_id environment variable to call Vault’s Login method. An equivalent curl command would be this:\ncurl -X POST \\  --data '{ \"role_id\":\"723d66af-3ddd-91c0-7b35-1ee51a30c5b8\", \"secret_id\":\"119439b3-4eec-5e5b-ce85-c1d00f046234\" }' \\  http://localhost:8200/v1/auth/approle/login This will spit out a single line of json, but if you have jq in your path, you can prettify the output by appending | jq .:\n{  \"request_id\": \"37c0e057-6fab-1873-3ec0-affaace26e76\",  \"lease_id\": \"\",  \"renewable\": false,  \"lease_duration\": 0,  \"data\": null,  \"wrap_info\": null,  \"warnings\": null,  \"auth\": {  \"client_token\": \"c14f5806-aff2-61b6-42c2-8920c8049b6c\",  \"accessor\": \"aef3d4f4-d279-bcda-8d9c-2a3de6344975\",  \"policies\": [  \"default\"  ],  \"metadata\": {  \"role_name\": \"demo_app\"  },  \"lease_duration\": 1200,  \"renewable\": true,  \"entity_id\": \"34b1094b-28d4-1fb0-b8f6-73ad28d80332\"  } } The line we care about is client_token in the auth section. The value is used to authenticate subsequent requests to Vault.\nFor instance, in the C# app we used the CubbyHole backend to store a Name. The equivalent curl commands would be:\nexport VAULT_TOKEN=\"c14f5806-aff2-61b6-42c2-8920c8049b6c\"  # vault write cubbyhole/test/path name=\"Another manual secret\" curl -X POST \\  --header \"X-Vault-Token: $VAULT_TOKEN\" \\  --data '{ \"Name\": \"Another manual secret\" }' \\  http://localhost:8200/v1/cubbyhole/test/path  # vault list cubbyhole/test/path curl -X GET \\  --header \"X-Vault-Token: $VAULT_TOKEN\" \\  http://localhost:8200/v1/cubbyhole/test/path So why use the client library if it’s just HTTP calls? Simple - by using VaultSharp (or equivalent) we get token auto renewal handled for us, along with working APIs; no more guessing and head-scratching while trying to work out the proper HTTP call to make!\nWhat Next? Read up on what you can do with Roles - such as limiting token and secret lifetimes, usage counts, etc.\nNext article will probably cover Vault’s Policies.\n","wordCount":"970","inLanguage":"en","datePublished":"2018-06-22T00:00:00Z","dateModified":"2018-06-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/06/22/vault-secure-communication/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Secure Communication with Vault</h1><div class=post-meta><span title="2018-06-22 00:00:00 +0000 UTC">June 22, 2018</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><p>I think <a href=https://vaultproject.io>Vault by Hashicorp</a> is a great product - I particularly love how you can do dynamic secret generation (e.g <a href=/2018/06/17/secret-management-vault-postgres-connection>for database connections</a>). But how do you validate that the application requesting the secret is allowed to perform that action? How do you know it&rsquo;s not someone or something impersonating your application?</p><p>While musing this at an airport the other day, my colleague <a href=https://twitter.com/PatrikHerrgard>Patrik</a> sent me a link to a StackOverflow post <a href=https://stackoverflow.com/questions/46583873/hashicorp-vault-client-best-practise>about this very question</a></p><p>The summary is this:</p><ol><li>Use an AppRole rather than a plain token</li><li>Bake the RoleID into your application</li><li>Provide a SecretID from the environment</li><li>Combine both to get a token from Vault on startup</li><li>Periodically renew said token.</li></ol><p>Or, in picture form:</p><p><img loading=lazy src=/images/vault-flow.png alt="vault token flow"></p><p>So let&rsquo;s see how we can go about doing this.</p><h2 id=0-setup-vault>0. Setup Vault<a hidden class=anchor aria-hidden=true href=#0-setup-vault>#</a></h2><p>This time we will use Vault in dev mode, which means that it starts unsealed, and we can specify the root token as something simple. On the downside, there is no persistence; restarting the container gives you a blank slate. If you would prefer to use Vault with persistent storage, see <a href=/2018/06/17/secret-management-vault-postgres-connection>Section 2 of the previous post</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -d --rm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name vault_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cap-add<span style=color:#f92672>=</span>IPC_LOCK <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -e VAULT_DEV_ROOT_TOKEN_ID<span style=color:#f92672>=</span>vault <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -p 8200:8200 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    vault
</span></span></code></pre></div><p>As in the previous article, we&rsquo;ll export the <code>VAULT_TOKEN</code> and <code>VAULT_ADDR</code> variables so we can use the Vault CLI:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_ADDR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>
</span></span><span style=display:flex><span>export VAULT_TOKEN<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vault&#34;</span>
</span></span></code></pre></div><p>For our last setup step, we need to enable the <code>AppRole</code> auth method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault auth enable approle
</span></span></code></pre></div><h2 id=1-create-a-role>1. Create A Role<a hidden class=anchor aria-hidden=true href=#1-create-a-role>#</a></h2><p>Creating a role has <a href=https://www.vaultproject.io/api/auth/approle/index.html#create-new-approle>many parameters</a> you can specify, but for our <code>demo_app</code> role, we are going to skip most of them, just providing <code>token_ttl</code> and <code>token_max_ttl</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write auth/approle/role/demo_app <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    token_ttl<span style=color:#f92672>=</span>20m <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    token_max_ttl<span style=color:#f92672>=</span>1h
</span></span></code></pre></div><h2 id=2-request-a-secret-id>2. Request A Secret ID<a hidden class=anchor aria-hidden=true href=#2-request-a-secret-id>#</a></h2><p>Vault has two modes of working, called Push and Pull. Push mode is when you generate the <code>secret_id</code> yourself and store it against the role. Pull mode is when you request Vault to generate the <code>secret_id</code> against the role and return it to you. I favour the Pull model, as it is one less thing to worry about (how to generate a secure <code>secret_id</code>.)</p><p>We have to specify the <code>-force</code> (shorthand <code>-f</code>) as we are writing a secret which has no key-value pairs, and as we are using the CLI, I have specified <code>-field=secret_id</code> which changes the command to only output the <code>secret_id</code>&rsquo;s value, rather than the whole object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export SECRET_ID<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>vault write -f -field<span style=color:#f92672>=</span>secret_id auth/approle/role/demo_app/secret-id<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo $SECRET_ID
</span></span><span style=display:flex><span><span style=color:#75715e>#&gt; 119439b3-4eec-5e5b-ce85-c1d00f046234</span>
</span></span></code></pre></div><h2 id=3-write-secret-id-to-environment>3. Write Secret ID to Environment<a hidden class=anchor aria-hidden=true href=#3-write-secret-id-to-environment>#</a></h2><p>This step would be done by another process, such as <a href=https://www.terraform.io/>Terraform</a> when provisioning your environment, or <a href=https://www.spinnaker.io/>Spinnaker</a> when deploying your containers.</p><p>As we are just using the CLI, we can pretend that <code>$SECRET_ID</code> represents the value stored in the environment.</p><h2 id=4-fetch-role-id>4. Fetch Role ID<a hidden class=anchor aria-hidden=true href=#4-fetch-role-id>#</a></h2><p>Next, assuming the role of the developer writing an app, we need fetch the <code>role_id</code>, for our <code>demo_app</code> role. As with fetching the <code>secret_id</code>, we specify the <code>-field=role_id</code> so we only get that part of the response printed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault read -field<span style=color:#f92672>=</span>role_id auth/approle/role/demo_app/role-id
</span></span><span style=display:flex><span><span style=color:#75715e>#&gt; 723d66af-3ddd-91c0-7b35-1ee51a30c5b8</span>
</span></span></code></pre></div><h2 id=5-embed-role-id-in-code>5. Embed Role ID in Code<a hidden class=anchor aria-hidden=true href=#5-embed-role-id-in-code>#</a></h2><p>We&rsquo;re on the CLI, and have saved the <code>role_id</code> into the <code>$ROLE_ID</code> variable, so nothing more to do here!</p><p>Let&rsquo;s create a simple C# Console app to demo this with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dotnet new console --name VaultDemo
</span></span><span style=display:flex><span>dotnet new sln --name VaultDemo
</span></span><span style=display:flex><span>dotnet sln add VaultDemo/VaultDemo.csproj
</span></span><span style=display:flex><span>dotnet add VaultDemo/VaultDemo.csproj package VaultSharp
</span></span></code></pre></div><p>We also installed the <code>VaultSharp</code> NuGet package, which takes care of doing the client token fetching for you - but we will go through what this is doing internally later!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>string</span> RoleID = <span style=color:#e6db74>&#34;723d66af-3ddd-91c0-7b35-1ee51a30c5b8&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> Task Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> auth = <span style=color:#66d9ef>new</span> AppRoleAuthenticationInfo(
</span></span><span style=display:flex><span>      RoleID,
</span></span><span style=display:flex><span>      Environment.GetEnvironmentVariable(<span style=color:#e6db74>&#34;SECRET_ID&#34;</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> client = VaultClientFactory.CreateVaultClient(
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> Uri(<span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>),
</span></span><span style=display:flex><span>      auth
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> client.CubbyholeWriteSecretAsync(<span style=color:#e6db74>&#34;test/path&#34;</span>, <span style=color:#66d9ef>new</span> Dictionary&lt;<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>object</span>&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      { <span style=color:#e6db74>&#34;Name&#34;</span>, <span style=color:#e6db74>&#34;I&#39;m a secret Name!&#34;</span> }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> secrets = <span style=color:#66d9ef>await</span> client.CubbyholeReadSecretAsync(<span style=color:#e6db74>&#34;test/path&#34;</span>);
</span></span><span style=display:flex><span>    Console.WriteLine(secrets.Data[<span style=color:#e6db74>&#34;Name&#34;</span>]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=6-deploy>6. Deploy!<a hidden class=anchor aria-hidden=true href=#6-deploy>#</a></h2><p>As we&rsquo;re running locally, nothing to do here, but if you want, imagine that you created a docker container or baked an AMI and deployed it to the cloud or something!</p><h2 id=7-run--on-start>7. Run / On Start<a hidden class=anchor aria-hidden=true href=#7-run--on-start>#</a></h2><p>As we&rsquo;ve already saved the <code>SECRET_ID</code> into an environment variable, we can just run the application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dotnet run --project VaultDemo/VaultDemo.csproj
</span></span><span style=display:flex><span><span style=color:#75715e>#&gt; I&#39;m a secret Name!</span>
</span></span></code></pre></div><h2 id=so-what-did-the-application-do>So what did the application do?<a hidden class=anchor aria-hidden=true href=#so-what-did-the-application-do>#</a></h2><p>When run, the application used both the <code>role_id</code> from the constant and the <code>secret_id</code> environment variable to call Vault&rsquo;s <a href=https://www.vaultproject.io/api/auth/approle/index.html#login-with-approle>Login</a> method. An equivalent <code>curl</code> command would be this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -X POST <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --data <span style=color:#e6db74>&#39;{ &#34;role_id&#34;:&#34;723d66af-3ddd-91c0-7b35-1ee51a30c5b8&#34;, &#34;secret_id&#34;:&#34;119439b3-4eec-5e5b-ce85-c1d00f046234&#34; }&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    http://localhost:8200/v1/auth/approle/login
</span></span></code></pre></div><p>This will spit out a single line of json, but if you have <a href=https://stedolan.github.io/jq/>jq</a> in your path, you can prettify the output by appending <code>| jq .</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;request_id&#34;</span>: <span style=color:#e6db74>&#34;37c0e057-6fab-1873-3ec0-affaace26e76&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;lease_id&#34;</span>: <span style=color:#e6db74>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;renewable&#34;</span>: <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;lease_duration&#34;</span>: <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;data&#34;</span>: <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;wrap_info&#34;</span>: <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;warnings&#34;</span>: <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;auth&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;client_token&#34;</span>: <span style=color:#e6db74>&#34;c14f5806-aff2-61b6-42c2-8920c8049b6c&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;accessor&#34;</span>: <span style=color:#e6db74>&#34;aef3d4f4-d279-bcda-8d9c-2a3de6344975&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;policies&#34;</span>: [
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#34;default&#34;</span>
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:#f92672>&#34;role_name&#34;</span>: <span style=color:#e6db74>&#34;demo_app&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;lease_duration&#34;</span>: <span style=color:#ae81ff>1200</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;renewable&#34;</span>: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;entity_id&#34;</span>: <span style=color:#e6db74>&#34;34b1094b-28d4-1fb0-b8f6-73ad28d80332&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The line we care about is <code>client_token</code> in the <code>auth</code> section. The value is used to authenticate subsequent requests to Vault.</p><p>For instance, in the C# app we used the <a href=https://www.vaultproject.io/api/secret/cubbyhole/index.html>CubbyHole</a> backend to store a <code>Name</code>. The equivalent curl commands would be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_TOKEN<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;c14f5806-aff2-61b6-42c2-8920c8049b6c&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># vault write cubbyhole/test/path name=&#34;Another manual secret&#34;</span>
</span></span><span style=display:flex><span>curl -X POST <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --header <span style=color:#e6db74>&#34;X-Vault-Token: </span>$VAULT_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --data <span style=color:#e6db74>&#39;{ &#34;Name&#34;: &#34;Another manual secret&#34; }&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    http://localhost:8200/v1/cubbyhole/test/path
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># vault list cubbyhole/test/path</span>
</span></span><span style=display:flex><span>curl -X GET <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --header <span style=color:#e6db74>&#34;X-Vault-Token: </span>$VAULT_TOKEN<span style=color:#e6db74>&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    http://localhost:8200/v1/cubbyhole/test/path
</span></span></code></pre></div><p>So why use the client library if it&rsquo;s just HTTP calls? Simple - by using <code>VaultSharp</code> (or equivalent) we get token auto renewal handled for us, along with working APIs; no more guessing and head-scratching while trying to work out the proper HTTP call to make!</p><h2 id=what-next>What Next?<a hidden class=anchor aria-hidden=true href=#what-next>#</a></h2><p>Read up on what you can do with Roles - such as limiting token and secret lifetimes, usage counts, etc.</p><p>Next article will probably cover Vault&rsquo;s <a href=https://www.vaultproject.io/docs/concepts/policies.html>Policies</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/vault/>vault</a></li><li><a href=https://andydote.co.uk/tags/security/>security</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/06/23/vault-locking-it-down-with-policies/><span class=title>« Prev Page</span><br><span>Locking Vault Down with Policies</span></a>
<a class=next href=https://andydote.co.uk/2018/06/18/git-bash-docker-volume-paths/><span class=title>Next Page »</span><br><span>Fixing Docker volume paths on Git Bash on Windows</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>