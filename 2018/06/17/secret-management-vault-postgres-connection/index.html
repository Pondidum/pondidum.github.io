<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Managing Postgres Connection Strings with Vault | Andy Dote</title><meta name=keywords content="vault,security,microservices,postgres"><meta name=description content="One of the points I made in my recent NDC talk on 12 Factor microservices, was that you shouldn&rsquo;t be storing sensitive data, such as API keys, usernames, passwords etc. in the environment variables.
Don&rsquo;t Store Sensitive Data in the Environment
My reasoning is that when you were accessing Environment Variables in Heroku&rsquo;s platform, you were actually accessing some (probably) secure key-value store, rather than actual environment variables.
While you can use something like Consul&rsquo;s key-value store for this, it&rsquo;s not much better as it still stores all the values in plaintext, and has no auditing or logging."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/06/17/secret-management-vault-postgres-connection/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2b33c247bf6959372dd097f2cfdcd9f4d5019027cd9b1e28ae3d14c17c37ac00.css integrity="sha256-KzPCR79pWTct0Jfyz9zZ9NUBkCfNmx4orj0UwXw3rAA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Managing Postgres Connection Strings with Vault"><meta property="og:description" content="One of the points I made in my recent NDC talk on 12 Factor microservices, was that you shouldn&rsquo;t be storing sensitive data, such as API keys, usernames, passwords etc. in the environment variables.
Don&rsquo;t Store Sensitive Data in the Environment
My reasoning is that when you were accessing Environment Variables in Heroku&rsquo;s platform, you were actually accessing some (probably) secure key-value store, rather than actual environment variables.
While you can use something like Consul&rsquo;s key-value store for this, it&rsquo;s not much better as it still stores all the values in plaintext, and has no auditing or logging."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/06/17/secret-management-vault-postgres-connection/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-06-17T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Managing Postgres Connection Strings with Vault"><meta name=twitter:description content="One of the points I made in my recent NDC talk on 12 Factor microservices, was that you shouldn&rsquo;t be storing sensitive data, such as API keys, usernames, passwords etc. in the environment variables.
Don&rsquo;t Store Sensitive Data in the Environment
My reasoning is that when you were accessing Environment Variables in Heroku&rsquo;s platform, you were actually accessing some (probably) secure key-value store, rather than actual environment variables.
While you can use something like Consul&rsquo;s key-value store for this, it&rsquo;s not much better as it still stores all the values in plaintext, and has no auditing or logging."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Managing Postgres Connection Strings with Vault","item":"https://andydote.co.uk/2018/06/17/secret-management-vault-postgres-connection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Managing Postgres Connection Strings with Vault","name":"Managing Postgres Connection Strings with Vault","description":"One of the points I made in my recent NDC talk on 12 Factor microservices, was that you shouldn\u0026rsquo;t be storing sensitive data, such as API keys, usernames, passwords etc. in the environment variables.\nDon\u0026rsquo;t Store Sensitive Data in the Environment\nMy reasoning is that when you were accessing Environment Variables in Heroku\u0026rsquo;s platform, you were actually accessing some (probably) secure key-value store, rather than actual environment variables.\nWhile you can use something like Consul\u0026rsquo;s key-value store for this, it\u0026rsquo;s not much better as it still stores all the values in plaintext, and has no auditing or logging.","keywords":["vault","security","microservices","postgres"],"articleBody":"One of the points I made in my recent NDC talk on 12 Factor microservices, was that you shouldn’t be storing sensitive data, such as API keys, usernames, passwords etc. in the environment variables.\nDon’t Store Sensitive Data in the Environment\nMy reasoning is that when you were accessing Environment Variables in Heroku’s platform, you were actually accessing some (probably) secure key-value store, rather than actual environment variables.\nWhile you can use something like Consul’s key-value store for this, it’s not much better as it still stores all the values in plaintext, and has no auditing or logging.\nEnter Vault Vault is a secure secret management application, which not only can store static values, but also generate credentials on the fly, and automatically expire them after usage or after a time period. We’re going to look at setting up Vault to generate Postgres connection strings.\nWhat you’ll need Docker, as we’ll be running both Vault and Postgres in containers A SQL client (for a GUI, I recommend DBeaver, for CLI PSQL included in the Postgres download is fine.) The Vault executable What we’ll do Setup Postgres and create a SQL user for Vault to use Setup Vault Setup Vault’s database functionality Fetch and renew credentials from Vault. 1. Setup a Postgres container When running on my local machine, I like to use the Alpine variant of the official Postgres container, as it’s pretty small, and does everything I’ve needed so far.\nWe’ll run a copy of the image, configure it to listen on the default port, and use the super secure password of postgres:\ndocker run \\ -d \\ --name postgres_demo \\ -p 5432:5432 \\ -e 'POSTGRES_PASSWORD=postgres' \\ postgres:alpine Next up, we need to create a user for Vault to use when generating credentials. You can execute this SQL in any SQL editor which can connect to postgres, or use the PSQL command line interface:\npsql --username postgres --dbname postgres # it will prompt for password psql\u003e create role VaultAdmin with Login password 'vault' CreateRole; psql\u003e grant connect on database postgres to vaultadmin; You can verify this has worked by running another instance of psql as the new user:\npsql --username VaultAdmin --dbname postgres # it will prompt for password 2. Setting up the Vault container The official Vault container image will by default run in dev mode, which means it will startup unsealed, and will use whatever token you specify for authentication. However, it won’t persist any information across container restarts, which is a bit irritating, so instead, we will run it in server mode, and configure file storage to give us (semi) persistent storage.\nThe configuration, when written out and appropriately formatted, looks as follows:\nbackend \"file\" { path = \"/vault/file\" } listener \"tcp\" { address = \"0.0.0.0:8200\" tls_disable = 1 } ui = true We are binding the listener to all interfaces on the container, disabling SSL (don’t do this in production environments!) and enabling the UI. To pass this through to the container, we can set the VAULT_LOCAL_CONFIG environment variable:\ndocker run \\ -d \\ --name vault_demo \\ --cap-add=IPC_LOCK \\ -p 8200:8200 \\ -e 'VAULT_LOCAL_CONFIG=backend \"file\" { path = \"/vault/file\" } listener \"tcp\" { address = \"0.0.0.0:8200\" tls_disable = 1 } ui = true' \\ vault server When we use the Vault CLI to interact with a Vault server, it want’s to use TLS, but as we are running without TLS, we need to override this default. Luckily it’s just a case of setting the VAULT_ADDR environment variable:\nexport VAULT_ADDR=\"http://localhost:8200\" You can run vault status to check you can communicate with the container successfully.\nBefore we can start configuring secret engines in Vault, it needs initialising. By default, the init command will generate five key shares, of which you will need any three to unseal Vault. The reason for Key Shares is so that you can distribute the keys to different people so that no one person has access to unseal Vault on their own. While this is great for production, for experimenting locally, one key is enough.\nvault operator init -key-shares=1 -key-threshold=1 The output will amongst other things give you two lines, one with the Unseal Key, and one with the Initial Root Token:\nUnseal Key 1: sk+C4xJihsMaa+DCBHHgoGVozz+dMC4Kd/ijX8oMcrQ= Initial Root Token: addaaeed-d387-5eab-128d-60d6e92b0757\nWe’ll need the Unseal key to unseal Vault so we can configure it and generate secrets, and the Root Token so we can authenticate with Vault itself.\nvault operator unseal \"sk+C4xJihsMaa+DCBHHgoGVozz+dMC4Kd/ijX8oMcrQ=\" To make life a bit easier, we can also set an environment variable with our token so that we don’t have to specify it on all the subsequent requests:\nexport VAULT_TOKEN=\"addaaeed-d387-5eab-128d-60d6e92b0757\" 3. Configure Vault’s Database Secret Engine First off we need to enable the database secret engine. This engine supports many different databases, such as Postgres, MSSQL, Mysql, MongoDB and Cassandra amongst others.\nvault secrets enable database Next, we need to configure how vault will connect to the database. You will need to substitute the IPAddress in the connection string for your docker host IP (in my case, the network is called DockerNAT, and my machine’s IP is 10.0.75.1, yours will probably be different.)\nvault write database/config/postgres_demo \\ plugin_name=postgresql-database-plugin \\ allowed_roles=\"*\" \\ connection_url=\"postgresql://{{username}}:{{password}}@10.0.75.1:5432/postgres?sslmode=disable\" \\ username=\"VaultAdmin\" \\ password=\"vault\" To explain more of the command: We can limit what roles can be granted by this database backend by specifying a CSV of roles (which we will define next). In our case, however, we are using the allow anything wildcard (*).\nNext, we need to define a role which our applications can request. In this case, I am creating a role which only allows reading of data, so it’s named reader. We also specify the default_ttl which controls how long the user is valid for, and the max_ttl which specifies for how long we can renew a user’s lease.\nvault write database/roles/reader \\ db_name=postgres_demo \\ creation_statements=\"CREATE ROLE \\\"{{name}}\\\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \\ GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{name}}\\\";\" \\ default_ttl=\"10m\" \\ max_ttl=\"1h\" vault read database/creds/reader \u003e Key Value \u003e --- ----- \u003e lease_id database/creds/reader/15cf95eb-a2eb-c5ba-5111-8c0c48ae30a6 \u003e lease_duration 10m \u003e lease_renewable true \u003e password A1a-3gkMQpmoh3gbj2aM \u003e username v-root-reader-tgl6FSXHZaC5LZOK4q0u-1529138525 We can now use the username and password to connect to postgres, but only for 10 minutes, after which, the user will be deleted (Note, Vault sets the expiry of the user in Postgres, but will also remove the user when it expires.)\nVerify the user can connect using PSQL again:\npsql --username v-root-reader-tgl6FSXHZaC5LZOK4q0u-1529138525 --dbname postgres If we want to keep using our credentials, we can run the renew command passing in the lease_id, which will increase the current lease timeout by the value of default_ttl. You can provide the -increment value to request a different duration extension in seconds, but you cannot go further than the max_ttl.\nvault lease renew database/creds/reader/15cf95eb-a2eb-c5ba-5111-8c0c48ae30a6 # or vault lease renew database/creds/reader/15cf95eb-a2eb-c5ba-5111-8c0c48ae30a6 -increment 360 Done! There are a lot more options and things you can do with Vault, but hopefully, this will give you an idea of how to start out.\n","wordCount":"1166","inLanguage":"en","datePublished":"2018-06-17T00:00:00Z","dateModified":"2018-06-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/06/17/secret-management-vault-postgres-connection/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Managing Postgres Connection Strings with Vault</h1><div class=post-meta><span title='2018-06-17 00:00:00 +0000 UTC'>June 17, 2018</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>One of the points I made in my recent NDC talk on 12 Factor microservices, was that you shouldn&rsquo;t be storing sensitive data, such as API keys, usernames, passwords etc. in the environment variables.</p><blockquote><p>Don&rsquo;t Store Sensitive Data in the Environment</p></blockquote><p>My reasoning is that when you were accessing Environment Variables in Heroku&rsquo;s platform, you were actually accessing some (probably) secure key-value store, rather than actual environment variables.</p><p>While you can use something like Consul&rsquo;s key-value store for this, it&rsquo;s not much better as it still stores all the values in plaintext, and has no auditing or logging.</p><h2 id=enter-vault>Enter Vault<a hidden class=anchor aria-hidden=true href=#enter-vault>#</a></h2><p>Vault is a secure secret management application, which not only can store static values, but also generate credentials on the fly, and automatically expire them after usage or after a time period. We&rsquo;re going to look at setting up Vault to generate Postgres connection strings.</p><h2 id=what-youll-need>What you&rsquo;ll need<a hidden class=anchor aria-hidden=true href=#what-youll-need>#</a></h2><ol><li>Docker, as we&rsquo;ll be running both Vault and Postgres in containers</li><li>A SQL client (for a GUI, I recommend <a href=https://dbeaver.io/>DBeaver</a>, for CLI <a href=https://www.postgresql.org/download/>PSQL</a> included in the Postgres download is fine.)</li><li>The <a href=https://www.vaultproject.io/downloads.html>Vault executable</a></li></ol><h2 id=what-well-do>What we&rsquo;ll do<a hidden class=anchor aria-hidden=true href=#what-well-do>#</a></h2><ol><li>Setup Postgres and create a SQL user for Vault to use</li><li>Setup Vault</li><li>Setup Vault&rsquo;s database functionality</li><li>Fetch and renew credentials from Vault.</li></ol><h2 id=1-setup-a-postgres-container>1. Setup a Postgres container<a hidden class=anchor aria-hidden=true href=#1-setup-a-postgres-container>#</a></h2><p>When running on my local machine, I like to use the Alpine variant of the <a href=https://hub.docker.com/_/postgres/>official Postgres</a> container, as it&rsquo;s pretty small, and does everything I&rsquo;ve needed so far.</p><p>We&rsquo;ll run a copy of the image, configure it to listen on the default port, and use the super secure password of <code>postgres</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --name postgres_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -p 5432:5432 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -e <span style=color:#e6db74>&#39;POSTGRES_PASSWORD=postgres&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  postgres:alpine
</span></span></code></pre></div><p>Next up, we need to create a user for Vault to use when generating credentials. You can execute this SQL in any SQL editor which can connect to postgres, or use the PSQL command line interface:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>psql --username postgres --dbname postgres   <span style=color:#75715e># it will prompt for password</span>
</span></span><span style=display:flex><span>psql&gt; create role VaultAdmin with Login password <span style=color:#e6db74>&#39;vault&#39;</span> CreateRole;
</span></span><span style=display:flex><span>psql&gt; grant connect on database postgres to vaultadmin;
</span></span></code></pre></div><p>You can verify this has worked by running another instance of psql as the new user:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>psql --username VaultAdmin --dbname postgres   <span style=color:#75715e># it will prompt for password</span>
</span></span></code></pre></div><h2 id=2-setting-up-the-vault-container>2. Setting up the Vault container<a hidden class=anchor aria-hidden=true href=#2-setting-up-the-vault-container>#</a></h2><p>The official Vault container image will by default run in <code>dev</code> mode, which means it will startup unsealed, and will use whatever token you specify for authentication. However, it won&rsquo;t persist any information across container restarts, which is a bit irritating, so instead, we will run it in server mode, and configure file storage to give us (semi) persistent storage.</p><p>The configuration, when written out and appropriately formatted, looks as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>backend <span style=color:#e6db74>&#34;file&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/vault/file&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>listener <span style=color:#e6db74>&#34;tcp&#34;</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    address <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0.0.0.0:8200&#34;</span>
</span></span><span style=display:flex><span>    tls_disable <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>ui <span style=color:#f92672>=</span> true
</span></span></code></pre></div><p>We are binding the listener to all interfaces on the container, disabling SSL (don&rsquo;t do this in production environments!) and enabling the UI. To pass this through to the container, we can set the <code>VAULT_LOCAL_CONFIG</code> environment variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -d <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --name vault_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    --cap-add<span style=color:#f92672>=</span>IPC_LOCK <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -p 8200:8200 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    -e <span style=color:#e6db74>&#39;VAULT_LOCAL_CONFIG=backend &#34;file&#34; { path = &#34;/vault/file&#34; } listener &#34;tcp&#34; { address = &#34;0.0.0.0:8200&#34; tls_disable = 1 } ui = true&#39;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    vault server
</span></span></code></pre></div><p>When we use the Vault CLI to interact with a Vault server, it want&rsquo;s to use TLS, but as we are running without TLS, we need to override this default. Luckily it&rsquo;s just a case of setting the <code>VAULT_ADDR</code> environment variable:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_ADDR<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;http://localhost:8200&#34;</span>
</span></span></code></pre></div><p>You can run <code>vault status</code> to check you can communicate with the container successfully.</p><p>Before we can start configuring secret engines in Vault, it needs initialising. By default, the <code>init</code> command will generate five key shares, of which you will need any three to unseal Vault. The reason for Key Shares is so that you can distribute the keys to different people so that no one person has access to unseal Vault on their own. While this is great for production, for experimenting locally, one key is enough.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault operator init -key-shares<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span> -key-threshold<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>The output will amongst other things give you two lines, one with the Unseal Key, and one with the Initial Root Token:</p><blockquote><p>Unseal Key 1: sk+C4xJihsMaa+DCBHHgoGVozz+dMC4Kd/ijX8oMcrQ=
Initial Root Token: addaaeed-d387-5eab-128d-60d6e92b0757</p></blockquote><p>We&rsquo;ll need the Unseal key to unseal Vault so we can configure it and generate secrets, and the Root Token so we can authenticate with Vault itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> vault operator unseal <span style=color:#e6db74>&#34;sk+C4xJihsMaa+DCBHHgoGVozz+dMC4Kd/ijX8oMcrQ=&#34;</span>
</span></span></code></pre></div><p>To make life a bit easier, we can also set an environment variable with our token so that we don&rsquo;t have to specify it on all the subsequent requests:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export VAULT_TOKEN<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;addaaeed-d387-5eab-128d-60d6e92b0757&#34;</span>
</span></span></code></pre></div><h2 id=3-configure-vaults-database-secret-engine>3. Configure Vault&rsquo;s Database Secret Engine<a hidden class=anchor aria-hidden=true href=#3-configure-vaults-database-secret-engine>#</a></h2><p>First off we need to enable the database secret engine. This engine supports many different databases, such as Postgres, MSSQL, Mysql, MongoDB and Cassandra amongst others.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault secrets enable database
</span></span></code></pre></div><p>Next, we need to configure how vault will connect to the database. You will need to substitute the IPAddress in the connection string for your docker host IP (in my case, the network is called <code>DockerNAT</code>, and my machine&rsquo;s IP is <code>10.0.75.1</code>, yours will probably be different.)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write database/config/postgres_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    plugin_name<span style=color:#f92672>=</span>postgresql-database-plugin <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    allowed_roles<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;*&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    connection_url<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;postgresql://{{username}}:{{password}}@10.0.75.1:5432/postgres?sslmode=disable&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    username<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;VaultAdmin&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    password<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;vault&#34;</span>
</span></span></code></pre></div><p>To explain more of the command: We can limit what roles can be granted by this database backend by specifying a CSV of roles (which we will define next). In our case, however, we are using the allow anything wildcard (<code>*</code>).</p><p>Next, we need to define a role which our applications can request. In this case, I am creating a role which only allows reading of data, so it&rsquo;s named <code>reader</code>. We also specify the <code>default_ttl</code> which controls how long the user is valid for, and the <code>max_ttl</code> which specifies for how long we can renew a user&rsquo;s lease.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write database/roles/reader <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    db_name<span style=color:#f92672>=</span>postgres_demo <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    creation_statements<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;CREATE ROLE \&#34;{{name}}\&#34; WITH LOGIN PASSWORD &#39;{{password}}&#39; VALID UNTIL &#39;{{expiration}}&#39;; \
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        GRANT SELECT ON ALL TABLES IN SCHEMA public TO \&#34;{{name}}\&#34;;&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    default_ttl<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;10m&#34;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    max_ttl<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;1h&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault read database/creds/reader
</span></span><span style=display:flex><span>&gt; Key                Value
</span></span><span style=display:flex><span>&gt; ---                -----
</span></span><span style=display:flex><span>&gt; lease_id           database/creds/reader/15cf95eb-a2eb-c5ba-5111-8c0c48ae30a6
</span></span><span style=display:flex><span>&gt; lease_duration     10m
</span></span><span style=display:flex><span>&gt; lease_renewable    true
</span></span><span style=display:flex><span>&gt; password           A1a-3gkMQpmoh3gbj2aM
</span></span><span style=display:flex><span>&gt; username           v-root-reader-tgl6FSXHZaC5LZOK4q0u-1529138525
</span></span></code></pre></div><p>We can now use the username and password to connect to postgres, but only for 10 minutes, after which, the user will be deleted (Note, Vault sets the expiry of the user in Postgres, but will also remove the user when it expires.)</p><p>Verify the user can connect using PSQL again:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>psql --username v-root-reader-tgl6FSXHZaC5LZOK4q0u-1529138525 --dbname postgres
</span></span></code></pre></div><p>If we want to keep using our credentials, we can run the renew command passing in the <code>lease_id</code>, which will increase the current lease timeout by the value of <code>default_ttl</code>. You can provide the <code>-increment</code> value to request a different duration extension in seconds, but you cannot go further than the <code>max_ttl</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault lease renew database/creds/reader/15cf95eb-a2eb-c5ba-5111-8c0c48ae30a6
</span></span><span style=display:flex><span><span style=color:#75715e># or</span>
</span></span><span style=display:flex><span>vault lease renew database/creds/reader/15cf95eb-a2eb-c5ba-5111-8c0c48ae30a6 -increment <span style=color:#ae81ff>360</span>
</span></span></code></pre></div><h2 id=done>Done!<a hidden class=anchor aria-hidden=true href=#done>#</a></h2><p>There are a lot more options and things you can do with Vault, but hopefully, this will give you an idea of how to start out.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/vault/>vault</a></li><li><a href=https://andydote.co.uk/tags/security/>security</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li><li><a href=https://andydote.co.uk/tags/postgres/>postgres</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/06/18/git-bash-docker-volume-paths/><span class=title>« Prev Page</span><br><span>Fixing Docker volume paths on Git Bash on Windows</span></a>
<a class=next href=https://andydote.co.uk/2018/05/15/writing-conference-talks/><span class=title>Next Page »</span><br><span>Writing Conference Talks</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>