<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Semantic Configuration Validation: Earlier | Andy Dote</title>
<meta name=keywords content="configuration,c#,strongtyping,stronk,validation"><meta name=description content="After my previous post on Validating Your Configuration, one of my colleagues made an interesting point, paraphrasing:
I want to know if the configuration is valid earlier than that. At build time preferably. I don&rsquo;t want my service to not start if part of it is invalid.
There are two points here, namely when to validate, and what to do with the results of validation.
Handling Validation Results If your configuration is invalid, you&rsquo;d think the service should fail to start, as it might be configured in a dangerous manner."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/09/08/semantic-configuration-validation-earlier/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Semantic Configuration Validation: Earlier"><meta property="og:description" content="After my previous post on Validating Your Configuration, one of my colleagues made an interesting point, paraphrasing:
I want to know if the configuration is valid earlier than that. At build time preferably. I don&rsquo;t want my service to not start if part of it is invalid.
There are two points here, namely when to validate, and what to do with the results of validation.
Handling Validation Results If your configuration is invalid, you&rsquo;d think the service should fail to start, as it might be configured in a dangerous manner."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/09/08/semantic-configuration-validation-earlier/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-09-08T00:00:00+00:00"><meta property="article:modified_time" content="2018-09-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Semantic Configuration Validation: Earlier"><meta name=twitter:description content="After my previous post on Validating Your Configuration, one of my colleagues made an interesting point, paraphrasing:
I want to know if the configuration is valid earlier than that. At build time preferably. I don&rsquo;t want my service to not start if part of it is invalid.
There are two points here, namely when to validate, and what to do with the results of validation.
Handling Validation Results If your configuration is invalid, you&rsquo;d think the service should fail to start, as it might be configured in a dangerous manner."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Semantic Configuration Validation: Earlier","item":"https://andydote.co.uk/2018/09/08/semantic-configuration-validation-earlier/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Semantic Configuration Validation: Earlier","name":"Semantic Configuration Validation: Earlier","description":"After my previous post on Validating Your Configuration, one of my colleagues made an interesting point, paraphrasing:\nI want to know if the configuration is valid earlier than that. At build time preferably. I don\u0026rsquo;t want my service to not start if part of it is invalid.\nThere are two points here, namely when to validate, and what to do with the results of validation.\nHandling Validation Results If your configuration is invalid, you\u0026rsquo;d think the service should fail to start, as it might be configured in a dangerous manner.","keywords":["configuration","c#","strongtyping","stronk","validation"],"articleBody":"After my previous post on Validating Your Configuration, one of my colleagues made an interesting point, paraphrasing:\nI want to know if the configuration is valid earlier than that. At build time preferably. I don’t want my service to not start if part of it is invalid.\nThere are two points here, namely when to validate, and what to do with the results of validation.\nHandling Validation Results If your configuration is invalid, you’d think the service should fail to start, as it might be configured in a dangerous manner. While this makes sense for some service, others might need to work differently.\nSay you have an API which supports both writing and reading of a certain type of resource. The read will return you a resource of some form, and the write side will trigger processing of a resource (and return you a 202 Accepted, obviously).\nWhat happens if your configuration just affects the write side of the API? Should you prevent people from reading too? Probably not, but again it depends on your domain as to what makes sense.\nValidating at Build Time This is the far more interesting point (to me). How can we modify our build to validate that the environment’s configuration is valid? We have the code to do the validation: we have automated tests, and we have a configuration validator class (in this example, implemented using FluentValidation).\nDepending on where your master configuration is stored, the next step can get much harder.\nLocal Configuration If your configuration is in the current repository (as it should be) then it will be no problem to read.\npublic class ConfigurationTests { public static IEnumerable\u003cobject[]\u003e AvailableEnvironments =\u003e Enum .GetValues(typeof(Environments)) .Cast() .Select(e =\u003e new object[] { e }); [Theory] [MemberData(nameof(AvailableEnvironments))] public void Environment_specific_configuration_is_valid(Environments environment) { var config = new ConfigurationBuilder() .AddJsonFile(\"config.json\") .AddJsonFile($\"config.{environment}.json\", optional: true) .Build() .Get(); var validator = new AppConfigurationValidator(); validator.ValidateAndThrow(config); } } Given the following two configuration files, we can make it pass and fail:\nconfig.json:\n{ \"Callback\": \"https://localhost\", \"Timeout\": \"00:00:30\", \"MaxRetries\": 100 } config.local.json:\n{ \"MaxRetries\": 0 } Remote Configuration But what if your configuration is not in the local repository, or at least, not completely there? For example, have a lot of configuration in Octopus Deploy, and would like to validate that at build time too.\nLuckily Octopus has a Rest API (and acompanying client) which you can use to query the values. All we need to do is replace the AddJsonFile calls with an AddInMemoryCollection() and populate a dictionary from somewhere:\n[Theory] [MemberData(nameof(AvailableEnvironments))] public async Task Octopus_environment_configuration_is_valid(Environments environment) { var variables = await FetchVariablesFromOctopus( \"MyDeploymentProjectName\", environment); var config = new ConfigurationBuilder() .AddInMemoryCollection(variables) .Build() .Get(); var validator = new AppConfigurationValidator(); validator.ValidateAndThrow(config); } Reading the variables from Octopus’ API requires a bit of work as you don’t appear to be able to ask for all variables which would apply if you deployed to a specific environment, which forces you into building the logic yourself. However, if you are just using Environment scoping, it shouldn’t be too hard.\nTime Delays Verifying the configuration at build time when your state is fetched from a remote store is not going to solve all your problems, as this little diagram illustrates:\nYou need to validate in both places: early on in your process, and on startup. How you handle the configuration being invalid doesn’t have to be the same in both places:\nIn the build/test phase, fail the build On startup, raise an alarm, but start if reasonable Again, how you handle the configuration errors when your application is starting is down to your domain, and what your application does.\n","wordCount":"600","inLanguage":"en","datePublished":"2018-09-08T00:00:00Z","dateModified":"2018-09-08T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/09/08/semantic-configuration-validation-earlier/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Semantic Configuration Validation: Earlier</h1><div class=post-meta>&lt;span title='2018-09-08 00:00:00 +0000 UTC'>September 8, 2018&lt;/span>&amp;nbsp;·&amp;nbsp;3 min</div></header><div class=post-content><p>After my previous post on <a href=/2018/08/26/validate-configuration/>Validating Your Configuration</a>, one of my colleagues made an interesting point, paraphrasing:</p><blockquote><p>I want to know if the configuration is valid earlier than that. At build time preferably. I don&rsquo;t want my service to not start if part of it is invalid.</p></blockquote><p>There are two points here, namely when to validate, and what to do with the results of validation.</p><h2 id=handling-validation-results>Handling Validation Results<a hidden class=anchor aria-hidden=true href=#handling-validation-results>#</a></h2><p>If your configuration is invalid, you&rsquo;d think the service should fail to start, as it might be configured in a dangerous manner. While this makes sense for some service, others might need to work differently.</p><p>Say you have an API which supports both writing and reading of a certain type of resource. The read will return you a resource of some form, and the write side will trigger processing of a resource (and return you <a href=https://httpstatuses.com/202>a 202 Accepted, obviously</a>).</p><p>What happens if your configuration just affects the write side of the API? Should you prevent people from reading too? Probably not, but again it depends on your domain as to what makes sense.</p><h2 id=validating-at-build-time>Validating at Build Time<a hidden class=anchor aria-hidden=true href=#validating-at-build-time>#</a></h2><p>This is the far more interesting point (to me). How can we modify our build to validate that the environment&rsquo;s configuration is valid? We have the code to do the validation: we have automated tests, and we have a configuration validator class (in this example, implemented using <a href=https://github.com/JeremySkinner/FluentValidation>FluentValidation</a>).</p><p>Depending on where your master configuration is stored, the next step can get much harder.</p><h3 id=local-configuration>Local Configuration<a hidden class=anchor aria-hidden=true href=#local-configuration>#</a></h3><p>If your configuration is in the current repository (<a href=/2018/08/07/managing-consul-appsettings/>as it should be</a>) then it will be no problem to read.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ConfigurationTests</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> IEnumerable&lt;<span style=color:#66d9ef>object</span>[]&gt; AvailableEnvironments =&gt; Enum
</span></span><span style=display:flex><span>        .GetValues(<span style=color:#66d9ef>typeof</span>(Environments))
</span></span><span style=display:flex><span>        .Cast&lt;Environments&gt;()
</span></span><span style=display:flex><span>        .Select(e =&gt; <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>object</span>[] { e });
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [Theory]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [MemberData(nameof(AvailableEnvironments))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Environment_specific_configuration_is_valid(Environments environment)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> config = <span style=color:#66d9ef>new</span> ConfigurationBuilder()
</span></span><span style=display:flex><span>            .AddJsonFile(<span style=color:#e6db74>&#34;config.json&#34;</span>)
</span></span><span style=display:flex><span>            .AddJsonFile(<span style=color:#e6db74>$&#34;config.{environment}.json&#34;</span>, optional: <span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>            .Build()
</span></span><span style=display:flex><span>            .Get&lt;AppConfiguration&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> validator = <span style=color:#66d9ef>new</span> AppConfigurationValidator();
</span></span><span style=display:flex><span>        validator.ValidateAndThrow(config);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Given the following two configuration files, we can make it pass and fail:</p><p><code>config.json:</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;Callback&#34;</span>: <span style=color:#e6db74>&#34;https://localhost&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;Timeout&#34;</span>: <span style=color:#e6db74>&#34;00:00:30&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;MaxRetries&#34;</span>: <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>config.local.json:</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;MaxRetries&#34;</span>: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=remote-configuration>Remote Configuration<a hidden class=anchor aria-hidden=true href=#remote-configuration>#</a></h3><p>But what if your configuration is not in the local repository, or at least, not completely there? For example, have a lot of configuration in Octopus Deploy, and would like to validate that at build time too.</p><p>Luckily Octopus has a Rest API (and <a href=https://www.nuget.org/packages/Octopus.Client/>acompanying client</a>) which you can use to query the values. All we need to do is replace the <code>AddJsonFile</code> calls with an <code>AddInMemoryCollection()</code> and populate a dictionary from somewhere:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Theory]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[MemberData(nameof(AvailableEnvironments))]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Octopus_environment_configuration_is_valid(Environments environment)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> variables = <span style=color:#66d9ef>await</span> FetchVariablesFromOctopus(
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;MyDeploymentProjectName&#34;</span>,
</span></span><span style=display:flex><span>        environment);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> config = <span style=color:#66d9ef>new</span> ConfigurationBuilder()
</span></span><span style=display:flex><span>        .AddInMemoryCollection(variables)
</span></span><span style=display:flex><span>        .Build()
</span></span><span style=display:flex><span>        .Get&lt;AppConfiguration&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> validator = <span style=color:#66d9ef>new</span> AppConfigurationValidator();
</span></span><span style=display:flex><span>    validator.ValidateAndThrow(config);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Reading the variables from Octopus&rsquo; API requires a bit of work as you don&rsquo;t appear to be able to ask for all variables which would apply if you deployed to a specific environment, which forces you into building the logic yourself. However, if you are just using Environment scoping, it shouldn&rsquo;t be too hard.</p><h3 id=time-delays>Time Delays<a hidden class=anchor aria-hidden=true href=#time-delays>#</a></h3><p>Verifying the configuration at build time when your state is fetched from a remote store is not going to solve all your problems, as this little diagram illustrates:</p><p><img loading=lazy src=versioning-time.png alt="test pass, a user changes value, deployment happens, startup fails"></p><p>You need to validate in both places: early on in your process, and on startup. How you handle the configuration being invalid doesn&rsquo;t have to be the same in both places:</p><ul><li>In the build/test phase, fail the build</li><li>On startup, raise an alarm, but start if reasonable</li></ul><p>Again, how you handle the configuration errors when your application is starting is down to your domain, and what your application does.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/configuration/>configuration</a></li><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/strongtyping/>strongtyping</a></li><li><a href=https://andydote.co.uk/tags/stronk/>stronk</a></li><li><a href=https://andydote.co.uk/tags/validation/>validation</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/09/10/sketchnotes-finding-service-boundaries/><span class=title>« Prev Page</span><br><span>SketchNotes: Finding Your Service Boundaries</span>
</a><a class=next href=https://andydote.co.uk/2018/09/06/consul-feature-toggles/><span class=title>Next Page »</span><br><span>Feature Toggles with Consul</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>