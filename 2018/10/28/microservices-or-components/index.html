<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Microservices or Components | Andy Dote</title><meta name=keywords content="architecture,microservices,design"><meta name=description content="One of the reasons people list for using MicroServices is that it helps enforce separation of concerns. This is usually achieved by adding a network boundary between the services. While this is useful, it&rsquo;s not without costs; namely that you&rsquo;ve added a set of new failure modes: the network. We can achieve the same separation of concerns within the same codebase if we put our minds to it. In fact, this is what Simon Brown calls a Modular Monolith, and DHH calls the Majestic Monolith."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2018/10/28/microservices-or-components/><link crossorigin=anonymous href=/assets/css/stylesheet.min.4ac25d88867f6882d86478d9b478a3d3efa1ed9e18f0bc5e432812301516cb28.css integrity="sha256-SsJdiIZ/aILYZHjZtHij0++h7Z4Y8LxeQygSMBUWyyg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Microservices or Components"><meta property="og:description" content="One of the reasons people list for using MicroServices is that it helps enforce separation of concerns. This is usually achieved by adding a network boundary between the services. While this is useful, it&rsquo;s not without costs; namely that you&rsquo;ve added a set of new failure modes: the network. We can achieve the same separation of concerns within the same codebase if we put our minds to it. In fact, this is what Simon Brown calls a Modular Monolith, and DHH calls the Majestic Monolith."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2018/10/28/microservices-or-components/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-10-28T00:00:00+00:00"><meta property="article:modified_time" content="2018-10-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Microservices or Components"><meta name=twitter:description content="One of the reasons people list for using MicroServices is that it helps enforce separation of concerns. This is usually achieved by adding a network boundary between the services. While this is useful, it&rsquo;s not without costs; namely that you&rsquo;ve added a set of new failure modes: the network. We can achieve the same separation of concerns within the same codebase if we put our minds to it. In fact, this is what Simon Brown calls a Modular Monolith, and DHH calls the Majestic Monolith."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Microservices or Components","item":"https://andydote.co.uk/2018/10/28/microservices-or-components/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Microservices or Components","name":"Microservices or Components","description":"One of the reasons people list for using MicroServices is that it helps enforce separation of concerns. This is usually achieved by adding a network boundary between the services. While this is useful, it\u0026rsquo;s not without costs; namely that you\u0026rsquo;ve added a set of new failure modes: the network. We can achieve the same separation of concerns within the same codebase if we put our minds to it. In fact, this is what Simon Brown calls a Modular Monolith, and DHH calls the Majestic Monolith.","keywords":["architecture","microservices","design"],"articleBody":"One of the reasons people list for using MicroServices is that it helps enforce separation of concerns. This is usually achieved by adding a network boundary between the services. While this is useful, it’s not without costs; namely that you’ve added a set of new failure modes: the network. We can achieve the same separation of concerns within the same codebase if we put our minds to it. In fact, this is what Simon Brown calls a Modular Monolith, and DHH calls the Majestic Monolith.\nWe recently needed to expand an existing service to have some new functionality. The current process looks something like this, where the user has done something which will eventually return them a URL which can be clicked to get to a web page to see the results.\nThe new process is an additional authentication challenge which the user will need to complete before they can get to the final results page. The new process looks like this:\nDesign Decisions Currently, the challenge functionality will only be used by this one service, but there is a high probability that we will need it for other services in the future too. At this point we have a decision to make: do we keep this functionality in-process, or make a separate microservice for it?\nTime To Live The first trade-off is time: it is slightly quicker to make it in-process, but if we do want to use this from somewhere else later, we’ll need to extract it; which is more work. The key here is “if” - we don’t know for sure that other services will need this exact functionality.\nIf we keep the new API and UI within the existing API and UI projects, we can also make some code reuse: there is a data store, data access tooling, permissions, styles that can be reused. Also, all of our infrastructure such as logging and monitoring is already in place, which will save us some time too.\nAPI Risk We want to avoid deploying a service which then needs to undergo a lot of rework in the future if the second and third users of it have slightly different requirements. If we build it as a separate service now, will we be sure we are making something which is generic and reusable by other services? Typically you only get the answer to this question after the second or third usage, so it seems unlikely that we would get our API design perfect on the first attempt.\nTechnical Risks If we are to go the separate service route, we are introducing new failure modes to the existing API. What if the challenge API is down? What if the request times out? Are we using HTTP or a Message Broker to communicate with it?\nIf we keep the service in-process to start with we can eliminate all of these concerns. Luckily, we tend to have very thin controllers and make use of Mediatr, so the actual implementation of how the remote call is made can be hidden in the message handler to a certain extent.\nTechnical Decisions As alluded to in the Time To Live point, we can reuse the existing data store and data access code, but this is a tradeoff in itself: what if the current storage tech is not quite ideal for the new requirements?\nIf the current service makes use of a complex Entity Framework model, but the new service is so simple that Dapper makes more sense, do we introduce the new dependency or not? What if we wanted to migrate away from one datastore to another (e.g. removing all MongoDB usage in favour of Postgres), but this is already using Mongo? We’d be increasing our dependency on a datastore we are explicitly trying to migrate away from.\nAll this assumes we want to write the service in the same programming language as the existing service! In our case we do but it’s worth considering if you have multiple languages in use already.\nFinally on the data storefront, if we decide to extract this as a separate service later, we will have to take into account data migrations, and how we can handle that with little if any, downtime.\nThe Decision After weighing up all these points (and a few others), we decided to keep the service inside the existing services. The Challenge API will live in its own area in the current API, and likewise, the Challenge UI will live in its own area in the existing UI.\nHow do we go about keeping it all separated though?\nCommunication we discuss all changes we want to make anyway, so the first line of defence to preventing the code becoming tightly coupled are these discussions. Pull Requests someone will notice you are doing something which is reducing the separation, and a discussion about how to avoid this will happen. Naming Conventions the Challenge API shares no naming of properties with the existing API. For example, the current API passes in a results_url and results_id, but the Challenge API stores and refers to these as the redirect_url and external_id. Readme it’ll go into the repository’s readme file, along with any other notes which developers will find useful. The sequence diagrams we drew (with much more detail) will also go in here. Technical Debt? The final question on this decision is “Isn’t this technical debt we are introducing?”. The answer I feel is “no”, it feels much closer to applying the YAGNI Principle (You Ain’t Gonna Need It). While there is work in the backlog which can use a Challenge API at the moment, that doesn’t necessarily mean it will still be there next week, or if it will be pushed further back or changed later.\nIn the end, the meeting where we came up with this and drew things on the whiteboard together was productive, and likely much shorter than it took me to write all this down. We were able to resist the “cool hip microservice” trend and come up with a design which is pretty contained and composable with other systems in the future.\nIf after all this discussion we decided to go the MicroService route, I would still be happy with the decision, as we would have all this material to look back on and justify our choice, rather than waving our hands about and shouting “but microservices” loudly.\nHow do you go about designing systems? Microservice all the things? Monolith all the things? Or something in between which makes the most sense for the situation at hand?\n","wordCount":"1095","inLanguage":"en","datePublished":"2018-10-28T00:00:00Z","dateModified":"2018-10-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2018/10/28/microservices-or-components/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Microservices or Components</h1><div class=post-meta><span title='2018-10-28 00:00:00 +0000 UTC'>October 28, 2018</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><p>One of the reasons people list for using MicroServices is that it helps enforce separation of concerns. This is usually achieved by adding a network boundary between the services. While this is useful, it&rsquo;s not without costs; namely that you&rsquo;ve added a set of new failure modes: the network. We can achieve the same separation of concerns within the same codebase if we put our minds to it. In fact, this is what <a href=https://www.simonbrown.je/>Simon Brown</a> calls a <a href=https://www.codingthearchitecture.com/presentations/sa2015-modular-monoliths>Modular Monolith</a>, and <a href=https://twitter.com/dhh>DHH</a> calls the <a href=https://m.signalvnoise.com/the-majestic-monolith-29166d022228>Majestic Monolith</a>.</p><p>We recently needed to expand an existing service to have some new functionality. The current process looks something like this, where the user has done something which will eventually return them a URL which can be clicked to get to a web page to see the results.</p><p><img loading=lazy src=/images/microservice-existing.png alt="api call does some work, returns a result_url which points to a web interface"></p><p>The new process is an additional authentication challenge which the user will need to complete before they can get to the final results page. The new process looks like this:</p><p><img loading=lazy src=/images/microservice-challenge.png alt="api call does work, makes a request to challenge API, passing the result_url as an argument.  The challenge-response returns a challenge_url, which is returned to the user instead of the return_url"></p><h2 id=design-decisions>Design Decisions<a hidden class=anchor aria-hidden=true href=#design-decisions>#</a></h2><p>Currently, the challenge functionality will only be used by this one service, but there is a high probability that we will need it for other services in the future too. At this point we have a decision to make: do we keep this functionality in-process, or make a separate microservice for it?</p><h3 id=time-to-live>Time To Live<a hidden class=anchor aria-hidden=true href=#time-to-live>#</a></h3><p>The first trade-off is time: it is slightly quicker to make it in-process, but if we do want to use this from somewhere else later, we&rsquo;ll need to extract it; which is more work. The key here is &ldquo;if&rdquo; - we don&rsquo;t know for sure that other services will need this exact functionality.</p><p>If we keep the new API and UI within the existing API and UI projects, we can also make some code reuse: there is a data store, data access tooling, permissions, styles that can be reused. Also, all of our infrastructure such as logging and monitoring is already in place, which will save us some time too.</p><h3 id=api-risk>API Risk<a hidden class=anchor aria-hidden=true href=#api-risk>#</a></h3><p>We want to avoid deploying a service which then needs to undergo a lot of rework in the future if the second and third users of it have slightly different requirements. If we build it as a separate service now, will we be sure we are making something which is generic and reusable by other services? Typically you only get the answer to this question after the second or third usage, so it seems unlikely that we would get our API design perfect on the first attempt.</p><h3 id=technical-risks>Technical Risks<a hidden class=anchor aria-hidden=true href=#technical-risks>#</a></h3><p>If we are to go the separate service route, we are introducing new failure modes to the existing API. What if the challenge API is down? What if the request times out? Are we using HTTP or a Message Broker to communicate with it?</p><p>If we keep the service in-process to start with we can eliminate all of these concerns. Luckily, we tend to have very thin controllers and make use of <a href=https://github.com/jbogard/MediatR>Mediatr</a>, so the actual implementation of how the remote call is made can be hidden in the message handler to a certain extent.</p><h3 id=technical-decisions>Technical Decisions<a hidden class=anchor aria-hidden=true href=#technical-decisions>#</a></h3><p>As alluded to in the Time To Live point, we can reuse the existing data store and data access code, but this is a tradeoff in itself: what if the current storage tech is not quite ideal for the new requirements?</p><p>If the current service makes use of a complex Entity Framework model, but the new service is so simple that Dapper makes more sense, do we introduce the new dependency or not? What if we wanted to migrate away from one datastore to another (e.g. removing all MongoDB usage in favour of Postgres), but this is already using Mongo? We&rsquo;d be increasing our dependency on a datastore we are explicitly trying to migrate away from.</p><p>All this assumes we want to write the service in the same programming language as the existing service! In our case we do but it&rsquo;s worth considering if you have multiple languages in use already.</p><p>Finally on the data storefront, if we decide to extract this as a separate service later, we will have to take into account data migrations, and how we can handle that with little if any, downtime.</p><h2 id=the-decision>The Decision<a hidden class=anchor aria-hidden=true href=#the-decision>#</a></h2><p>After weighing up all these points (and a few others), we decided to keep the service inside the existing services. The Challenge API will live in its own area in the current API, and likewise, the Challenge UI will live in its own area in the existing UI.</p><p>How do we go about keeping it all separated though?</p><ul><li><strong>Communication</strong> we discuss all changes we want to make anyway, so the first line of defence to preventing the code becoming tightly coupled are these discussions.</li><li><strong>Pull Requests</strong> someone will notice you are doing something which is reducing the separation, and a discussion about how to avoid this will happen.</li><li><strong>Naming Conventions</strong> the Challenge API shares no naming of properties with the existing API. For example, the current API passes in a <code>results_url</code> and <code>results_id</code>, but the Challenge API stores and refers to these as the <code>redirect_url</code> and <code>external_id</code>.</li><li><strong>Readme</strong> it&rsquo;ll go into the repository&rsquo;s readme file, along with any other notes which developers will find useful. The sequence diagrams we drew (with much more detail) will also go in here.</li></ul><h2 id=technical-debt>Technical Debt?<a hidden class=anchor aria-hidden=true href=#technical-debt>#</a></h2><p>The final question on this decision is &ldquo;Isn&rsquo;t this technical debt we are introducing?&rdquo;. The answer I feel is &ldquo;no&rdquo;, it feels much closer to applying the YAGNI Principle (You Ain&rsquo;t Gonna Need It). While there is work in the backlog which can use a Challenge API at the moment, that doesn&rsquo;t necessarily mean it will still be there next week, or if it will be pushed further back or changed later.</p><p>In the end, the meeting where we came up with this and drew things on the whiteboard together was productive, and likely much shorter than it took me to write all this down. We were able to resist the &ldquo;cool hip microservice&rdquo; trend and come up with a design which is pretty contained and composable with other systems in the future.</p><p>If after all this discussion we decided to go the MicroService route, I would still be happy with the decision, as we would have all this material to look back on and justify our choice, rather than waving our hands about and shouting &ldquo;but microservices&rdquo; loudly.</p><p>How do you go about designing systems? Microservice all the things? Monolith all the things? Or something in between which makes the most sense for the situation at hand?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/architecture/>architecture</a></li><li><a href=https://andydote.co.uk/tags/microservices/>microservices</a></li><li><a href=https://andydote.co.uk/tags/design/>design</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/12/08/stopping-caring/><span class=title>« Prev Page</span><br><span>Stopping Caring...</span></a>
<a class=next href=https://andydote.co.uk/2018/09/10/sketchnotes-finding-service-boundaries/><span class=title>Next Page »</span><br><span>SketchNotes: Finding Your Service Boundaries</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>