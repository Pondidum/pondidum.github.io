<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tracing: structured logging, but better in every way | Andy Dote</title><meta name=keywords content="opentelemetry,observability,tracing"><meta name=description content="It is no secret that I am not a fan of logs; I&rsquo;ve baited (rapala in work lingo. Rapala is a Finnish brand of fishing lure, and used to mean baiting in this context) discussion in our work chat with things like:
If you&rsquo;re writing log statements, you&rsquo;re doing it wrong.
This is a pretty incendiary statement, and while there has been some good discussion after, I figured it was time to write down why I think logs are bad, why tracing should be used instead, and how we get from one to the other."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2023/09/19/tracing-is-better/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Tracing: structured logging, but better in every way"><meta property="og:description" content="It is no secret that I am not a fan of logs; I&rsquo;ve baited (rapala in work lingo. Rapala is a Finnish brand of fishing lure, and used to mean baiting in this context) discussion in our work chat with things like:
If you&rsquo;re writing log statements, you&rsquo;re doing it wrong.
This is a pretty incendiary statement, and while there has been some good discussion after, I figured it was time to write down why I think logs are bad, why tracing should be used instead, and how we get from one to the other."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2023/09/19/tracing-is-better/"><meta property="article:section" content="post"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tracing: structured logging, but better in every way"><meta name=twitter:description content="It is no secret that I am not a fan of logs; I&rsquo;ve baited (rapala in work lingo. Rapala is a Finnish brand of fishing lure, and used to mean baiting in this context) discussion in our work chat with things like:
If you&rsquo;re writing log statements, you&rsquo;re doing it wrong.
This is a pretty incendiary statement, and while there has been some good discussion after, I figured it was time to write down why I think logs are bad, why tracing should be used instead, and how we get from one to the other."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Tracing: structured logging, but better in every way","item":"https://andydote.co.uk/2023/09/19/tracing-is-better/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Tracing: structured logging, but better in every way","name":"Tracing: structured logging, but better in every way","description":"It is no secret that I am not a fan of logs; I\u0026rsquo;ve baited (rapala in work lingo. Rapala is a Finnish brand of fishing lure, and used to mean baiting in this context) discussion in our work chat with things like:\nIf you\u0026rsquo;re writing log statements, you\u0026rsquo;re doing it wrong.\nThis is a pretty incendiary statement, and while there has been some good discussion after, I figured it was time to write down why I think logs are bad, why tracing should be used instead, and how we get from one to the other.","keywords":["opentelemetry","observability","tracing"],"articleBody":"It is no secret that I am not a fan of logs; I’ve baited (rapala in work lingo. Rapala is a Finnish brand of fishing lure, and used to mean baiting in this context) discussion in our work chat with things like:\nIf you’re writing log statements, you’re doing it wrong.\nThis is a pretty incendiary statement, and while there has been some good discussion after, I figured it was time to write down why I think logs are bad, why tracing should be used instead, and how we get from one to the other.\nHopefully, with less clickbait. Step 3 will shock you, though.\nLogs vs Traces First, lets breakdown what I see as the key differences between logging and tracing code. If you want the practical example and want to skip this wall of text, click here. There is also a short Question and Answer at the end.\nLog Levels Log Levels are meaningless. Is a log line debug, info, warning, error, fatal, or some other shade in between?\nThe only time I have seen this well managed was when we had 3 descriptions:\nInfo (everything) Create A Task for Later (e.g. this can wait for working hours) Wake Someone Up (this is on fire). However, this has issues; a timeout once is “for later” or just info, but many timeouts might be “wake up”, how do you encode that logic somewhere?\nThere is no equivalent of this in a trace, so there’s one less thing to worry about.\nMessages Something like found ${count} users in the cache looks like a good log message. It is clear and has the information you care about. However, when you come to querying your log aggregation system, you need to do a free-text search on a substring of the message or use a wildcard search. Both of these operations are slow, and worse still cannot help you with the negative version of the question “find me operations where the cache wasn’t checked”.\nAssuming structured logs are being used, we can at least add the count as a property to the log message so it can now be filtered on by the log aggregator. At which point, why do you need the log message at all? Why not just have log({ users_in_cache: count })?\nThe logging libraries also put more importance on the message than the properties by having it be the first (and only required) argument to the logging function. From a querying and analysis perspective, this is wrong: messages force you into free text searching and reduce the likelihood of fast queries on attributes.\nGiven this logline:\nlogger.info(\"found the user in the cache\", userId); You could reconstruct this as a statement that can be filtered on:\nspan.addAttributes({ user_in_cache: true, user_id: userId, }) Mixed Outputs / Semantics Nowadays, people configure their HTTP server to write logs to stdout rather than to a log file. This makes a great deal of sense, as now a separate piece of software can tail the logs and send them off to the aggregator. Your application’s output, however, will likely end up with mixed plaintext and structured logs, mostly down to libraries and frameworks doing their own thing with logging, which is probably not the same as what you are doing (or other libraries are doing.)\nThe second problem with writing logs to stdout is that it mixes the semantics of log lines with console output. While both log messages and console output are (probably) just text, they do have different purposes. A piece of feedback might be “Server listening on port 3000. Click here to open the browser”. This is useful to a local user running the app but isn’t valuable in your logs. Not to mention, its plaintext output on the console, rather than structured, so now your log tailer needs to figure out what to do with it.\nWith OpenTelemetry, you instead configure an exporter to handle all your traces (and logs and metrics, if you desire.) This is typically sent as OTLP format either directly to a vendor or to an OTEL Collector instance, which can add/remove/modify data and send it to one or multiple places.\nNow you are free to write whatever feedback you want to stdout.\nRelationships Loglines don’t have a causal relationships. At best, structured logs might have some kind of request identifier (such as requestID or correlationID) for all lines written during a request. This allows you to find all the log lines for a given ID, but the log lines themselves don’t have a fixed order. Ordering in structured logging relies on the timestamp field, but this is limited to the accuracy and resolution of the time source. It means that it is possible to get lines appearing at the same time when they happened at different times.\nTraces come with automatic parent-child relationships, allowing us to see not only all spans in a single request, but what caused each span, and (as we’ll get to in the next point) when they happened.\nTracing also takes these relationships another step further but having a standard set of formats to pass trace and span IDs along to other services, embedded in HTTP headers, message queue metadata, or other locations. Assuming all your other services send their traces to the same system, you can start to visualise who calls your service and what the effects are of you calling other services.\nImagine opening a trace from your service and discovering another team in a downstream service has started tracing their stuff, and you suddenly can see even more information about the request. You didn’t even do anything! You notice that the way your service is structured causes a lot of load on the downstream, and start a conversation to see if there is a way to make it faster/better.\nTimings The only timing data you get on log lines automatically is the timestamp of when the log line was written. When you want to see how long an operation took, you must start a timer, and then stop the timer, and log the elapsed duration yourself. As this is a manual process, it is often not done, and when it is done, it tends to have inconsistencies across the application, namely timing source (and thus resolution), property name, and format. Is it elapsed, elapsed_ms, duration, or length? does it contain a number of seconds, milliseconds, nanoseconds, or a timestamp format?\nBy comparison, traces come with startTime, finishTime, and duration attributes, which are not only guaranteed to be there but are set from the same timing source and are always written in the same format.\nCombine this with the relationship attributes, and you can now render timing graphs, allowing for easy visualisation of how long each part of a process takes, what can be parallelised, and what parts depend on other parts.\nFor example, this is a graph showing how long a CI job took to run, showing all the different steps, their durations, and child steps:\nQuerying Querying can have wildly different performance characteristics depending on which log aggregation service you are using. What unifies all these systems is their slowness, which is mostly down to vast amounts of data which needs indexing so that it can be free text searched. Filtering logs by their structured properties is however pretty quick (usually.)\nWhere querying falls down is trying to find trends in data, and trying to find answers to negative queries. For example, how would you search for “all requests to x endpoint, where users were not found in the cache”? This requires you to group the logs by request ID, then find an entry with a particular url path, then see if it is missing a log line. The same query in a tracing system would be where path = \"/some/api\" \u0026\u0026 !user_in_cache, as the tracing system is already aware of all the spans in a trace, and does the grouping automagically.\nFinally, visualising missing data is hard. Take this small example; it is 4 parallel requests to a system, and one of them is missing a log line. Which line is missing?\nTimestamp UserID Message 12:51:27 3fcce385be9e fetched 3rd party preferences 12:51:27 3fcce385be9e found user in cache 12:51:27 915d273db25c fetched 3rd party preferences 12:51:27 3fcce385be9e saved successfully 12:51:27 8507d369d11c fetched 3rd party preferences 12:51:27 c4e71b4a29f2 fetched 3rd party preferences 12:51:27 915d273db25c saved successfully 12:51:27 c4e71b4a29f2 found user in cache 12:51:27 c4e71b4a29f2 saved successfully 12:51:27 8507d369d11c found user in cache 12:51:27 8507d369d11c saved successfully Is it easier to see the one that is different now?\nTimestamp UserID Fetched In Cache Saved 12:51:27 3fcce385be9e true true true 12:51:27 915d273db25c true false true 12:51:27 8507d369d11c true true true 12:51:27 c4e71b4a29f2 true true true Not only is it easy to see at a glance that 915d273db25c didn’t find the user in the cache, but also how much less space this takes up (both visually and in terms of storage.)\nWe can also then use this to query further: show me all traces where in_cache != true, and see what’s different about them.\nEvolving logs So, with all that being said, let’s look at a practical example of how to go about tracing an existing system and what that looks like.\nRipping all the log statements in an application in one go is not a feasible strategy, especially on a large codebase. However, we can use logs as a decent starting place and evolve our system to something better. Namely, to OpenTelemetry Tracing.\nWe’ll start off with a real pair of functions from one of the codebases I work on. Lots of information changed to protect the guilty innocent. This is run as part of an api call to publish a container, but this part has no web specific code.\nfunc PrepareContainer(ctx context.Context, container ContainerContext, locales []string, dryRun bool, allLocalesRequired bool) (*StatusResult, error) { logger.Info(`Filling home page template`) homePage, err := RenderPage(ctx, home, container, locales, allLocalesRequired) if err != nil { return nil, err } templateIds := []string{homePage.ID} if container.PageSlugs.FAQ != \"\" { faqPage, err := RenderPage(ctx, faq, container, locales, allLocalesRequired) if err != nil { return nil, err } templateIds = append(templateIds, faqPage.ID) } if dryRun { return \u0026StatusResult{Status: StatusDryRun}, nil } logger.Info(`Marking page template(s) for usage`, \"template_ids\", templateIds) if err := MarkReadyForUsage(ctx, container, templateIds); err != nil { return nil, err } return \u0026StatusResult{Status: StatusComplete}, nil } func RenderPage(ctx context.Context, source Source, container ContainerContext, locales []string, allLocalesRequired bool) (string, error) { logger.Info(fmt.Sprintf(`Filling %s page template`, source.Name)) template, err := FetchAndFillTemplate(ctx, source, container, locales) if err != nil { return nil, err } page, err := ConfigureFromTemplate(ctx, container, template, locales) if err != nil { return nil, err } if len(page.Locales) != len(locales) { const message = fmt.Sprintf(`Failed to render %s page template for some locales`, source.Name) if allLocalesRequired { return nil, fmt.Errorf(message) } else { logger.Warn(message, \"locales\", locales, \"pages\", page.Locales) } } return page, nil } Step 1: Add a Tracer The first step is to import a tracer and start a span for each method. As is somewhat common in Go, the methods already have a ctx parameter, so we just need to wrap it with the tr.Start call.\nvar tr = otel.Tracer(\"container_api\") func PrepareContainer(ctx context.Context, container ContainerContext, locales []string, dryRun bool, allLocalesRequired bool) (*StatusResult, error) { ctx, span := tr.Start(ctx, \"prepare_container\") defer span.End() func RenderPage(ctx context.Context, source Source, container ContainerContext, locales []string, allLocalesRequired bool) (string, error) { ctx, span := tr.Start(ctx, \"render_page\") defer span.End() Just this step alone already gives us value over logging: As mentioned above, the spans automatically come with timing data and parent-child relationships.\nStep 2: Wrap the Errors OTEL Spans support a status attribute, along with a status message which is used when there is a non-success status. By creating a small wrapper function like this:\nfunc Error(s trace.Span, err error) error { s.RecordError(err) s.SetStatus(codes.Error, err.Error()) return err } We can wrap all error returns so that we capture the error itself (SetStatus) and there is an error event recorded on the trace too (RecordError):\nif err := MarkReadyForUsage(ctx, container, templateIds); err != nil { - return nil, err + return nil, tracing.Error(span, err) } Step 3: Add Attributes and Replace Messages The next steps is to replace any logger messages with attributes by turning them into statements that can be filtered on.\n- logger.Info(fmt.Sprintf(`Filling %s page template`, source.Name)) + tracing.String(span, \"source_name\", source.Name) We also want to add attributes for any parameters we might want to filter on later.\nctx, span := tr.Start(ctx, \"prepare_container\") defer span.End() tracing.StringSlice(span, \"locales\", locales) tracing.Bool(span, \"dry_run\", dryRun) tracing.Bool(span, \"locales_mandatory\", allLocalesRequired) Finally , we can simplify a code block: there is no point in the logger.Warning call here, as we can have all the required information as filterable properties:\n+ allLocalesRendered := len(page.Locales) == len(locales) + tracing.Bool(span, \"all_locales_rendered\", allLocalesRendered) + tracing.StringSlice(span, \"locales_rendered\", page.Locales) - if len(page.Locales) != len(locales) { + if !allLocalesRendered \u0026\u0026 allLocalesRequired { + return nil, tracing.Errorf(`Failed to render %s page template for some locales`, source.Name) - const message = fmt.Sprintf(`Failed to render %s page template for some locales`, source.Name) - if allLocalesRequired { - return nil, tracing.Errorf(message) - } else { - logger.Warn(message, \"locales\", locales, \"pages\", page.Locales) - } } The Result The diff between the two functions shows that the tracing version is longer - by 9 lines. However, the traced version contains so much more information than the logged version.\nvar tr = otel.Tracer(\"container_api\") func PrepareContainer(ctx context.Context, container ContainerContext, locales []string, dryRun bool, allLocalesRequired bool) (*StatusResult, error) { ctx, span := tr.Start(ctx, \"prepare_container\") defer span.End() tracing.StringSlice(span, \"locales\", locales) tracing.Bool(span, \"dry_run\", dryRun) tracing.Bool(span, \"locales_mandatory\", allLocalesRequired) homePage, err := RenderPage(ctx, home, container, locales, allLocalesRequired) if err != nil { return nil, tracing.Error(span, err) } templateIds := []string{homePage.ID} hasFaq := container.PageSlugs.FAQ != \"\" tracing.Bool(span, \"has_faq\", hasFaq) if hasFaq { faqPage, err := RenderPage(ctx, faq, container, locales, allLocalesRequired) if err != nil { return nil, tracing.Error(span, err) } templateIds = append(templateIds, faqPage.ID) } tracing.StringSlice(span, \"template_ids\", templateIds) if dryRun { return \u0026StatusResult{Status: StatusDryRun}, nil } if err := MarkReadyForUsage(ctx, container, templateIds); err != nil { return nil, tracing.Error(span, err) } return \u0026StatusResult{Status: StatusComplete}, nil } func RenderPage(ctx context.Context, source Source, container ContainerContext, locales []string, allLocalesRequired bool) (string, error) { ctx, span := tr.Start(ctx, \"render_page\") defer span.End() tracing.String(span, \"source_name\", source.Name) template, err := FetchAndFillTemplate(ctx, source, container, locales) if err != nil { return nil, tracing.Error(span, err) } page, err := ConfigureFromTemplate(ctx, container, template, locales) if err != nil { return nil, tracing.Error(span, err) } allLocalesRendered := len(page.Locales) == len(locales) tracing.Bool(span, \"all_locales_rendered\", allLocalesRendered) tracing.StringSlice(span, \"locales_rendered\", page.Locales) if !allLocalesRendered \u0026\u0026 required { return nil, tracing.Errorf(`Failed to render %s page template for some locales`, source.Name) } return page, nil } If you wish to view the files as individual steps: initial, step 1, step 2, step 3, final\nQuestions \u0026 Answers Some questions I have seen come up when talking about doing this.\nHow do I use this? If you’re debugging some error, taking the span name from your UI, and searching the codebase is a good start. Use the attributes named in code to search your UI for things that match/don’t match.\nAlso, try Observability Driven Development. It involves using your trace data before, during, and after a change so you know if its actually behaving as you expect.\nWhat do you recommend to view traces? Honeycomb is the best, no question. Lightstep is a close second.\nI think this is ugly! That is not a question. It is also a matter of opinion - I happen to think traced code looks better than logged code. It also could be that it takes some getting used to when you first start seeing it! Remember how unit testing felt weird to start with?\nI need a log message… I try to turn log messages into statements. Like in the example above:\nfound user in cache =\u003e user_in_cache: true loading template ${name} =\u003e template_loading: true, template_name: name When I need to mark that code execution has gotten to a particular point in a method:\nadd an attribute, like initial_processing_complete: true contemplate if the method should be split, and thus have its own span I have a loop, I am overwriting attributes on each iteration Similar to above: either move the loop body into its own method, use a closure to create a new span in the loop, or don’t have a span per iteration.\nYou can always add summary information after a loop:\nfoos := 0 bars := 0 for i, thing := range things { // ... if thing.prop == \"foo\" { foos++ } else { bars++ } } tracing.SetAttribute(span, \"foos\", foos) tracing.SetAttribute(span, \"bars\", bars) Thanks Thanks to Aki for some of the questions and some discussions which expanded a few of the sections here.\nThanks to Lari for prompting this blog post initially!\nThanks to you, for making it to the end.\n","wordCount":"2799","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2023/09/19/tracing-is-better/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Tracing: structured logging, but better in every way</h1><div class=post-meta><span title='2023-09-19 00:00:00 +0000 UTC'>September 19, 2023</span>&nbsp;·&nbsp;14 min</div></header><div class=post-content><p>It is no secret that I am not a fan of logs; I&rsquo;ve baited (<code>rapala</code> in work lingo. Rapala is a Finnish brand of fishing lure, and used to mean baiting in this context) discussion in our work chat with things like:</p><blockquote><p>If you&rsquo;re writing log statements, you&rsquo;re doing it wrong.</p></blockquote><p>This is a pretty incendiary statement, and while there has been some good discussion after, I figured it was time to write down why I think logs are bad, why tracing should be used instead, and how we get from one to the other.</p><p>Hopefully, with less clickbait. Step 3 will shock you, though.</p><h2 id=logs-vs-traces>Logs vs Traces<a hidden class=anchor aria-hidden=true href=#logs-vs-traces>#</a></h2><p>First, lets breakdown what I see as the key differences between logging and tracing code. If you want the practical example and want to skip this wall of text, <a href=#evolving-logs>click here</a>. There is also a short <a href=#questions--answers>Question and Answer</a> at the end.</p><h3 id=log-levels>Log Levels<a hidden class=anchor aria-hidden=true href=#log-levels>#</a></h3><p>Log Levels are meaningless. Is a log line <code>debug</code>, <code>info</code>, <code>warning</code>, <code>error</code>, <code>fatal</code>, or some other shade in between?</p><p>The only time I have seen this well managed was when we had 3 descriptions:</p><ul><li>Info (everything)</li><li>Create A Task for Later (e.g. this can wait for working hours)</li><li>Wake Someone Up (this is on fire).</li></ul><p>However, this has issues; a timeout once is &ldquo;for later&rdquo; or just <code>info</code>, but many timeouts might be &ldquo;wake up&rdquo;, how do you encode that logic somewhere?</p><p>There is no equivalent of this in a trace, so there&rsquo;s one less thing to worry about.</p><h3 id=messages>Messages<a hidden class=anchor aria-hidden=true href=#messages>#</a></h3><p>Something like <code>found ${count} users in the cache</code> looks like a good log message. It is clear and has the information you care about. However, when you come to querying your log aggregation system, you need to do a free-text search on a substring of the message or use a wildcard search. Both of these operations are slow, and worse still cannot help you with the negative version of the question &ldquo;find me operations where the cache wasn&rsquo;t checked&rdquo;.</p><p>Assuming structured logs are being used, we can at least add the <code>count</code> as a property to the log message so it can now be filtered on by the log aggregator. At which point, why do you need the log message at all? Why not just have <code>log({ users_in_cache: count })</code>?</p><p>The logging libraries also put more importance on the message than the properties by having it be the first (and only required) argument to the logging function. From a querying and analysis perspective, this is wrong: messages force you into free text searching and reduce the likelihood of fast queries on attributes.</p><p>Given this logline:</p><pre tabindex=0><code>logger.info(&#34;found the user in the cache&#34;, userId);
</code></pre><p>You could reconstruct this as a statement that can be filtered on:</p><pre tabindex=0><code>span.addAttributes({
  user_in_cache: true,
  user_id: userId,
})
</code></pre><h3 id=mixed-outputs--semantics>Mixed Outputs / Semantics<a hidden class=anchor aria-hidden=true href=#mixed-outputs--semantics>#</a></h3><p>Nowadays, people configure their HTTP server to write logs to <code>stdout</code> rather than to a log file. This makes a great deal of sense, as now a separate piece of software can tail the logs and send them off to the aggregator. Your application&rsquo;s output, however, will likely end up with mixed plaintext and structured logs, mostly down to libraries and frameworks doing their own thing with logging, which is probably not the same as what you are doing (or other libraries are doing.)</p><p>The second problem with writing logs to <code>stdout</code> is that it mixes the semantics of log lines with console output. While both log messages and console output are (probably) just text, they do have different purposes. A piece of feedback might be &ldquo;Server listening on port 3000. Click here to open the browser&rdquo;. This is useful to a local user running the app but isn&rsquo;t valuable in your logs. Not to mention, its plaintext output on the console, rather than structured, so now your log tailer needs to figure out what to do with it.</p><p>With OpenTelemetry, you instead configure an <code>exporter</code> to handle all your traces (and logs and metrics, if you desire.) This is typically sent as OTLP format either directly to a vendor or to an OTEL Collector instance, which can add/remove/modify data and send it to one or multiple places.</p><p>Now you are free to write whatever feedback you want to <code>stdout</code>.</p><h3 id=relationships>Relationships<a hidden class=anchor aria-hidden=true href=#relationships>#</a></h3><p>Loglines don&rsquo;t have a causal relationships. At best, structured logs might have some kind of request identifier (such as <code>requestID</code> or <code>correlationID</code>) for all lines written during a request. This allows you to find all the log lines for a given ID, but the log lines themselves don&rsquo;t have a fixed order. Ordering in structured logging relies on the timestamp field, but this is limited to the accuracy and resolution of the time source. It means that it is possible to get lines appearing at the same time when they happened at different times.</p><p>Traces come with automatic parent-child relationships, allowing us to see not only all spans in a single request, but what caused each span, and (as we&rsquo;ll get to in the next point) when they happened.</p><p>Tracing also takes these relationships another step further but having a standard set of formats to pass trace and span IDs along to other services, embedded in HTTP headers, message queue metadata, or other locations. Assuming all your other services send their traces to the same system, you can start to visualise who calls your service and what the effects are of you calling other services.</p><p>Imagine opening a trace from your service and discovering another team in a downstream service has started tracing their stuff, and you suddenly can see even more information about the request. You didn&rsquo;t even do anything! You notice that the way your service is structured causes a lot of load on the downstream, and start a conversation to see if there is a way to make it faster/better.</p><h3 id=timings>Timings<a hidden class=anchor aria-hidden=true href=#timings>#</a></h3><p>The only timing data you get on log lines automatically is the <code>timestamp</code> of when the log line was written. When you want to see how long an operation took, you must start a timer, and then stop the timer, and log the elapsed duration yourself. As this is a manual process, it is often not done, and when it is done, it tends to have inconsistencies across the application, namely timing source (and thus resolution), property name, and format. Is it <code>elapsed</code>, <code>elapsed_ms</code>, <code>duration</code>, or <code>length</code>? does it contain a number of seconds, milliseconds, nanoseconds, or a timestamp format?</p><p>By comparison, traces come with <code>startTime</code>, <code>finishTime</code>, and <code>duration</code> attributes, which are not only guaranteed to be there but are set from the same timing source and are always written in the same format.</p><p>Combine this with the <a href=#relationships>relationship</a> attributes, and you can now render timing graphs, allowing for easy visualisation of how long each part of a process takes, what can be parallelised, and what parts depend on other parts.</p><p>For example, this is a graph showing <a href=/2023/07/06/observability-driven-ci/>how long a CI job took to run</a>, showing all the different steps, their durations, and child steps:</p><p><img loading=lazy src=trace-build.png alt="a graph of a single build showing each task as a horizontal box denoting start and durations"></p><h3 id=querying>Querying<a hidden class=anchor aria-hidden=true href=#querying>#</a></h3><p>Querying can have wildly different performance characteristics depending on which log aggregation service you are using. What unifies all these systems is their slowness, which is mostly down to vast amounts of data which needs indexing so that it can be free text searched. Filtering logs by their structured properties is however pretty quick (usually.)</p><p>Where querying falls down is trying to find trends in data, and trying to find answers to negative queries. For example, how would you search for &ldquo;all requests to x endpoint, where users were not found in the cache&rdquo;? This requires you to group the logs by request ID, then find an entry with a particular url path, then see if it is missing a log line. The same query in a tracing system would be <code>where path = "/some/api" && !user_in_cache</code>, as the tracing system is already aware of all the spans in a trace, and does the grouping automagically.</p><p>Finally, visualising missing data is hard. Take this small example; it is 4 parallel requests to a system, and one of them is missing a log line. Which line is missing?</p><table><thead><tr><th>Timestamp</th><th>UserID</th><th>Message</th></tr></thead><tbody><tr><td>12:51:27</td><td>3fcce385be9e</td><td>fetched 3rd party preferences</td></tr><tr><td>12:51:27</td><td>3fcce385be9e</td><td>found user in cache</td></tr><tr><td>12:51:27</td><td>915d273db25c</td><td>fetched 3rd party preferences</td></tr><tr><td>12:51:27</td><td>3fcce385be9e</td><td>saved successfully</td></tr><tr><td>12:51:27</td><td>8507d369d11c</td><td>fetched 3rd party preferences</td></tr><tr><td>12:51:27</td><td>c4e71b4a29f2</td><td>fetched 3rd party preferences</td></tr><tr><td>12:51:27</td><td>915d273db25c</td><td>saved successfully</td></tr><tr><td>12:51:27</td><td>c4e71b4a29f2</td><td>found user in cache</td></tr><tr><td>12:51:27</td><td>c4e71b4a29f2</td><td>saved successfully</td></tr><tr><td>12:51:27</td><td>8507d369d11c</td><td>found user in cache</td></tr><tr><td>12:51:27</td><td>8507d369d11c</td><td>saved successfully</td></tr></tbody></table><p>Is it easier to see the one that is different now?</p><table><thead><tr><th>Timestamp</th><th>UserID</th><th>Fetched</th><th>In Cache</th><th>Saved</th></tr></thead><tbody><tr><td>12:51:27</td><td>3fcce385be9e</td><td>true</td><td>true</td><td>true</td></tr><tr><td>12:51:27</td><td>915d273db25c</td><td>true</td><td>false</td><td>true</td></tr><tr><td>12:51:27</td><td>8507d369d11c</td><td>true</td><td>true</td><td>true</td></tr><tr><td>12:51:27</td><td>c4e71b4a29f2</td><td>true</td><td>true</td><td>true</td></tr></tbody></table><p>Not only is it easy to see at a glance that <code>915d273db25c</code> didn&rsquo;t find the user in the cache, but also how much less space this takes up (both visually and in terms of storage.)</p><p>We can also then use this to query further: show me all traces where <code>in_cache != true</code>, and see what&rsquo;s different about them.</p><h2 id=evolving-logs>Evolving logs<a hidden class=anchor aria-hidden=true href=#evolving-logs>#</a></h2><p>So, with all that being said, let&rsquo;s look at a practical example of how to go about tracing an existing system and what that looks like.</p><p>Ripping all the log statements in an application in one go is not a feasible strategy, especially on a large codebase. However, we can use logs as a decent starting place and evolve our system to something better. Namely, to OpenTelemetry Tracing.</p><p>We&rsquo;ll start off with a real pair of functions from one of the codebases I work on. Lots of information changed to protect the <del>guilty</del> innocent. This is run as part of an api call to publish a container, but this part has no web specific code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrepareContainer</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>container</span> <span style=color:#a6e22e>ContainerContext</span>, <span style=color:#a6e22e>locales</span> []<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>dryRun</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>allLocalesRequired</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>StatusResult</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>`Filling home page template`</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>homePage</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>home</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>locales</span>, <span style=color:#a6e22e>allLocalesRequired</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>templateIds</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#a6e22e>homePage</span>.<span style=color:#a6e22e>ID</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>PageSlugs</span>.<span style=color:#a6e22e>FAQ</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>faqPage</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>faq</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>locales</span>, <span style=color:#a6e22e>allLocalesRequired</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>templateIds</span> = append(<span style=color:#a6e22e>templateIds</span>, <span style=color:#a6e22e>faqPage</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dryRun</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>StatusResult</span>{<span style=color:#a6e22e>Status</span>: <span style=color:#a6e22e>StatusDryRun</span>}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#e6db74>`Marking page template(s) for usage`</span>, <span style=color:#e6db74>&#34;template_ids&#34;</span>, <span style=color:#a6e22e>templateIds</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>MarkReadyForUsage</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>templateIds</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>StatusResult</span>{<span style=color:#a6e22e>Status</span>: <span style=color:#a6e22e>StatusComplete</span>}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>source</span> <span style=color:#a6e22e>Source</span>, <span style=color:#a6e22e>container</span> <span style=color:#a6e22e>ContainerContext</span>, <span style=color:#a6e22e>locales</span> []<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>allLocalesRequired</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Info</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>`Filling %s page template`</span>, <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>Name</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>template</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>FetchAndFillTemplate</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>source</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>page</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ConfigureFromTemplate</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>template</span>, <span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>Locales</span>) <span style=color:#f92672>!=</span> len(<span style=color:#a6e22e>locales</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>message</span> = <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>`Failed to render %s page template for some locales`</span>, <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>allLocalesRequired</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>message</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>logger</span>.<span style=color:#a6e22e>Warn</span>(<span style=color:#a6e22e>message</span>, <span style=color:#e6db74>&#34;locales&#34;</span>, <span style=color:#a6e22e>locales</span>, <span style=color:#e6db74>&#34;pages&#34;</span>, <span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>Locales</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>page</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=step-1-add-a-tracer>Step 1: Add a Tracer<a hidden class=anchor aria-hidden=true href=#step-1-add-a-tracer>#</a></h3><p>The first step is to import a tracer and start a span for each method. As is somewhat common in Go, the methods already have a <code>ctx</code> parameter, so we just need to wrap it with the <code>tr.Start</code> call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tr</span> = <span style=color:#a6e22e>otel</span>.<span style=color:#a6e22e>Tracer</span>(<span style=color:#e6db74>&#34;container_api&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrepareContainer</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>container</span> <span style=color:#a6e22e>ContainerContext</span>, <span style=color:#a6e22e>locales</span> []<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>dryRun</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>allLocalesRequired</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>StatusResult</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;prepare_container&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>()</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>source</span> <span style=color:#a6e22e>Source</span>, <span style=color:#a6e22e>container</span> <span style=color:#a6e22e>ContainerContext</span>, <span style=color:#a6e22e>locales</span> []<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>allLocalesRequired</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;render_page&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>()</span></span></code></pre></div><p>Just this step alone already gives us value over logging: As mentioned above, the spans automatically come with <a href=#timings>timing data</a> and <a href=#relationships>parent-child relationships</a>.</p><p><img loading=lazy src=trace-add-spans.png alt="small trace burndown graph, showing the methods from the previous code example"></p><h3 id=step-2-wrap-the-errors>Step 2: Wrap the Errors<a hidden class=anchor aria-hidden=true href=#step-2-wrap-the-errors>#</a></h3><p>OTEL Spans support a <code>status</code> attribute, along with a status message which is used when there is a non-success status. By creating a small wrapper function like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>Span</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>RecordError</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>SetStatus</span>(<span style=color:#a6e22e>codes</span>.<span style=color:#a6e22e>Error</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can wrap all error returns so that we capture the error itself (<code>SetStatus</code>) and there is an error event recorded on the trace too (<code>RecordError</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>if err := MarkReadyForUsage(ctx, container, templateIds); err != nil {
</span></span><span style=display:flex><span><span style=color:#f92672>- return nil, err
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ return nil, tracing.Error(span, err)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>}
</span></span></code></pre></div><h3 id=step-3-add-attributes-and-replace-messages>Step 3: Add Attributes and Replace Messages<a hidden class=anchor aria-hidden=true href=#step-3-add-attributes-and-replace-messages>#</a></h3><p>The next steps is to replace any <code>logger</code> messages with attributes by turning them into statements that can be filtered on.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#f92672>- logger.Info(fmt.Sprintf(`Filling %s page template`, source.Name))
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ tracing.String(span, &#34;source_name&#34;, source.Name)
</span></span></span></code></pre></div><p>We also want to add attributes for any parameters we might want to filter on later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;prepare_container&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>StringSlice</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;locales&#34;</span>, <span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Bool</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;dry_run&#34;</span>, <span style=color:#a6e22e>dryRun</span>)
</span></span><span style=display:flex;background-color:#3c3d38><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Bool</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;locales_mandatory&#34;</span>, <span style=color:#a6e22e>allLocalesRequired</span>)
</span></span></code></pre></div><p>Finally , we can simplify a code block: there is no point in the <code>logger.Warning</code> call here, as we can have all the required information as filterable properties:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a6e22e>+ allLocalesRendered := len(page.Locales) == len(locales)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>+ tracing.Bool(span, &#34;all_locales_rendered&#34;, allLocalesRendered)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+ tracing.StringSlice(span, &#34;locales_rendered&#34;, page.Locales)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>- if len(page.Locales) != len(locales) {
</span></span></span><span style=display:flex><span><span style=color:#f92672></span><span style=color:#a6e22e>+ if !allLocalesRendered &amp;&amp; allLocalesRequired {
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>+   return nil, tracing.Errorf(`Failed to render %s page template for some locales`, source.Name)
</span></span></span><span style=display:flex><span><span style=color:#a6e22e></span><span style=color:#f92672>- const message = fmt.Sprintf(`Failed to render %s page template for some locales`, source.Name)
</span></span></span><span style=display:flex><span><span style=color:#f92672>- if allLocalesRequired {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-   return nil, tracing.Errorf(message)
</span></span></span><span style=display:flex><span><span style=color:#f92672>- } else {
</span></span></span><span style=display:flex><span><span style=color:#f92672>-   logger.Warn(message, &#34;locales&#34;, locales, &#34;pages&#34;, page.Locales)
</span></span></span><span style=display:flex><span><span style=color:#f92672>- }
</span></span></span><span style=display:flex><span><span style=color:#f92672></span>}
</span></span></code></pre></div><h3 id=the-result>The Result<a hidden class=anchor aria-hidden=true href=#the-result>#</a></h3><p>The diff between the two functions shows that the tracing version is longer - by 9 lines. However, the traced version contains so much more information than the logged version.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>tr</span> = <span style=color:#a6e22e>otel</span>.<span style=color:#a6e22e>Tracer</span>(<span style=color:#e6db74>&#34;container_api&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrepareContainer</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>container</span> <span style=color:#a6e22e>ContainerContext</span>, <span style=color:#a6e22e>locales</span> []<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>dryRun</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>allLocalesRequired</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>StatusResult</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;prepare_container&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>StringSlice</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;locales&#34;</span>, <span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Bool</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;dry_run&#34;</span>, <span style=color:#a6e22e>dryRun</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Bool</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;locales_mandatory&#34;</span>, <span style=color:#a6e22e>allLocalesRequired</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>homePage</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>home</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>locales</span>, <span style=color:#a6e22e>allLocalesRequired</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>templateIds</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>string</span>{<span style=color:#a6e22e>homePage</span>.<span style=color:#a6e22e>ID</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>hasFaq</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>container</span>.<span style=color:#a6e22e>PageSlugs</span>.<span style=color:#a6e22e>FAQ</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Bool</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;has_faq&#34;</span>, <span style=color:#a6e22e>hasFaq</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hasFaq</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>faqPage</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>faq</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>locales</span>, <span style=color:#a6e22e>allLocalesRequired</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>templateIds</span> = append(<span style=color:#a6e22e>templateIds</span>, <span style=color:#a6e22e>faqPage</span>.<span style=color:#a6e22e>ID</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>StringSlice</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;template_ids&#34;</span>, <span style=color:#a6e22e>templateIds</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dryRun</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>StatusResult</span>{<span style=color:#a6e22e>Status</span>: <span style=color:#a6e22e>StatusDryRun</span>}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>MarkReadyForUsage</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>templateIds</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>StatusResult</span>{<span style=color:#a6e22e>Status</span>: <span style=color:#a6e22e>StatusComplete</span>}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>RenderPage</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>source</span> <span style=color:#a6e22e>Source</span>, <span style=color:#a6e22e>container</span> <span style=color:#a6e22e>ContainerContext</span>, <span style=color:#a6e22e>locales</span> []<span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>allLocalesRequired</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>span</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tr</span>.<span style=color:#a6e22e>Start</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;render_page&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>End</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>String</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;source_name&#34;</span>, <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>template</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>FetchAndFillTemplate</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>source</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>page</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ConfigureFromTemplate</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>container</span>, <span style=color:#a6e22e>template</span>, <span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>allLocalesRendered</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>Locales</span>) <span style=color:#f92672>==</span> len(<span style=color:#a6e22e>locales</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Bool</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;all_locales_rendered&#34;</span>, <span style=color:#a6e22e>allLocalesRendered</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>StringSlice</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;locales_rendered&#34;</span>, <span style=color:#a6e22e>page</span>.<span style=color:#a6e22e>Locales</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>allLocalesRendered</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>required</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>`Failed to render %s page template for some locales`</span>, <span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>Name</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>page</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you wish to view the files as individual steps: <a href=example-api-0.go>initial</a>, <a href=example-api-1.go>step 1</a>, <a href=example-api-2.go>step 2</a>, <a href=example-api-3.go>step 3</a>, <a href=example-api-4.go>final</a></p><h2 id=questions--answers>Questions & Answers<a hidden class=anchor aria-hidden=true href=#questions--answers>#</a></h2><p>Some questions I have seen come up when talking about doing this.</p><h3 id=how-do-i-use-this>How do I use this?<a hidden class=anchor aria-hidden=true href=#how-do-i-use-this>#</a></h3><p>If you&rsquo;re debugging some error, taking the span name from your UI, and searching the codebase is a good start. Use the attributes named in code to search your UI for things that match/don&rsquo;t match.</p><p>Also, try <a href=/presentations/index.html?odd>Observability Driven Development</a>. It involves using your trace data before, during, and after a change so you know if its actually behaving as you expect.</p><h3 id=what-do-you-recommend-to-view-traces>What do you recommend to view traces?<a hidden class=anchor aria-hidden=true href=#what-do-you-recommend-to-view-traces>#</a></h3><p><a href=https://honeycomb.io>Honeycomb</a> is the best, no question. <a href=https://lightstep.com>Lightstep</a> is a close second.</p><h3 id=i-think-this-is-ugly>I think this is ugly!<a hidden class=anchor aria-hidden=true href=#i-think-this-is-ugly>#</a></h3><p>That is not a question. It is also a matter of opinion - I happen to think traced code looks better than logged code. It also could be that it takes some getting used to when you first start seeing it! Remember how unit testing felt weird to start with?</p><h3 id=i-need-a-log-message>I need a log message&mldr;<a hidden class=anchor aria-hidden=true href=#i-need-a-log-message>#</a></h3><p>I try to turn log messages into statements. Like in the example above:</p><ul><li><code>found user in cache</code> => <code>user_in_cache: true</code></li><li><code>loading template ${name}</code> => <code>template_loading: true, template_name: name</code></li></ul><p>When I need to mark that code execution has gotten to a particular point in a method:</p><ul><li>add an attribute, like <code>initial_processing_complete: true</code></li><li>contemplate if the method should be split, and thus have its own span</li></ul><h3 id=i-have-a-loop-i-am-overwriting-attributes-on-each-iteration>I have a loop, I am overwriting attributes on each iteration<a hidden class=anchor aria-hidden=true href=#i-have-a-loop-i-am-overwriting-attributes-on-each-iteration>#</a></h3><p>Similar to above: either move the loop body into its own method, use a closure to create a new span in the loop, or don&rsquo;t have a span per iteration.</p><p>You can always add summary information after a loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>foos</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bars</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>thing</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>things</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>thing</span>.<span style=color:#a6e22e>prop</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;foo&#34;</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>foos</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bars</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>SetAttribute</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;foos&#34;</span>, <span style=color:#a6e22e>foos</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>tracing</span>.<span style=color:#a6e22e>SetAttribute</span>(<span style=color:#a6e22e>span</span>, <span style=color:#e6db74>&#34;bars&#34;</span>, <span style=color:#a6e22e>bars</span>)
</span></span></code></pre></div><h2 id=thanks>Thanks<a hidden class=anchor aria-hidden=true href=#thanks>#</a></h2><p>Thanks to <a href=https://fi.linkedin.com/in/aki-foudila-339222200>Aki</a> for some of the questions and some discussions which expanded a few of the sections here.</p><p>Thanks to <a href=https://www.tuomistolari.net/>Lari</a> for prompting this blog post initially!</p><p>Thanks to you, for making it to the end.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/opentelemetry/>opentelemetry</a></li><li><a href=https://andydote.co.uk/tags/observability/>observability</a></li><li><a href=https://andydote.co.uk/tags/tracing/>tracing</a></li></ul><nav class=paginav><a class=next href=https://andydote.co.uk/2023/07/23/architecture-testing/><span class=title>Next Page »</span><br><span>Architecture Testing</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>