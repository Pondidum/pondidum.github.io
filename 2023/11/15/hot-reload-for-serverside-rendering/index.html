<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hot Reload for ServerSide Rendering | Andy Dote</title><meta name=keywords content="developer experience,productivity"><meta name=description content="In one of my too many side projects, I am using htmx and go templates to render a somewhat complicated web UI. I much prefer using htmx for this kind of thing rather than react, as react brings in so much more additional complexity than I need or want. However, there is one thing I miss from the React ecosystem, and that is hot reload.
Being able to save a file in my editor and see the changes instantly in a web browser is an amazing developer experience, and I want to recreate that for htmx."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2023/11/15/hot-reload-for-serverside-rendering/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Hot Reload for ServerSide Rendering"><meta property="og:description" content="In one of my too many side projects, I am using htmx and go templates to render a somewhat complicated web UI. I much prefer using htmx for this kind of thing rather than react, as react brings in so much more additional complexity than I need or want. However, there is one thing I miss from the React ecosystem, and that is hot reload.
Being able to save a file in my editor and see the changes instantly in a web browser is an amazing developer experience, and I want to recreate that for htmx."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2023/11/15/hot-reload-for-serverside-rendering/"><meta property="article:section" content="post"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hot Reload for ServerSide Rendering"><meta name=twitter:description content="In one of my too many side projects, I am using htmx and go templates to render a somewhat complicated web UI. I much prefer using htmx for this kind of thing rather than react, as react brings in so much more additional complexity than I need or want. However, there is one thing I miss from the React ecosystem, and that is hot reload.
Being able to save a file in my editor and see the changes instantly in a web browser is an amazing developer experience, and I want to recreate that for htmx."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Hot Reload for ServerSide Rendering","item":"https://andydote.co.uk/2023/11/15/hot-reload-for-serverside-rendering/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hot Reload for ServerSide Rendering","name":"Hot Reload for ServerSide Rendering","description":"In one of my too many side projects, I am using htmx and go templates to render a somewhat complicated web UI. I much prefer using htmx for this kind of thing rather than react, as react brings in so much more additional complexity than I need or want. However, there is one thing I miss from the React ecosystem, and that is hot reload.\nBeing able to save a file in my editor and see the changes instantly in a web browser is an amazing developer experience, and I want to recreate that for htmx.","keywords":["developer experience","productivity"],"articleBody":"In one of my too many side projects, I am using htmx and go templates to render a somewhat complicated web UI. I much prefer using htmx for this kind of thing rather than react, as react brings in so much more additional complexity than I need or want. However, there is one thing I miss from the React ecosystem, and that is hot reload.\nBeing able to save a file in my editor and see the changes instantly in a web browser is an amazing developer experience, and I want to recreate that for htmx. I realised the steps to build my own hot reload were actually pretty small.\nOn the server side:\ngenerate a guid on startup expose this to the client somehow On the client side:\nfetch the guid if the guid doesn’t match what we have seen before, refresh the page Despite my preference for HTMX and html/template in Go, neither the Client nor Server implementations a framework specific. The server utilises Fiber as its host, but it is not a hard requirement.\nThe Client I decided to use a websocket for the transport, as if I decide later to make the server notify the client of changes also. For the client side, I have a single script that I include in the html template, which connects a websocket, and handles all messages received. It also handles reconnection if the server disconnects, along with a simple backoff mechanism.\n(function () { var lastUuid = \"\"; var timeout; const resetBackoff = () =\u003e { timeout = 1000; }; const backOff = () =\u003e { if (timeout \u003e 10 * 1000) { return; } timeout = timeout * 2; }; const hotReloadUrl = () =\u003e { const hostAndPort = location.hostname + (location.port ? \":\" + location.port : \"\"); if (location.protocol === \"https:\") { return \"wss://\" + hostAndPort + \"/ws/hotreload\"; } else if (location.protocol === \"http:\") { return \"ws://\" + hostAndPort + \"/ws/hotreload\"; } }; function connectHotReload() { const socket = new WebSocket(hotReloadUrl()); socket.onmessage = (event) =\u003e { if (lastUuid === \"\") { lastUuid = event.data; } if (lastUuid !== event.data) { console.log(\"[Hot Reloader] Server Changed, reloading\"); location.reload(); } }; socket.onopen = () =\u003e { resetBackoff(); socket.send(\"Hello\"); }; socket.onclose = () =\u003e { const timeoutId = setTimeout(function () { clearTimeout(timeoutId); backOff(); connectHotReload(); }, timeout); }; } resetBackoff(); connectHotReload(); })(); Note this is a pretty dumb hot reload - it just refreshes the current page.\nThe Server The entire implementation is about 20 lines of go, utilising the websocket package for fiber, my web server framework of choice. There is not a lot to it; just create a UUID, and send that value to any client which connects to the websocket, and sends any message to us.\nimport ( \"github.com/gofiber/contrib/websocket\" \"github.com/gofiber/fiber/v2\" \"github.com/google/uuid\" ) func WithHotReload(app *fiber.App) { id := []byte(uuid.New().String()) app.Use(\"/ws\", func(c *fiber.Ctx) error { if websocket.IsWebSocketUpgrade(c) { return c.Next() } return fiber.ErrUpgradeRequired }) app.Get(\"/ws/hotreload\", websocket.New(func(c *websocket.Conn) { for { if _, _, err := c.ReadMessage(); err != nil { break } if err := c.WriteMessage(websocket.TextMessage, id); err != nil { break } } })) } How it works I use the modd tool to restart my go applications when I am developing them: any time I save a file, the app restarts.\nWhen the app restarts, all websocket connections are aborted. The client then tries to reconnect, and when it does, it receives a new UUID from the server, causing the entire page to refresh. As all my apps are serverside rendered, there is usually little, if any, state to keep, so a full page refresh is fine for my development needs.\nIn this implementation, the socket is not needed; it would be just as easy to poll an API every x seconds to see if the UUID has changed, but having the client react to the server breaking the connection on restart seems better; there is less random HTTP noise in the network tab too.\nFuture modifications I think I could make htmx do the hard work of switching out the page dom when the socket indicates the page has changed, and while that would be cool, it does mean that the client part would become htmx specific, so I probably won’t do this.\n","wordCount":"706","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2023/11/15/hot-reload-for-serverside-rendering/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Hot Reload for ServerSide Rendering</h1><div class=post-meta><span title='2023-11-15 00:00:00 +0000 UTC'>November 15, 2023</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>In one of my too many side projects, I am using <a href=https://htmx.org/>htmx</a> and go templates to render a somewhat complicated web UI. I much prefer using htmx for this kind of thing rather than react, as react brings in so much more additional complexity than I need or want. However, there is one thing I miss from the React ecosystem, and that is hot reload.</p><p>Being able to save a file in my editor and see the changes instantly in a web browser is an amazing developer experience, and I want to recreate that for htmx. I realised the steps to build my own hot reload were actually pretty small.</p><p>On the server side:</p><ul><li>generate a guid on startup</li><li>expose this to the client somehow</li></ul><p>On the client side:</p><ul><li>fetch the guid</li><li>if the guid doesn&rsquo;t match what we have seen before, refresh the page</li></ul><p>Despite my preference for HTMX and html/template in Go, neither the Client nor Server implementations a framework specific. The server utilises <a href=https://gofiber.io/>Fiber</a> as its host, but it is not a hard requirement.</p><h2 id=the-client>The Client<a hidden class=anchor aria-hidden=true href=#the-client>#</a></h2><p>I decided to use a websocket for the transport, as if I decide later to make the server notify the client of changes also. For the client side, I have a single script that I include in the html template, which connects a websocket, and handles all messages received. It also handles reconnection if the server disconnects, along with a simple backoff mechanism.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>lastUuid</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>timeout</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>resetBackoff</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>timeout</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>backOff</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>timeout</span> <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>1000</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>timeout</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>timeout</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hotReloadUrl</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hostAndPort</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>hostname</span> <span style=color:#f92672>+</span> (<span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>port</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;:&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>port</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>protocol</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;https:&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;wss://&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>hostAndPort</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/ws/hotreload&#34;</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>protocol</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;http:&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;ws://&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>hostAndPort</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/ws/hotreload&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>connectHotReload</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>socket</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>WebSocket</span>(<span style=color:#a6e22e>hotReloadUrl</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>onmessage</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>lastUuid</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;&#34;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>lastUuid</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>lastUuid</span> <span style=color:#f92672>!==</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>data</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;[Hot Reloader] Server Changed, reloading&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>location</span>.<span style=color:#a6e22e>reload</span>();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>onopen</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>resetBackoff</span>();
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>send</span>(<span style=color:#e6db74>&#34;Hello&#34;</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>socket</span>.<span style=color:#a6e22e>onclose</span> <span style=color:#f92672>=</span> () =&gt; {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>timeoutId</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span> () {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>clearTimeout</span>(<span style=color:#a6e22e>timeoutId</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>backOff</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>connectHotReload</span>();
</span></span><span style=display:flex><span>      }, <span style=color:#a6e22e>timeout</span>);
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>resetBackoff</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>connectHotReload</span>();
</span></span><span style=display:flex><span>})();
</span></span></code></pre></div><p>Note this is a pretty dumb hot reload - it just refreshes the current page.</p><h2 id=the-server>The Server<a hidden class=anchor aria-hidden=true href=#the-server>#</a></h2><p>The entire implementation is about 20 lines of go, utilising the <code>websocket</code> package for <code>fiber</code>, my web server framework of choice. There is not a lot to it; just create a UUID, and send that value to any client which connects to the websocket, and sends any message to us.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;github.com/gofiber/contrib/websocket&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;github.com/gofiber/fiber/v2&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;github.com/google/uuid&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WithHotReload</span>(<span style=color:#a6e22e>app</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>fiber</span>.<span style=color:#a6e22e>App</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>id</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#a6e22e>uuid</span>.<span style=color:#a6e22e>New</span>().<span style=color:#a6e22e>String</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Use</span>(<span style=color:#e6db74>&#34;/ws&#34;</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>fiber</span>.<span style=color:#a6e22e>Ctx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>websocket</span>.<span style=color:#a6e22e>IsWebSocketUpgrade</span>(<span style=color:#a6e22e>c</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Next</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fiber</span>.<span style=color:#a6e22e>ErrUpgradeRequired</span>
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;/ws/hotreload&#34;</span>, <span style=color:#a6e22e>websocket</span>.<span style=color:#a6e22e>New</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>websocket</span>.<span style=color:#a6e22e>Conn</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>ReadMessage</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>WriteMessage</span>(<span style=color:#a6e22e>websocket</span>.<span style=color:#a6e22e>TextMessage</span>, <span style=color:#a6e22e>id</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=how-it-works>How it works<a hidden class=anchor aria-hidden=true href=#how-it-works>#</a></h2><p>I use the <a href=https://github.com/cortesi/modd/>modd</a> tool to restart my go applications when I am developing them: any time I save a file, the app restarts.</p><p>When the app restarts, all websocket connections are aborted. The client then tries to reconnect, and when it does, it receives a new UUID from the server, causing the entire page to refresh. As all my apps are serverside rendered, there is usually little, if any, state to keep, so a full page refresh is fine for my development needs.</p><p>In this implementation, the socket is not needed; it would be just as easy to poll an API every x seconds to see if the UUID has changed, but having the client react to the server breaking the connection on restart seems better; there is less random HTTP noise in the network tab too.</p><h2 id=future-modifications>Future modifications<a hidden class=anchor aria-hidden=true href=#future-modifications>#</a></h2><p>I think I could make htmx do the hard work of switching out the page dom when the socket indicates the page has changed, and while that would be cool, it does mean that the client part would become htmx specific, so I probably won&rsquo;t do this.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/developer-experience/>developer experience</a></li><li><a href=https://andydote.co.uk/tags/productivity/>productivity</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2024/07/20/otel-errors/><span class=title>« Prev Page</span><br><span>Multiple errors in an OTEL Span</span></a>
<a class=next href=https://andydote.co.uk/2023/09/19/tracing-is-better/><span class=title>Next Page »</span><br><span>Tracing: structured logging, but better in every way</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>