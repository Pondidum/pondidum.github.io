<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Implementing Custom Aspnet Core ModelBinders | Andy Dote</title><meta name=keywords content="design,aspnetcore,dotnetcore"><meta name=description content="This post is a summary of a stream I did last night where I implemented all of this. If you want to watch me grumble my way through it, it&rsquo;s available on YouTube here.
In my Crispin project, I wanted the ability to support loading Toggles by both name and ID, for all operations. As I use mediator to send messages from my controllers to the handlers in the domain, this means that I had to either:"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2017/09/22/implemeting-custom-aspnetcore-modelbinders/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Implementing Custom Aspnet Core ModelBinders"><meta property="og:description" content="This post is a summary of a stream I did last night where I implemented all of this. If you want to watch me grumble my way through it, it&rsquo;s available on YouTube here.
In my Crispin project, I wanted the ability to support loading Toggles by both name and ID, for all operations. As I use mediator to send messages from my controllers to the handlers in the domain, this means that I had to either:"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2017/09/22/implemeting-custom-aspnetcore-modelbinders/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-09-22T00:00:00+00:00"><meta property="article:modified_time" content="2017-09-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing Custom Aspnet Core ModelBinders"><meta name=twitter:description content="This post is a summary of a stream I did last night where I implemented all of this. If you want to watch me grumble my way through it, it&rsquo;s available on YouTube here.
In my Crispin project, I wanted the ability to support loading Toggles by both name and ID, for all operations. As I use mediator to send messages from my controllers to the handlers in the domain, this means that I had to either:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Implementing Custom Aspnet Core ModelBinders","item":"https://andydote.co.uk/2017/09/22/implemeting-custom-aspnetcore-modelbinders/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Implementing Custom Aspnet Core ModelBinders","name":"Implementing Custom Aspnet Core ModelBinders","description":"This post is a summary of a stream I did last night where I implemented all of this. If you want to watch me grumble my way through it, it\u0026rsquo;s available on YouTube here.\nIn my Crispin project, I wanted the ability to support loading Toggles by both name and ID, for all operations. As I use mediator to send messages from my controllers to the handlers in the domain, this means that I had to either:","keywords":["design","aspnetcore","dotnetcore"],"articleBody":"This post is a summary of a stream I did last night where I implemented all of this. If you want to watch me grumble my way through it, it’s available on YouTube here.\nIn my Crispin project, I wanted the ability to support loading Toggles by both name and ID, for all operations. As I use mediator to send messages from my controllers to the handlers in the domain, this means that I had to either:\n create separate request types for loading by name and loading by id have both an ID and Name property on each method  I didn’t like the sound of either of these as both involve more typing than I want to do, and the second variant has the added downside of causing a lot of if statements in the handlers, as you have to work out which is set before loading. Not to mention the duplication of the load toggle logic in every handler.\nThe solution I came up with was to use some inheritance, a static factory, some method hiding, and a custom IModelBinder.\nToggleLocator I started off by having an abstract base class called ToggleLocator. To start with, it just has two static methods for creating an instance of ToggleLocator:\npublic abstract class ToggleLocator { \tpublic static ToggleLocator Create(Guid toggleID) = new ToggleLocatorByID(toggleID); \tpublic static ToggleLocator Create(string toggleName) = new ToggleLocatorByName(toggleName); } As this is going to be used in both Query handlers and Command handlers, I need to be able to load the Toggle (the EventSourced AggregateRoot), and the ToggleView (the projected current state of the AggregateRoot). So we add two abstract methods to the ToggleLocator\ninternal abstract ToggleView LocateView(IStorageSession session); internal abstract Toggle LocateAggregate(IStorageSession session); Note that not only are these two methods abstract, they are also internal - we don’t want anything outside the domain to know about how a toggle is loaded. I was considering using an privately implemented interface to do this method hiding, but didn’t see the point as I can acomplish the same using the internal methods.\nWe can now write two implementations of the ToggleLocator. First up is the ToggleLocatorByID, which is very straight forward to implement; we use the ID to load the AggregateRoot directly, and the AllToggles view can be queried by ID to fetch the view version also.\npublic class ToggleLocatorByID : ToggleLocator { \tprivate readonly ToggleID _toggleID;  \tpublic ToggleLocatorByID(ToggleID toggleID) \t{ \t_toggleID = toggleID; \t}  \tinternal override ToggleView LocateView(IStorageSession session) = session \t.LoadProjection() \t.Toggles \t.SingleOrDefault(view = view.ID == _toggleID);  \tinternal override Toggle LocateAggregate(IStorageSession session) = session \t.LoadAggregate(_toggleID); } The more interesting class to implement is ToggleLocatorByName, as this needs to be able to load an AggregateRoot by name; something which is not directly supported. So to do this we fetch the ToggleView first, and then use the ID property so we can load the Toggle:\npublic class ToggleLocatorByName : ToggleLocator { \tprivate readonly string _toggleName;  \tpublic ToggleLocatorByName(string toggleName) \t{ \t_toggleName = toggleName; \t}  \tinternal override ToggleView LocateView(IStorageSession session) = session \t.LoadProjection() \t.Toggles \t.SingleOrDefault(t = t.Name.Equals(_toggleName, StringComparison.OrdinalIgnoreCase));  \tinternal override Toggle LocateAggregate(IStorageSession session) \t{ \tvar view = LocateView(session);  \treturn view != null \t? session.LoadAggregate(view.ID) \t: null; \t} } All this means that the handlers have no conditionals for loading, they just call the relevant .Locate method:\nprivate Task ModifyTags(ToggleLocator locator, Action modify) { \tusing (var session = _storage.BeginSession()) \t{ \tvar toggle = locator.LocateAggregate(session); \t//or \tvar view = locator.LocateView(session); \t//... \t} } And in the controllers, we have separate action methods for each route:\n[Route(\"name/{toggleName}/tags/{tagName}\")] [HttpPut] public async Task PutTag(string toggleName, string tagName) { \tvar request = new AddToggleTagRequest(ToggleLocator.Create(toggleName), tagName); \tvar response = await _mediator.Send(request);  \treturn new JsonResult(response.Tags); } [Route(\"id/{toggleID}/tags/{tagName}\")] [HttpPut] public async Task PutTag(Guid toggleID, string tagName) { \tvar request = new AddToggleTagRequest(ToggleLocator.Create(ToggleID.Parse(toggleID)), tagName); \tvar response = await _mediator.Send(request);  \treturn new JsonResult(response.Tags); } But that is still more duplication than I would like, so lets see if we can resolve this with a custom IModelBinder.\nCustom IModelBinder for ToggleLocator To make a custom model binder, we need to implement two interfaces: IModelBinderProvider and IModelBinder. I am not sure why IModelBinderProvider exists to be perfectly honest, but you need it, and as it is doing nothing particularly interesting, I decided to implement both interfaces in the one class, and just return this from IModelBinderProvider.GetBinder:\npublic class ToggleLocatorBinder : IModelBinderProvider { \tpublic IModelBinder GetBinder(ModelBinderProviderContext context) \t{ \tif (context.Metadata.ModelType == typeof(ToggleLocator)) \treturn this;  \treturn null; \t} } We can then implement the second interface, IModelBinder. Here we check (again) that the parameter is a ToggleLocator, fetch the value which came from the route (or querystring, thanks to the .ValueProvider property).\nAll I need to do here is try and parse the value as a Guid. If it parses successfully, we create a ToggleLocatorByID instance, otherwise create a ToggleLocatorByName instance.\npublic class ToggleLocatorBinder : IModelBinderProvider, IModelBinder { \tpublic Task BindModelAsync(ModelBindingContext bindingContext) \t{ \tif (bindingContext.ModelType != typeof(ToggleLocator)) \treturn Task.CompletedTask;  \tvar value = bindingContext.ValueProvider.GetValue(bindingContext.FieldName); \tvar guid = Guid.Empty;  \tvar locator = Guid.TryParse(value.FirstValue, out guid) \t? ToggleLocator.Create(ToggleID.Parse(guid)) \t: ToggleLocator.Create(value.FirstValue);  \tbindingContext.Result = ModelBindingResult.Success(locator);  \treturn Task.CompletedTask; \t} } We add this into our MVC registration code at the beginning of the ModelBinderProviders collection, as MVC will use the first binder which can support the target type, and there is a binder in the collection somewhere which will handle anything which inherits object…\nservices.AddMvc(options = { \toptions.ModelBinderProviders.Insert(0, new ToggleLocatorBinder()); }); Now we can reduce our action methods down to one which handles both routes:\n[Route(\"id/{id}/tags/{tagName}\")] [Route(\"name/{id}/tags/{tagName}\")] [HttpPut] public async Task PutTag(ToggleLocator id, string tagName) { \tvar request = new AddToggleTagRequest(id, tagName); \tvar response = await _mediator.Send(request);  \treturn new JsonResult(response.Tags); } Much better, no duplication, and no (obvious) if statements!\n","wordCount":"937","inLanguage":"en","datePublished":"2017-09-22T00:00:00Z","dateModified":"2017-09-22T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2017/09/22/implemeting-custom-aspnetcore-modelbinders/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Implementing Custom Aspnet Core ModelBinders</h1><div class=post-meta><span title="2017-09-22 00:00:00 +0000 UTC">September 22, 2017</span>&nbsp;·&nbsp;5 min</div></header><div class=post-content><p>This post is a summary of a <a href=https://twitch.tv/pondidum>stream</a> I did last night where I implemented all of this. If you want to watch me grumble my way through it, it&rsquo;s <a href="https://www.youtube.com/watch?v=hR213Oxj_xI">available on YouTube here</a>.</p><p>In my <a href=https://github.com/pondidum/crispin>Crispin</a> project, I wanted the ability to support loading Toggles by both name and ID, for all operations. As I use mediator to send messages from my controllers to the handlers in the domain, this means that I had to either:</p><ul><li>create separate request types for loading by name and loading by id</li><li>have both an <code>ID</code> and <code>Name</code> property on each method</li></ul><p>I didn&rsquo;t like the sound of either of these as both involve more typing than I want to do, and the second variant has the added downside of causing a lot of <code>if</code> statements in the handlers, as you have to work out which is set before loading. Not to mention the duplication of the load toggle logic in every handler.</p><p>The solution I came up with was to use some inheritance, a static factory, some method hiding, and a custom <code>IModelBinder</code>.</p><h2 id=togglelocator>ToggleLocator<a hidden class=anchor aria-hidden=true href=#togglelocator>#</a></h2><p>I started off by having an <code>abstract</code> base class called <code>ToggleLocator</code>. To start with, it just has two static methods for creating an instance of <code>ToggleLocator</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleLocator</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ToggleLocator Create(Guid toggleID) =&gt; <span style=color:#66d9ef>new</span> ToggleLocatorByID(toggleID);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ToggleLocator Create(<span style=color:#66d9ef>string</span> toggleName) =&gt; <span style=color:#66d9ef>new</span> ToggleLocatorByName(toggleName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As this is going to be used in both Query handlers and Command handlers, I need to be able to load the Toggle (the EventSourced AggregateRoot), and the ToggleView (the projected current state of the AggregateRoot). So we add two <code>abstract</code> methods to the <code>ToggleLocator</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>abstract</span> ToggleView LocateView(IStorageSession session);
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>abstract</span> Toggle LocateAggregate(IStorageSession session);
</span></span></code></pre></div><p>Note that not only are these two methods <code>abstract</code>, they are also <code>internal</code> - we don&rsquo;t want anything outside the domain to know about how a toggle is loaded. I was considering using an privately implemented interface to do this method hiding, but didn&rsquo;t see the point as I can acomplish the same using the internal methods.</p><p>We can now write two implementations of the <code>ToggleLocator</code>. First up is the <code>ToggleLocatorByID</code>, which is very straight forward to implement; we use the ID to load the AggregateRoot directly, and the <code>AllToggles</code> view can be queried by ID to fetch the view version also.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleLocatorByID</span> : ToggleLocator
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ToggleID <span style=color:#ae81ff>_</span>toggleID;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> ToggleLocatorByID(ToggleID toggleID)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>toggleID = toggleID;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>override</span> ToggleView LocateView(IStorageSession session) =&gt; session
</span></span><span style=display:flex><span>		.LoadProjection&lt;AllToggles&gt;()
</span></span><span style=display:flex><span>		.Toggles
</span></span><span style=display:flex><span>		.SingleOrDefault(view =&gt; view.ID == <span style=color:#ae81ff>_</span>toggleID);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>override</span> Toggle LocateAggregate(IStorageSession session) =&gt; session
</span></span><span style=display:flex><span>		.LoadAggregate&lt;Toggle&gt;(<span style=color:#ae81ff>_</span>toggleID);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The more interesting class to implement is <code>ToggleLocatorByName</code>, as this needs to be able to load an AggregateRoot by name; something which is not directly supported. So to do this we fetch the <code>ToggleView</code> first, and then use the <code>ID</code> property so we can load the <code>Toggle</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleLocatorByName</span> : ToggleLocator
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>string</span> <span style=color:#ae81ff>_</span>toggleName;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> ToggleLocatorByName(<span style=color:#66d9ef>string</span> toggleName)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#ae81ff>_</span>toggleName = toggleName;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>override</span> ToggleView LocateView(IStorageSession session) =&gt; session
</span></span><span style=display:flex><span>		.LoadProjection&lt;AllToggles&gt;()
</span></span><span style=display:flex><span>		.Toggles
</span></span><span style=display:flex><span>		.SingleOrDefault(t =&gt; t.Name.Equals(<span style=color:#ae81ff>_</span>toggleName, StringComparison.OrdinalIgnoreCase));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>override</span> Toggle LocateAggregate(IStorageSession session)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> view = LocateView(session);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> view != <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>			? session.LoadAggregate&lt;Toggle&gt;(view.ID)
</span></span><span style=display:flex><span>			: <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>All this means that the handlers have no conditionals for loading, they just call the relevant <code>.Locate</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>private</span> Task&lt;UpdateToggleTagsResponse&gt; ModifyTags(ToggleLocator locator, Action&lt;Toggle&gt; modify)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> session = <span style=color:#ae81ff>_</span>storage.BeginSession())
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> toggle = locator.LocateAggregate(session);
</span></span><span style=display:flex><span>		<span style=color:#75715e>//or</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> view  = locator.LocateView(session);
</span></span><span style=display:flex><span>		<span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And in the controllers, we have separate action methods for each route:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Route(&#34;name/{toggleName}/tags/{tagName}&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPut]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; PutTag(<span style=color:#66d9ef>string</span> toggleName, <span style=color:#66d9ef>string</span> tagName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> request = <span style=color:#66d9ef>new</span> AddToggleTagRequest(ToggleLocator.Create(toggleName), tagName);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> <span style=color:#ae81ff>_</span>mediator.Send(request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JsonResult(response.Tags);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[Route(&#34;id/{toggleID}/tags/{tagName}&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPut]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; PutTag(Guid toggleID, <span style=color:#66d9ef>string</span> tagName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> request = <span style=color:#66d9ef>new</span> AddToggleTagRequest(ToggleLocator.Create(ToggleID.Parse(toggleID)), tagName);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> <span style=color:#ae81ff>_</span>mediator.Send(request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JsonResult(response.Tags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But that is still more duplication than I would like, so lets see if we can resolve this with a custom <code>IModelBinder</code>.</p><h2 id=custom-imodelbinder-for-togglelocator>Custom IModelBinder for ToggleLocator<a hidden class=anchor aria-hidden=true href=#custom-imodelbinder-for-togglelocator>#</a></h2><p>To make a custom model binder, we need to implement two interfaces: <code>IModelBinderProvider</code> and <code>IModelBinder</code>. I am not sure why <code>IModelBinderProvider</code> exists to be perfectly honest, but you need it, and as it is doing nothing particularly interesting, I decided to implement both interfaces in the one class, and just return <code>this</code> from <code>IModelBinderProvider.GetBinder</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleLocatorBinder</span> : IModelBinderProvider
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> IModelBinder GetBinder(ModelBinderProviderContext context)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (context.Metadata.ModelType == <span style=color:#66d9ef>typeof</span>(ToggleLocator))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can then implement the second interface, <code>IModelBinder</code>. Here we check (again) that the parameter is a <code>ToggleLocator</code>, fetch the value which came from the route (or querystring, thanks to the <code>.ValueProvider</code> property).</p><p>All I need to do here is try and parse the value as a <code>Guid</code>. If it parses successfully, we create a <code>ToggleLocatorByID</code> instance, otherwise create a <code>ToggleLocatorByName</code> instance.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ToggleLocatorBinder</span> : IModelBinderProvider, IModelBinder
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> Task BindModelAsync(ModelBindingContext bindingContext)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> (bindingContext.ModelType != <span style=color:#66d9ef>typeof</span>(ToggleLocator))
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> Task.CompletedTask;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#66d9ef>value</span> = bindingContext.ValueProvider.GetValue(bindingContext.FieldName);
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> guid = Guid.Empty;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> locator = Guid.TryParse(<span style=color:#66d9ef>value</span>.FirstValue, <span style=color:#66d9ef>out</span> guid)
</span></span><span style=display:flex><span>			? ToggleLocator.Create(ToggleID.Parse(guid))
</span></span><span style=display:flex><span>			: ToggleLocator.Create(<span style=color:#66d9ef>value</span>.FirstValue);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		bindingContext.Result = ModelBindingResult.Success(locator);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> Task.CompletedTask;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We add this into our MVC registration code at the beginning of the <code>ModelBinderProviders</code> collection, as MVC will use the first binder which can support the target type, and there is a binder in the collection somewhere which will handle anything which inherits object&mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>services.AddMvc(options =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	options.ModelBinderProviders.Insert(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>new</span> ToggleLocatorBinder());
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>Now we can reduce our action methods down to one which handles both routes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Route(&#34;id/{id}/tags/{tagName}&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[Route(&#34;name/{id}/tags/{tagName}&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>[HttpPut]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task&lt;IActionResult&gt; PutTag(ToggleLocator id, <span style=color:#66d9ef>string</span> tagName)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> request = <span style=color:#66d9ef>new</span> AddToggleTagRequest(id, tagName);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> response = <span style=color:#66d9ef>await</span> <span style=color:#ae81ff>_</span>mediator.Send(request);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> JsonResult(response.Tags);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Much better, no duplication, and no (obvious) if statements!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/aspnetcore/>aspnetcore</a></li><li><a href=https://andydote.co.uk/tags/dotnetcore/>dotnetcore</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2017/10/02/dotnet-core-docker-integration-tests/><span class=title>« Prev Page</span><br><span>Integration Testing with Dotnet Core, Docker and RabbitMQ</span></a>
<a class=next href=https://andydote.co.uk/2017/09/17/testing-containers/><span class=title>Next Page »</span><br><span>Testing Containers or Test Behaviour, Not Implementation</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>