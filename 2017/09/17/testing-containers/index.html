<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Testing Containers or Test Behaviour, Not Implementation | Andy Dote</title>
<meta name=keywords content="design,structuremap,testing"><meta name=description content="The trouble with testing containers is that usually the test ends up very tightly coupled to the implementation.
Let&rsquo;s see an example. If we start off with an interface and implementation of a &ldquo;cache&rdquo;, which in this case is just going to store a single string value.
public interface ICache { string Value { get; set; } } public class Cache { public string Value { get; set; } } We then setup our container (StructureMap in this case) to return the same instance of the cache whenever an ICache is requested:"><meta name=author content><link rel=canonical href=https://andydote.co.uk/2017/09/17/testing-containers/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.c6a36963ab47314b3d95fe85a9385337e1ef8eb1c2194eecb86f178d492ab666.js integrity="sha256-xqNpY6tHMUs9lf6FqThTN+HvjrHCGU7suG8XjUkqtmY="></script><script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script><link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Testing Containers or Test Behaviour, Not Implementation"><meta property="og:description" content="The trouble with testing containers is that usually the test ends up very tightly coupled to the implementation.
Let&rsquo;s see an example. If we start off with an interface and implementation of a &ldquo;cache&rdquo;, which in this case is just going to store a single string value.
public interface ICache { string Value { get; set; } } public class Cache { public string Value { get; set; } } We then setup our container (StructureMap in this case) to return the same instance of the cache whenever an ICache is requested:"><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2017/09/17/testing-containers/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-09-17T00:00:00+00:00"><meta property="article:modified_time" content="2017-09-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Testing Containers or Test Behaviour, Not Implementation"><meta name=twitter:description content="The trouble with testing containers is that usually the test ends up very tightly coupled to the implementation.
Let&rsquo;s see an example. If we start off with an interface and implementation of a &ldquo;cache&rdquo;, which in this case is just going to store a single string value.
public interface ICache { string Value { get; set; } } public class Cache { public string Value { get; set; } } We then setup our container (StructureMap in this case) to return the same instance of the cache whenever an ICache is requested:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Testing Containers or Test Behaviour, Not Implementation","item":"https://andydote.co.uk/2017/09/17/testing-containers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Testing Containers or Test Behaviour, Not Implementation","name":"Testing Containers or Test Behaviour, Not Implementation","description":"The trouble with testing containers is that usually the test ends up very tightly coupled to the implementation.\nLet\u0026rsquo;s see an example. If we start off with an interface and implementation of a \u0026ldquo;cache\u0026rdquo;, which in this case is just going to store a single string value.\npublic interface ICache { string Value { get; set; } } public class Cache { public string Value { get; set; } } We then setup our container (StructureMap in this case) to return the same instance of the cache whenever an ICache is requested:","keywords":["design","structuremap","testing"],"articleBody":"The trouble with testing containers is that usually the test ends up very tightly coupled to the implementation.\nLet’s see an example. If we start off with an interface and implementation of a “cache”, which in this case is just going to store a single string value.\npublic interface ICache { string Value { get; set; } } public class Cache { public string Value { get; set; } } We then setup our container (StructureMap in this case) to return the same instance of the cache whenever an ICache is requested:\nvar container = new Container(_ =\u003e { _.For().Use().Singleton(); }); The following test is fairly typical of how this behaviour gets verified - it just compares that the same instance was returned by the container:\nvar first = container.GetInstance(); var second = container.GetInstance(); first.ShouldBe(second); But this is a very brittle test, as it is assuming that ICache will actually be the singleton. However in the future, we might add in a decorator, or make the cache a totally different style of implementation which isn’t singleton based.\nFor example, if we were to include a decorator class, which just logs reads and writes to the console:\npublic class LoggingCache : ICache { private readonly Cache _backingCache; public LoggingCache(Cache backingCache) { _backingCache = backingCache; } public string Value { get { Console.WriteLine(\"Value fetched\"); return _backingCache.Value; } set { Console.Write($\"Value changed from {_backingCache.Value} to {value}\"); _backingCache.Value = value; } } } Which will change our container registration:\nvar container = new Container(_ =\u003e { _.ForSingletonOf(); _.For().Use(); }); The test will now fail, or need changing to match the new implementation. This shows two things:\nTests are tightly coupled to the implementation Tests are testing the implementation, not the intent. Testing intent, not implementation Instead of checking if we get the same class instances back from the container, it would make for more sense to check the classes behave as expected. For my “super stupid cache” example this could take the following form:\nvar first = container.GetInstance(); var second = container.GetInstance(); first.Value = \"testing\"; second.Value.ShouldBe(\"testing\"); Not only does this test validate the behaviour of the classes, but it is far less brittle - we can change what the container returns entirely for ICache, as long as it behaves the same.\nBut what do you think? How do you go about testing behaviour?\n","wordCount":"389","inLanguage":"en","datePublished":"2017-09-17T00:00:00Z","dateModified":"2017-09-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2017/09/17/testing-containers/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Testing Containers or Test Behaviour, Not Implementation</h1><div class=post-meta>&lt;span title='2017-09-17 00:00:00 +0000 UTC'>September 17, 2017&lt;/span>&amp;nbsp;·&amp;nbsp;2 min</div></header><div class=post-content><p>The trouble with testing containers is that usually the test ends up very tightly coupled to the implementation.</p><p>Let&rsquo;s see an example. If we start off with an interface and implementation of a &ldquo;cache&rdquo;, which in this case is just going to store a single string value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ICache</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> Value { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Cache</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Value { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We then setup our container (<a href=http://structuremap.github.io>StructureMap</a> in this case) to return the same instance of the cache whenever an <code>ICache</code> is requested:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> container = <span style=color:#66d9ef>new</span> Container(_ =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _.For&lt;ICache&gt;().Use&lt;Cache&gt;().Singleton();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>The following test is fairly typical of how this behaviour gets verified - it just compares that the same instance was returned by the container:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> first = container.GetInstance&lt;ICache&gt;();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> second = container.GetInstance&lt;ICache&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>first.ShouldBe(second);
</span></span></code></pre></div><p>But this is a very brittle test, as it is assuming that <code>ICache</code> will actually be the singleton. However in the future, we might add in a decorator, or make the cache a totally different style of implementation which isn&rsquo;t singleton based.</p><p>For example, if we were to include a decorator class, which just logs reads and writes to the console:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggingCache</span> : ICache
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Cache _backingCache;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> LoggingCache(Cache backingCache)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _backingCache = backingCache;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Value
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>get</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Value fetched&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> _backingCache.Value;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>set</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.Write(<span style=color:#e6db74>$&#34;Value changed from {_backingCache.Value} to {value}&#34;</span>);
</span></span><span style=display:flex><span>            _backingCache.Value = <span style=color:#66d9ef>value</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Which will change our container registration:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> container = <span style=color:#66d9ef>new</span> Container(_ =&gt; {
</span></span><span style=display:flex><span>    _.ForSingletonOf&lt;Cache&gt;();
</span></span><span style=display:flex><span>    _.For&lt;ICache&gt;().Use&lt;LoggingCache&gt;();
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>The test will now fail, or need changing to match the new implementation. This shows two things:</p><ul><li>Tests are tightly coupled to the implementation</li><li>Tests are testing the implementation, not the intent.</li></ul><h2 id=testing-intent-not-implementation>Testing intent, not implementation<a hidden class=anchor aria-hidden=true href=#testing-intent-not-implementation>#</a></h2><p>Instead of checking if we get the same class instances back from the container, it would make for more sense to check the classes <em>behave</em> as expected. For my &ldquo;super stupid cache&rdquo; example this could take the following form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> first = container.GetInstance&lt;ICache&gt;();
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> second = container.GetInstance&lt;ICache&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>first.Value = <span style=color:#e6db74>&#34;testing&#34;</span>;
</span></span><span style=display:flex><span>second.Value.ShouldBe(<span style=color:#e6db74>&#34;testing&#34;</span>);
</span></span></code></pre></div><p>Not only does this test validate the behaviour of the classes, but it is far less brittle - we can change what the container returns entirely for <code>ICache</code>, as long as it behaves the same.</p><p>But what do you think? How do you go about testing behaviour?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/structuremap/>structuremap</a></li><li><a href=https://andydote.co.uk/tags/testing/>testing</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2017/09/22/implemeting-custom-aspnetcore-modelbinders/><span class=title>« Prev Page</span><br><span>Implementing Custom Aspnet Core ModelBinders</span>
</a><a class=next href=https://andydote.co.uk/2017/09/09/repositories-revisited/><span class=title>Next Page »</span><br><span>Repositories Revisited (and why CQRS is better)</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>