<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Integration Testing with Dotnet Core, Docker and RabbitMQ | Andy Dote</title><meta name=keywords content="dotnetcore,rabbitmq,docker,testing"><meta name=description content="When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.
For one of my libraries (RabbitHarness) I have a set of tests which check it behaves as expected against a real instance of RabbitMQ. Ideally these tests will always be run, but sometimes RabbitMQ just isn&rsquo;t available such as when running on AppVeyor builds, or if I haven&rsquo;t started my local RabbitMQ Docker container."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2017/10/02/dotnet-core-docker-integration-tests/><link crossorigin=anonymous href=/assets/css/stylesheet.min.d3aaf8cdcec9a6487824ab95cadf08232ec362e7ba510c6b742973d16ef5b72e.css integrity="sha256-06r4zc7Jpkh4JKuVyt8IIy7DYue6UQxrdClz0W71ty4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Integration Testing with Dotnet Core, Docker and RabbitMQ"><meta property="og:description" content="When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.
For one of my libraries (RabbitHarness) I have a set of tests which check it behaves as expected against a real instance of RabbitMQ. Ideally these tests will always be run, but sometimes RabbitMQ just isn&rsquo;t available such as when running on AppVeyor builds, or if I haven&rsquo;t started my local RabbitMQ Docker container."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2017/10/02/dotnet-core-docker-integration-tests/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-10-02T00:00:00+00:00"><meta property="article:modified_time" content="2017-10-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Integration Testing with Dotnet Core, Docker and RabbitMQ"><meta name=twitter:description content="When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.
For one of my libraries (RabbitHarness) I have a set of tests which check it behaves as expected against a real instance of RabbitMQ. Ideally these tests will always be run, but sometimes RabbitMQ just isn&rsquo;t available such as when running on AppVeyor builds, or if I haven&rsquo;t started my local RabbitMQ Docker container."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Integration Testing with Dotnet Core, Docker and RabbitMQ","item":"https://andydote.co.uk/2017/10/02/dotnet-core-docker-integration-tests/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Integration Testing with Dotnet Core, Docker and RabbitMQ","name":"Integration Testing with Dotnet Core, Docker and RabbitMQ","description":"When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.\nFor one of my libraries (RabbitHarness) I have a set of tests which check it behaves as expected against a real instance of RabbitMQ. Ideally these tests will always be run, but sometimes RabbitMQ just isn\u0026rsquo;t available such as when running on AppVeyor builds, or if I haven\u0026rsquo;t started my local RabbitMQ Docker container.","keywords":["dotnetcore","rabbitmq","docker","testing"],"articleBody":"When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.\nFor one of my libraries (RabbitHarness) I have a set of tests which check it behaves as expected against a real instance of RabbitMQ. Ideally these tests will always be run, but sometimes RabbitMQ just isn’t available such as when running on AppVeyor builds, or if I haven’t started my local RabbitMQ Docker container.\nSkipping tests if RabbitMQ is not available First off, I prevent the tests from running if RabbitMQ is not available by using a custom XUnit FactAttribute:\npublic class RequiresRabbitFactAttribute : FactAttribute { private static readonly Lazy\u003cbool\u003e IsAvailable = new Lazy\u003cbool\u003e(() =\u003e { var factory = new ConnectionFactory { HostName = \"localhost\", RequestedConnectionTimeout = 1000 }; try { using (var connection = factory.CreateConnection()) return connection.IsOpen; } catch (Exception) { return false; } }); public override string Skip { get { return IsAvailable.Value ? \"\" : \"RabbitMQ is not available\"; } set { /* nothing */ } } } This attribute will try connecting to a RabbitMQ instance on localhost once for all tests per run, and cause any test with this attribute to be skipped if RabbitMQ is not available.\nBuild Script \u0026 Docker I decided the build script should start a RabbitMQ container, and use that for the tests, but I didn’t want to re-use my standard RabbitMQ instance which I use for all kinds of things, and may well be broken at any given time.\nAs my build script is just a bash script, I can check if the docker command is available, and then start a container if it is (relying on the assumption that if docker is available, I can start a container).\nif [ -x \"$(command -v docker)\" ]; then CONTAINER=$(docker run -d --rm -p 5672:5672 rabbitmq:3.6.11-alpine) echo \"Started RabbitMQ container: $CONTAINER\" fi If docker is available, we start a new container. I use rabbitmq:3.6.11-alpine as it is a tiny image, with no frills, and also start it with the -d and --rm flags, which starts the container in a disconnected mode (e.g. the docker run command returns instantly), and will delete the container when it is stopped, taking care of clean up for us! I only bother binding the main data connection port (5672), as that is all we are going to be using. Finally, the container’s ID, which is returned by the docker run command, is stored in the CONTAINER variable.\nI recommend putting this step as the very first part of your build script, as it gives the container time to start up RabbitMQ and be ready for connections while your build is running. Otherwise I found I was needing to put a sleep 5 command in afterwards to pause the script for a short time.\nThe script then continues on with the normal build process:\ndotnet restore \"$NAME.sln\" dotnet build \"$NAME.sln\" --configuration $MODE find . -iname \"*.Tests.csproj\" -type f -exec dotnet test \"{}\" --configuration $MODE \\; dotnet pack ./src/$NAME --configuration $MODE --output ../../.build Once this is all done, I have another check that docker exists, and stop the container we started earlier, by using the container ID in CONTAINER:\nif [ -x \"$(command -v docker)\" ]; then docker stop $CONTAINER fi And that’s it! You can see the full build script for RabbitHarness here.\nThe only problem with this script is if you try and start a RabbitMQ container while you already have one running, the command will fail, but the build should succeed anyway as the running instance of RabbitMQ will work for the tests, and the docker stop command will just output that it can’t find a container with a blank ID.\nI think I will be using this technique more to help provide isolation for builds - I think that the Microsoft/mssql-server-linux containers might be very useful for some of our work codebases (which do work against the Linux instances of MSSQL, even if they weren’t designed to!)\n","wordCount":"668","inLanguage":"en","datePublished":"2017-10-02T00:00:00Z","dateModified":"2017-10-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2017/10/02/dotnet-core-docker-integration-tests/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Integration Testing with Dotnet Core, Docker and RabbitMQ</h1><div class=post-meta><span title='2017-10-02 00:00:00 +0000 UTC'>October 2, 2017</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>When building libraries, not only is it a good idea to have a large suite of Unit Tests, but also a suite of Integration Tests.</p><p>For one of my libraries (<a href=https://github.com/pondidum/rabbitharness>RabbitHarness</a>) I have a set of tests which check it behaves as expected against a real instance of <a href=http://www.rabbitmq.com/>RabbitMQ</a>. Ideally these tests will always be run, but sometimes RabbitMQ just isn&rsquo;t available such as when running on <a href=https://ci.appveyor.com/project/Pondidum/rabbitharness>AppVeyor</a> builds, or if I haven&rsquo;t started my local RabbitMQ Docker container.</p><h2 id=skipping-tests-if-rabbitmq-is-not-available>Skipping tests if RabbitMQ is not available<a hidden class=anchor aria-hidden=true href=#skipping-tests-if-rabbitmq-is-not-available>#</a></h2><p>First off, I prevent the tests from running if RabbitMQ is not available by using a custom <a href=https://xunit.github.io/>XUnit</a> <code>FactAttribute</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RequiresRabbitFactAttribute</span> : FactAttribute
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> Lazy&lt;<span style=color:#66d9ef>bool</span>&gt; IsAvailable = <span style=color:#66d9ef>new</span> Lazy&lt;<span style=color:#66d9ef>bool</span>&gt;(() =&gt;
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> factory = <span style=color:#66d9ef>new</span> ConnectionFactory { HostName = <span style=color:#e6db74>&#34;localhost&#34;</span>, RequestedConnectionTimeout = <span style=color:#ae81ff>1000</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> connection = factory.CreateConnection())
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> connection.IsOpen;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>catch</span> (Exception)
</span></span><span style=display:flex><span>		{
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>string</span> Skip
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>get</span> { <span style=color:#66d9ef>return</span> IsAvailable.Value ? <span style=color:#e6db74>&#34;&#34;</span> : <span style=color:#e6db74>&#34;RabbitMQ is not available&#34;</span>;  }
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>set</span> { <span style=color:#75715e>/* nothing */</span> }
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This attribute will try connecting to a RabbitMQ instance on <code>localhost</code> once for all tests per run, and cause any test with this attribute to be skipped if RabbitMQ is not available.</p><h2 id=build-script--docker>Build Script & Docker<a hidden class=anchor aria-hidden=true href=#build-script--docker>#</a></h2><p>I decided the build script should start a RabbitMQ container, and use that for the tests, but I didn&rsquo;t want to re-use my standard RabbitMQ instance which I use for all kinds of things, and may well be broken at any given time.</p><p>As my build script is just a <code>bash</code> script, I can check if the <code>docker</code> command is available, and then start a container if it is (relying on the assumption that if <code>docker</code> is available, I can start a container).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -x <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>command -v docker<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  CONTAINER<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>docker run -d --rm -p 5672:5672 rabbitmq:3.6.11-alpine<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;Started RabbitMQ container: </span>$CONTAINER<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>If <code>docker</code> is available, we start a new container. I use <code>rabbitmq:3.6.11-alpine</code> as it is a tiny image, with no frills, and also start it with the <code>-d</code> and <code>--rm</code> flags, which starts the container in a disconnected mode (e.g. the <code>docker run</code> command returns instantly), and will delete the container when it is stopped, taking care of clean up for us! I only bother binding the main data connection port (<code>5672</code>), as that is all we are going to be using. Finally, the container&rsquo;s ID, which is returned by the <code>docker run</code> command, is stored in the <code>CONTAINER</code> variable.</p><p>I recommend putting this step as the very first part of your build script, as it gives the container time to start up RabbitMQ and be ready for connections while your build is running. Otherwise I found I was needing to put a <code>sleep 5</code> command in afterwards to pause the script for a short time.</p><p>The script then continues on with the normal build process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dotnet restore <span style=color:#e6db74>&#34;</span>$NAME<span style=color:#e6db74>.sln&#34;</span>
</span></span><span style=display:flex><span>dotnet build <span style=color:#e6db74>&#34;</span>$NAME<span style=color:#e6db74>.sln&#34;</span> --configuration $MODE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>find . -iname <span style=color:#e6db74>&#34;*.Tests.csproj&#34;</span> -type f -exec dotnet test <span style=color:#e6db74>&#34;{}&#34;</span> --configuration $MODE <span style=color:#ae81ff>\;</span>
</span></span><span style=display:flex><span>dotnet pack ./src/$NAME --configuration $MODE --output ../../.build
</span></span></code></pre></div><p>Once this is all done, I have another check that <code>docker</code> exists, and stop the container we started earlier, by using the container ID in <code>CONTAINER</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>[</span> -x <span style=color:#e6db74>&#34;</span><span style=color:#66d9ef>$(</span>command -v docker<span style=color:#66d9ef>)</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>  docker stop $CONTAINER
</span></span><span style=display:flex><span><span style=color:#66d9ef>fi</span>
</span></span></code></pre></div><p>And that&rsquo;s it! You can see the full <a href=https://github.com/Pondidum/RabbitHarness/blob/master/build.sh>build script for RabbitHarness here</a>.</p><p>The only problem with this script is if you try and start a RabbitMQ container while you already have one running, the command will fail, but the build should succeed anyway as the running instance of RabbitMQ will work for the tests, and the <code>docker stop</code> command will just output that it can&rsquo;t find a container with a blank ID.</p><p>I think I will be using this technique more to help provide isolation for builds - I think that the <a href=https://hub.docker.com/r/microsoft/mssql-server-linux/>Microsoft/mssql-server-linux</a> containers might be very useful for some of our work codebases (which do work against the Linux instances of MSSQL, even if they weren&rsquo;t designed to!)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/dotnetcore/>dotnetcore</a></li><li><a href=https://andydote.co.uk/tags/rabbitmq/>rabbitmq</a></li><li><a href=https://andydote.co.uk/tags/docker/>docker</a></li><li><a href=https://andydote.co.uk/tags/testing/>testing</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2017/10/04/structuremap-composite-decorator/><span class=title>« Prev Page</span><br><span>Composite Decorators with StructureMap</span></a>
<a class=next href=https://andydote.co.uk/2017/09/22/implemeting-custom-aspnetcore-modelbinders/><span class=title>Next Page »</span><br><span>Implementing Custom Aspnet Core ModelBinders</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>