<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Serilog LogContext with StructureMap and SimpleInjector | Andy Dote</title><meta name=keywords content="c#,structuremap,simpleinjector,di,ioc"><meta name=description content="This article has been updated after feedback from .Net Junkie (Godfather of SimpleInjector). I now have a working SimpleInjector implementation of this, and am very appreciative of him for taking the time to help me :)
Serilog is one of the main set of libraries I use on a regular basis, and while it is great at logging, it does cause something in our codebase that I am less happy about."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2017/07/28/serilog-context-with-structuremap-and-simpleinjector/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2b33c247bf6959372dd097f2cfdcd9f4d5019027cd9b1e28ae3d14c17c37ac00.css integrity="sha256-KzPCR79pWTct0Jfyz9zZ9NUBkCfNmx4orj0UwXw3rAA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/mermaid.min.725f44bd345b0a2a4043ca952b0863edd789e913cf0813a12bbdfe986fe87079.js integrity="sha256-cl9EvTRbCipAQ8qVKwhj7deJ6RPPCBOhK73+mG/ocHk="></script>
<script defer crossorigin=anonymous src=/js/tabs.min.2d019e9ee3574770ad4ecfd4f5f794739892195cb82a4e6383252b9074ab520c.js integrity="sha256-LQGenuNXR3CtTs/U9feUc5iSGVy4Kk5jgyUrkHSrUgw="></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Serilog LogContext with StructureMap and SimpleInjector"><meta property="og:description" content="This article has been updated after feedback from .Net Junkie (Godfather of SimpleInjector). I now have a working SimpleInjector implementation of this, and am very appreciative of him for taking the time to help me :)
Serilog is one of the main set of libraries I use on a regular basis, and while it is great at logging, it does cause something in our codebase that I am less happy about."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2017/07/28/serilog-context-with-structuremap-and-simpleinjector/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-07-28T00:00:00+00:00"><meta property="article:modified_time" content="2017-07-28T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Serilog LogContext with StructureMap and SimpleInjector"><meta name=twitter:description content="This article has been updated after feedback from .Net Junkie (Godfather of SimpleInjector). I now have a working SimpleInjector implementation of this, and am very appreciative of him for taking the time to help me :)
Serilog is one of the main set of libraries I use on a regular basis, and while it is great at logging, it does cause something in our codebase that I am less happy about."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Serilog LogContext with StructureMap and SimpleInjector","item":"https://andydote.co.uk/2017/07/28/serilog-context-with-structuremap-and-simpleinjector/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Serilog LogContext with StructureMap and SimpleInjector","name":"Serilog LogContext with StructureMap and SimpleInjector","description":"This article has been updated after feedback from .Net Junkie (Godfather of SimpleInjector). I now have a working SimpleInjector implementation of this, and am very appreciative of him for taking the time to help me :)\nSerilog is one of the main set of libraries I use on a regular basis, and while it is great at logging, it does cause something in our codebase that I am less happy about.","keywords":["c#","structuremap","simpleinjector","di","ioc"],"articleBody":"This article has been updated after feedback from .Net Junkie (Godfather of SimpleInjector). I now have a working SimpleInjector implementation of this, and am very appreciative of him for taking the time to help me :)\nSerilog is one of the main set of libraries I use on a regular basis, and while it is great at logging, it does cause something in our codebase that I am less happy about. Take the following snippet for example:\npublic class Something { private static readonly ILogger Log = Log.ForContext(typeof(Something)); } There are two things I don’t like about this. The first is the static field access: We have tests which assert on log content for disallowed information, or to include a correlationid etc. Having a static field means that if tests run in parallel, we end up with flaky tests due to multiple log messages being written. The second thing I don’t like is less about the line itself, but the repetition of this line throughout the codebase. Nearly every class which does logging has the same line, but with the type parameter changed.\nI set out to see if I could remedy both problems at once.\nFixing the Static Field The first fix is to inject the logger in via a constructor argument, which will allow tests to use their own version of the logger:\npublic class Something { private readonly ILogger _log; public Something(ILogger logger) { _log = logger.ForContext(typeof(Something)); } } That was easy! Now on to the hard part; removing the repeated .ForContext call.\nFixing the ForContext Repetition Most (if not all) the applications I build use a dependency injection container to build objects. In my opinion there are only two containers which are worth considering in the .net space: StructureMap, and SimpleInjector. If you like convention based registration, use StructureMap. If you like to get a safety net that prevents and detects common misconfigurations, use SimpleInjector.\nTests We can use the same tests to verify the behaviour both when using StructureMap and SimpleInjector’s. We have a couple of test classes, and an interface to allow for more generic testing:\nprivate interface ILogOwner { ILogger Logger { get; } } private class Something : ILogOwner { public ILogger Logger { get; } public Something(ILogger logger) { Logger = logger; } } private class Everything : ILogOwner { public ILogger Logger { get; } public Everything(ILogger logger) { Logger = logger; } } And then a single parameterised test method for verification:\npublic class Tests { private readonly Container _container; public Tests() { Log.Logger = new LoggerConfiguration() .MinimumLevel.Debug() .WriteTo.Console() .CreateLogger(); // _container = new ... } [Theory] [InlineData(typeof(Something))] [InlineData(typeof(Everything))] public void Types_get_their_own_context(Type type) { var instance = (ILogOwner)_container.GetInstance(type); var context = GetContextFromLogger(instance); context.ShouldBe(type.FullName); } private static string GetContextFromLogger(ILogOwner owner) { var logEvent = CreateLogEvent(); owner.Logger.Write(logEvent); return logEvent.Properties[\"SourceContext\"].ToString().Trim('\"'); } private static LogEvent CreateLogEvent() =\u003e new LogEvent( DateTimeOffset.Now, LogEventLevel.Debug, null, new MessageTemplate(\"\", Enumerable.Empty()), Enumerable.Empty()); } StructureMap The StructureMap initialisation just requires a single line change to use the construction context when creating a logger:\n_container = new Container(_ =\u003e { _.Scan(a =\u003e { a.TheCallingAssembly(); a.WithDefaultConventions(); }); // original: // _.For().Use(context =\u003e Log.Logger); // contextual _.For().Use(context =\u003e Log.ForContext(context.ParentType)); }); SimpleInjector SimpleInjector does a lot of verification of your container configuration, and as such deals mostly with Types, rather than instances, or types which have multiple mappings as we are doing. This makes it slightly harder to support the behaviour we had with StructureMap, but not impossible. A huge thanks to .Net Junkie for assisting with this!\nFirst we need to create an implementation of IDependencyInjectionBehavior, which will handle our ILogger type requests, and pass all other types requests to the standard implementation:\nclass SerilogContextualLoggerInjectionBehavior : IDependencyInjectionBehavior { private readonly IDependencyInjectionBehavior _original; private readonly Container _container; public SerilogContextualLoggerInjectionBehavior(ContainerOptions options) { _original = options.DependencyInjectionBehavior; _container = options.Container; } public void Verify(InjectionConsumerInfo consumer) =\u003e _original.Verify(consumer); public InstanceProducer GetInstanceProducer(InjectionConsumerInfo i, bool t) =\u003e i.Target.TargetType == typeof(ILogger) ? GetLoggerInstanceProducer(i.ImplementationType) : _original.GetInstanceProducer(i, t); private InstanceProducer GetLoggerInstanceProducer(Type type) =\u003e Lifestyle.Transient.CreateProducer(() =\u003e Log.ForContext(type), _container); } This can then be set in our container setup:\n_ontainer = new Container(); _container.Options.DependencyInjectionBehavior = new SerilogContextualLoggerInjectionBehavior(_container.Options); _container.Register(); _container.Register(); And now our tests pass!\nOutcomes Thanks to this container usage, I no longer have to have the .ForContext(typeof(Something)) scattered throughout my codebases.\nHopefully this shows how taking away just some of the little tasks makes life easier - I now no longer have to remember to do the .ForContext on each class, and don’t need to have tests to validate it is done on each class (I have one test in my container configuration tests which validates this behaviour instead).\n","wordCount":"765","inLanguage":"en","datePublished":"2017-07-28T00:00:00Z","dateModified":"2017-07-28T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2017/07/28/serilog-context-with-structuremap-and-simpleinjector/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Serilog LogContext with StructureMap and SimpleInjector</h1><div class=post-meta><span title='2017-07-28 00:00:00 +0000 UTC'>July 28, 2017</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p><em>This article has been updated after feedback from <a href=https://twitter.com/dot_NET_Junkie>.Net Junkie</a> (Godfather of SimpleInjector). I now have a working SimpleInjector implementation of this, and am very appreciative of him for taking the time to help me :)</em></p><p>Serilog is one of the main set of libraries I use on a regular basis, and while it is great at logging, it does cause something in our codebase that I am less happy about. Take the following snippet for example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> ILogger Log = Log.ForContext(<span style=color:#66d9ef>typeof</span>(Something));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There are two things I don&rsquo;t like about this. The first is the static field access: We have tests which assert on log content for disallowed information, or to include a correlationid etc. Having a static field means that if tests run in parallel, we end up with flaky tests due to multiple log messages being written. The second thing I don&rsquo;t like is less about the line itself, but the repetition of this line throughout the codebase. Nearly every class which does logging has the same line, but with the type parameter changed.</p><p>I set out to see if I could remedy both problems at once.</p><h2 id=fixing-the-static-field>Fixing the Static Field<a hidden class=anchor aria-hidden=true href=#fixing-the-static-field>#</a></h2><p>The first fix is to inject the logger in via a constructor argument, which will allow tests to use their own version of the logger:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> ILogger _log;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Something(ILogger logger)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _log = logger.ForContext(<span style=color:#66d9ef>typeof</span>(Something));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That was easy! Now on to the hard part; removing the repeated <code>.ForContext</code> call.</p><h2 id=fixing-the-forcontext-repetition>Fixing the ForContext Repetition<a hidden class=anchor aria-hidden=true href=#fixing-the-forcontext-repetition>#</a></h2><p>Most (if not all) the applications I build use a dependency injection container to build objects. In my opinion there are only two containers which are worth considering in the .net space: <a href=http://structuremap.github.io/>StructureMap</a>, and <a href=https://simpleinjector.org>SimpleInjector</a>. If you like convention based registration, use StructureMap. If you like to get a safety net that prevents and detects common misconfigurations, use SimpleInjector.</p><h3 id=tests>Tests<a hidden class=anchor aria-hidden=true href=#tests>#</a></h3><p>We can use the same tests to verify the behaviour both when using StructureMap and SimpleInjector&rsquo;s. We have a couple of test classes, and an interface to allow for more generic testing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ILogOwner</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ILogger Logger { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Something</span> : ILogOwner
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ILogger Logger { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Something(ILogger logger)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Logger = logger;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Everything</span> : ILogOwner
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ILogger Logger { <span style=color:#66d9ef>get</span>; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Everything(ILogger logger)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Logger = logger;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And then a single parameterised test method for verification:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tests</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Container _container;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Tests()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Log.Logger = <span style=color:#66d9ef>new</span> LoggerConfiguration()
</span></span><span style=display:flex><span>            .MinimumLevel.Debug()
</span></span><span style=display:flex><span>            .WriteTo.Console()
</span></span><span style=display:flex><span>            .CreateLogger();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// _container = new ...</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [Theory]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [InlineData(typeof(Something))]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [InlineData(typeof(Everything))]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Types_get_their_own_context(Type type)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> instance = (ILogOwner)_container.GetInstance(type);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> context = GetContextFromLogger(instance);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        context.ShouldBe(type.FullName);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>string</span> GetContextFromLogger(ILogOwner owner)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> logEvent = CreateLogEvent();
</span></span><span style=display:flex><span>        owner.Logger.Write(logEvent);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> logEvent.Properties[<span style=color:#e6db74>&#34;SourceContext&#34;</span>].ToString().Trim(<span style=color:#e6db74>&#39;&#34;&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> LogEvent CreateLogEvent() =&gt; <span style=color:#66d9ef>new</span> LogEvent(
</span></span><span style=display:flex><span>        DateTimeOffset.Now,
</span></span><span style=display:flex><span>        LogEventLevel.Debug,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>null</span>,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> MessageTemplate(<span style=color:#e6db74>&#34;&#34;</span>, Enumerable.Empty&lt;MessageTemplateToken&gt;()),
</span></span><span style=display:flex><span>        Enumerable.Empty&lt;LogEventProperty&gt;());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=structuremap>StructureMap<a hidden class=anchor aria-hidden=true href=#structuremap>#</a></h3><p>The StructureMap initialisation just requires a single line change to use the construction context when creating a logger:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>_container = <span style=color:#66d9ef>new</span> Container(_ =&gt;
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    _.Scan(a =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        a.TheCallingAssembly();
</span></span><span style=display:flex><span>        a.WithDefaultConventions();
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// original:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// _.For&lt;ILogger&gt;().Use(context =&gt; Log.Logger);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// contextual</span>
</span></span><span style=display:flex><span>    _.For&lt;ILogger&gt;().Use(context =&gt; Log.ForContext(context.ParentType));
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=simpleinjector>SimpleInjector<a hidden class=anchor aria-hidden=true href=#simpleinjector>#</a></h3><p>SimpleInjector does a lot of verification of your container configuration, and as such deals mostly with Types, rather than instances, or types which have multiple mappings as we are doing. This makes it slightly harder to support the behaviour we had with StructureMap, but not impossible. A huge thanks to .Net Junkie for assisting with this!</p><p>First we need to create an implementation of <code>IDependencyInjectionBehavior</code>, which will handle our <code>ILogger</code> type requests, and pass all other types requests to the standard implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SerilogContextualLoggerInjectionBehavior</span> : IDependencyInjectionBehavior
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IDependencyInjectionBehavior _original;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> Container _container;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> SerilogContextualLoggerInjectionBehavior(ContainerOptions options)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _original = options.DependencyInjectionBehavior;
</span></span><span style=display:flex><span>        _container = options.Container;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Verify(InjectionConsumerInfo consumer) =&gt; _original.Verify(consumer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> InstanceProducer GetInstanceProducer(InjectionConsumerInfo i, <span style=color:#66d9ef>bool</span> t) =&gt;
</span></span><span style=display:flex><span>        i.Target.TargetType == <span style=color:#66d9ef>typeof</span>(ILogger)
</span></span><span style=display:flex><span>            ? GetLoggerInstanceProducer(i.ImplementationType)
</span></span><span style=display:flex><span>            : _original.GetInstanceProducer(i, t);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> InstanceProducer&lt;ILogger&gt; GetLoggerInstanceProducer(Type type) =&gt;
</span></span><span style=display:flex><span>        Lifestyle.Transient.CreateProducer(() =&gt; Log.ForContext(type), _container);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This can then be set in our container setup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>_ontainer = <span style=color:#66d9ef>new</span> Container();
</span></span><span style=display:flex><span>_container.Options.DependencyInjectionBehavior = <span style=color:#66d9ef>new</span> SerilogContextualLoggerInjectionBehavior(_container.Options);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>_container.Register&lt;Something&gt;();
</span></span><span style=display:flex><span>_container.Register&lt;Everything&gt;();
</span></span></code></pre></div><p>And now our tests pass!</p><h2 id=outcomes>Outcomes<a hidden class=anchor aria-hidden=true href=#outcomes>#</a></h2><p>Thanks to this container usage, I no longer have to have the <code>.ForContext(typeof(Something))</code> scattered throughout my codebases.</p><p>Hopefully this shows how taking away just some of the little tasks makes life easier - I now no longer have to remember to do the <code>.ForContext</code> on each class, and don&rsquo;t need to have tests to validate it is done on each class (I have one test in my container configuration tests which validates this behaviour instead).</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/c#/>c#</a></li><li><a href=https://andydote.co.uk/tags/structuremap/>structuremap</a></li><li><a href=https://andydote.co.uk/tags/simpleinjector/>simpleinjector</a></li><li><a href=https://andydote.co.uk/tags/di/>di</a></li><li><a href=https://andydote.co.uk/tags/ioc/>ioc</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2017/09/09/repositories-revisited/><span class=title>« Prev Page</span><br><span>Repositories Revisited (and why CQRS is better)</span></a>
<a class=next href=https://andydote.co.uk/2017/07/15/getting-things-done/><span class=title>Next Page »</span><br><span>Getting Things Done</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>