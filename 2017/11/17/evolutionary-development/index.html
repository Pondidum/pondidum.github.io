<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Evolutionary Development | Andy Dote</title><meta name=keywords content="design,architecture,process"><meta name=description content="Having recently finished reading the Building Evolutionary Architectures: Support Constant Change book, I got to thinking about a system which was fairly representative of an architecture which was fine for it&rsquo;s initial version, but it&rsquo;s usage had outgrown the architecture.
Example System: Document Storage The system in question was a file store for a multi user, internal, desktop based CRM system. The number of users was very small, and the first implementation was just a network file share."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2017/11/17/evolutionary-development/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Evolutionary Development"><meta property="og:description" content="Having recently finished reading the Building Evolutionary Architectures: Support Constant Change book, I got to thinking about a system which was fairly representative of an architecture which was fine for it&rsquo;s initial version, but it&rsquo;s usage had outgrown the architecture.
Example System: Document Storage The system in question was a file store for a multi user, internal, desktop based CRM system. The number of users was very small, and the first implementation was just a network file share."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2017/11/17/evolutionary-development/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2017-11-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Evolutionary Development"><meta name=twitter:description content="Having recently finished reading the Building Evolutionary Architectures: Support Constant Change book, I got to thinking about a system which was fairly representative of an architecture which was fine for it&rsquo;s initial version, but it&rsquo;s usage had outgrown the architecture.
Example System: Document Storage The system in question was a file store for a multi user, internal, desktop based CRM system. The number of users was very small, and the first implementation was just a network file share."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Evolutionary Development","item":"https://andydote.co.uk/2017/11/17/evolutionary-development/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Evolutionary Development","name":"Evolutionary Development","description":"Having recently finished reading the Building Evolutionary Architectures: Support Constant Change book, I got to thinking about a system which was fairly representative of an architecture which was fine for it\u0026rsquo;s initial version, but it\u0026rsquo;s usage had outgrown the architecture.\nExample System: Document Storage The system in question was a file store for a multi user, internal, desktop based CRM system. The number of users was very small, and the first implementation was just a network file share.","keywords":["design","architecture","process"],"articleBody":"Having recently finished reading the Building Evolutionary Architectures: Support Constant Change book, I got to thinking about a system which was fairly representative of an architecture which was fine for it’s initial version, but it’s usage had outgrown the architecture.\nExample System: Document Storage The system in question was a file store for a multi user, internal, desktop based CRM system. The number of users was very small, and the first implementation was just a network file share. This was a fine solution to start with, but as the number of CRM users grew, cracks started to appear in the system.\nA few examples of problems seen were:\nConcurrent writes to the same files Finding files for a specific record in the CRM Response time Files “going missing” Storage size Data retention rules Most of this was caused by the number of file stored, which was well past the 5 million mark. For example, queries for “all files for x record” got slower and slower over time.\nSamba shares can’t be listed in date-modified order (you actually get all the file names, then sorting is applied), which means you can’t auto delete old files, or auto index (e.g. export text to elasticsearch) updated files easily.\nThe key to dealing with this problem is to take small steps - if you have a large throughput to support, the last thing you want to do is break it for everyone at once, by doing a “big bang” release.\nNot only can we take small steps in deploying our software, but we can also utilise Feature Toggles to make things safer. We can switch on a small part of the new system for a small percentage of users, and slowly ramp up usage while monitoring for errors.\nIncremental Replacement To replace this in an incremental manner, we are going to do the following 4 actions for every feature, until all features are done:\nImplement new feature in API and client Deploy client (toggle: off) Deploy API Start toggle roll out Now that we know how each feature is going to be delivered, we can write out our list of features, in a rough implementation order:\nCreate API, build scripts, CI and deployment pipeline Implement authentication on the API Implement fetching a list of files for a record Implement fetching a single file’s content for a record Implement storing a single file for a record Implement deletion of a single file for a record The development and deployment of our features can be overlapped too: we can be deploying the next version of the client with the next feature off while we are still rolling out the previous feature(s). This all assumes that your features are nice and isolated however!\nOnce this list of features is done, and all the toggles are on, from the client perspective we are feature complete.\nWe are free to change how the backend of the API works. As long as we don’t change the API’s contract, the client doesn’t need any more changes.\nOur next set of features could be:\nImplement audit log of API actions Publish store and delete events to a queue Change our indexing process to consume the store and delete events Make the samba hidden (except to the API) Implement background delete of old documents Move storage backend (to S3, for example) This list of features doesn’t impact the front end (client) system, but the backend systems can now have a more efficient usage of the file store. As with the client and initial API development, we would do this with a quick, iterative process.\nBut we can’t do iterative because… This is a common reaction when an iterative approach is suggested, and thankfully can be countered in a number of ways.\nFirst off, if this is an absolute requirement, we can do our iterations an feature toggling rollouts to another environment, such a Pre-Production, or QA. While this reduces some of the benefits (we loose out on live data ramp up), it does at least keep small chunks of work.\nAnother work around is to use feature toggles anyway, but only have a couple of “trusted” users use the new functionality. Depending on what you are releasing, this could mean a couple of users you know, or giving a few users a non-visible change (i.e. they’re not aware they’ve been selected!) You could also use NDA (Non Disclosure Agreements) if you need to keep them quiet, although this is quite an extreme measure.\nA final option is to use experiments, using an experimentation library (such as Github’s Scientist) which continues to use the existing features, but in parallel runs and records the results of the replacement feature. This obviously has to be done with care, as you don’t want to cause side effects.\nHow do you replace old software? Big bang, iterative, experimentation, or some other process?\n","wordCount":"814","inLanguage":"en","datePublished":"2017-11-17T00:00:00Z","dateModified":"2017-11-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2017/11/17/evolutionary-development/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Evolutionary Development</h1><div class=post-meta><span title='2017-11-17 00:00:00 +0000 UTC'>November 17, 2017</span>&nbsp;·&nbsp;4 min</div></header><div class=post-content><p>Having recently finished reading the <a href=https://www.goodreads.com/book/show/35755822-building-evolutionary-architectures>Building Evolutionary Architectures: Support Constant Change book</a>, I got to thinking about a system which was fairly representative of an architecture which was fine for it&rsquo;s initial version, but it&rsquo;s usage had outgrown the architecture.</p><h2 id=example-system-document-storage>Example System: Document Storage<a hidden class=anchor aria-hidden=true href=#example-system-document-storage>#</a></h2><p>The system in question was a file store for a multi user, internal, desktop based CRM system. The number of users was very small, and the first implementation was just a network file share. This was a fine solution to start with, but as the number of CRM users grew, cracks started to appear in the system.</p><p>A few examples of problems seen were:</p><ul><li>Concurrent writes to the same files</li><li>Finding files for a specific record in the CRM</li><li>Response time</li><li>Files &ldquo;going missing&rdquo;</li><li>Storage size</li><li>Data retention rules</li></ul><p>Most of this was caused by the number of file stored, which was well past the 5 million mark. For example, queries for &ldquo;all files for x record&rdquo; got slower and slower over time.</p><p>Samba shares can&rsquo;t be listed in date-modified order (you actually get all the file names, then sorting is applied), which means you can&rsquo;t auto delete old files, or auto index (e.g. export text to elasticsearch) updated files easily.</p><p>The key to dealing with this problem is to take small steps - if you have a large throughput to support, the last thing you want to do is break it for everyone at once, by doing a &ldquo;big bang&rdquo; release.</p><p>Not only can we take small steps in deploying our software, but we can also utilise Feature Toggles to make things safer. We can switch on a small part of the new system for a small percentage of users, and slowly ramp up usage while monitoring for errors.</p><h2 id=incremental-replacement>Incremental Replacement<a hidden class=anchor aria-hidden=true href=#incremental-replacement>#</a></h2><p>To replace this in an incremental manner, we are going to do the following 4 actions for every feature, until all features are done:</p><ol><li>Implement new feature in API and client</li><li>Deploy client (toggle: off)</li><li>Deploy API</li><li>Start toggle roll out</li></ol><p>Now that we know how each feature is going to be delivered, we can write out our list of features, in a rough implementation order:</p><ul><li>Create API, build scripts, CI and deployment pipeline</li><li>Implement authentication on the API</li><li>Implement fetching a list of files for a record</li><li>Implement fetching a single file&rsquo;s content for a record</li><li>Implement storing a single file for a record</li><li>Implement deletion of a single file for a record</li></ul><p>The development and deployment of our features can be overlapped too: we can be deploying the next version of the client with the next feature off while we are still rolling out the previous feature(s). This all assumes that your features are nice and isolated however!</p><p>Once this list of features is done, and all the toggles are on, from the client perspective we are feature complete.</p><p>We are free to change how the backend of the API works. As long as we don&rsquo;t change the API&rsquo;s contract, the client doesn&rsquo;t need any more changes.</p><p>Our next set of features could be:</p><ul><li>Implement audit log of API actions</li><li>Publish store and delete events to a queue</li><li>Change our indexing process to consume the store and delete events</li><li>Make the samba hidden (except to the API)</li><li>Implement background delete of old documents</li><li>Move storage backend (to S3, for example)</li></ul><p>This list of features doesn&rsquo;t impact the front end (client) system, but the backend systems can now have a more efficient usage of the file store. As with the client and initial API development, we would do this with a quick, iterative process.</p><h2 id=but-we-cant-do-iterative-because>But we can&rsquo;t do iterative because&mldr;<a hidden class=anchor aria-hidden=true href=#but-we-cant-do-iterative-because>#</a></h2><p>This is a common reaction when an iterative approach is suggested, and thankfully can be countered in a number of ways.</p><p>First off, if this is an absolute requirement, we can do our iterations an feature toggling rollouts to another environment, such a Pre-Production, or QA. While this reduces some of the benefits (we loose out on live data ramp up), it does at least keep small chunks of work.</p><p>Another work around is to use feature toggles anyway, but only have a couple of &ldquo;trusted&rdquo; users use the new functionality. Depending on what you are releasing, this could mean a couple of users you know, or giving a few users a non-visible change (i.e. they&rsquo;re not aware they&rsquo;ve been selected!) You could also use NDA (Non Disclosure Agreements) if you need to keep them quiet, although this is quite an extreme measure.</p><p>A final option is to use experiments, using an experimentation library (such as <a href=https://github.com/github/scientist>Github&rsquo;s Scientist</a>) which continues to use the existing features, but in parallel runs and records the results of the replacement feature. This obviously has to be done with care, as you don&rsquo;t want to cause side effects.</p><p>How do you replace old software? Big bang, iterative, experimentation, or some other process?</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/architecture/>architecture</a></li><li><a href=https://andydote.co.uk/tags/process/>process</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2017/12/09/tweaking-process-remove-errors/><span class=title>« Prev Page</span><br><span>Tweaking Processes to Remove Errors</span></a>
<a class=next href=https://andydote.co.uk/2017/11/09/configuration-composition/><span class=title>Next Page »</span><br><span>Strong Configuration Composition</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>