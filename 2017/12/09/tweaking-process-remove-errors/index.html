<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Tweaking Processes to Remove Errors | Andy Dote</title><meta name=keywords content="design,process"><meta name=description content="When we are developing (internal) Nuget packages at work, the process used is the following:
 Get latest of master New branch feature-SomethingDescriptive Implement feature Push to GitHub TeamCity builds Publish package to the nuget feed Pull request Merge to master  Obviously 3 to 6 can repeat many times if something doesn&rsquo;t work out quite right.
There are a number of problems with this process:
Pull-request after publishing Pull requests are a great tool which we use extensively, but in this case, they are being done too late."><meta name=author content><link rel=canonical href=https://andydote.co.uk/2017/12/09/tweaking-process-remove-errors/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b4e19c453811e60acfec1f00c15ac2be1c53f6ab90187e684358ce7faaf48bab.css integrity="sha256-tOGcRTgR5grP7B8AwVrCvhxT9quQGH5oQ1jOf6r0i6s=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://andydote.co.uk/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://andydote.co.uk/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://andydote.co.uk/favicon-32x32.png><link rel=apple-touch-icon href=https://andydote.co.uk/apple-touch-icon.png><link rel=mask-icon href=https://andydote.co.uk/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Tweaking Processes to Remove Errors"><meta property="og:description" content="When we are developing (internal) Nuget packages at work, the process used is the following:
 Get latest of master New branch feature-SomethingDescriptive Implement feature Push to GitHub TeamCity builds Publish package to the nuget feed Pull request Merge to master  Obviously 3 to 6 can repeat many times if something doesn&rsquo;t work out quite right.
There are a number of problems with this process:
Pull-request after publishing Pull requests are a great tool which we use extensively, but in this case, they are being done too late."><meta property="og:type" content="article"><meta property="og:url" content="https://andydote.co.uk/2017/12/09/tweaking-process-remove-errors/"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2017-12-09T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Tweaking Processes to Remove Errors"><meta name=twitter:description content="When we are developing (internal) Nuget packages at work, the process used is the following:
 Get latest of master New branch feature-SomethingDescriptive Implement feature Push to GitHub TeamCity builds Publish package to the nuget feed Pull request Merge to master  Obviously 3 to 6 can repeat many times if something doesn&rsquo;t work out quite right.
There are a number of problems with this process:
Pull-request after publishing Pull requests are a great tool which we use extensively, but in this case, they are being done too late."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://andydote.co.uk/post/"},{"@type":"ListItem","position":3,"name":"Tweaking Processes to Remove Errors","item":"https://andydote.co.uk/2017/12/09/tweaking-process-remove-errors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Tweaking Processes to Remove Errors","name":"Tweaking Processes to Remove Errors","description":"When we are developing (internal) Nuget packages at work, the process used is the following:\n Get latest of master New branch feature-SomethingDescriptive Implement feature Push to GitHub TeamCity builds Publish package to the nuget feed Pull request Merge to master  Obviously 3 to 6 can repeat many times if something doesn\u0026rsquo;t work out quite right.\nThere are a number of problems with this process:\nPull-request after publishing Pull requests are a great tool which we use extensively, but in this case, they are being done too late.","keywords":["design","process"],"articleBody":"When we are developing (internal) Nuget packages at work, the process used is the following:\n Get latest of master New branch feature-SomethingDescriptive Implement feature Push to GitHub TeamCity builds Publish package to the nuget feed Pull request Merge to master  Obviously 3 to 6 can repeat many times if something doesn’t work out quite right.\nThere are a number of problems with this process:\nPull-request after publishing Pull requests are a great tool which we use extensively, but in this case, they are being done too late. By the time another developer has reviewed something, possibly requesting changes, the package is published.\nPotentially broken packages published As packages are test-consumed from the main package feed, there is the chance that someone else is working on another code base, and decides to update the nuget which you have just published. Now they are pulling in a potentially broken, or unreviewed package.\nPublished package is not nessacarily what is on master Assuming the pull-request is approved with no changes, then the code is going to make it to master. However there is nothing to stop another developer’s changes getting to master first, and now you have a merge…and the published package doesn’t match what the source says it contains.\nFeature/version conflicts with multiple developers A few of our packages get updated fairly frequently, and there is a strong likelyhood that two developers are adding things to the same package. Both publish their package off their feature branch, and now someone’s changes have been “lost” as the latest package doesn’t have bother developer’s changes.\nSoltuon: Continuous Delivery / Master Based Development We can solve all of these issues by changing the process to be more “Trunk Based”:\n Get latest of master New branch feature-SomethingDescriptive Implement feature Push to GitHub Pull request TeamCity builds branch Merge to master TeamCity builds \u0026 publishes the package  All we have really changed here is to publish from master, rather than your feature branch. Now a pull-request has to happen (master branch is Protected in GitHub) before you can publish a package, meaning we have elimnated all of the issues with our previous process.\nExcept one, kind of.\nHow do developers test their new version of the package is correct from a different project? There are two solutions to this (and you could implement both):\n Publish package to a local nuget feed Publish packages from feature branches as -pre versions  The local nuget feed is super simple to implement: just use a directory e.g. I have /d/dev/local-packages/ defined in my machine’s nuget.config file. We use Gulp for our builds, so modifying our gulp publish task to publish locally when no arguments are specified would be trivial.\nThe publishing of Pre-release packages can also be implemented through our gulp scripts: we just need to adjust TeamCity to pass in the branch name to the gulp command (gulp ci --mode=Release --barnch \"%vcsroot.branch%\"), and we can modify the script to add the -pre flag to the version number if the branch parameter is not master.\nPersonally, I would use local publishing only, and implement the feature branch publishing if the package in question is consumed by multiple teams, and you would want an external team to be able to verify the changes made before a proper release.\nNow our developers can still test their package works from a consuming application, and not clutter the nuget feed with potentially broken packages.\n","wordCount":"569","inLanguage":"en","datePublished":"2017-12-09T00:00:00Z","dateModified":"2017-12-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://andydote.co.uk/2017/12/09/tweaking-process-remove-errors/"},"publisher":{"@type":"Organization","name":"Andy Dote","logo":{"@type":"ImageObject","url":"https://andydote.co.uk/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://andydote.co.uk accesskey=h title="Andy Dote (Alt + H)">Andy Dote</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://andydote.co.uk/archive title=Archive><span>Archive</span></a></li><li><a href=https://andydote.co.uk/talks title=Talks><span>Talks</span></a></li><li><a href=https://andydote.co.uk/notes title=Notes><span>Notes</span></a></li><li><a href=https://andydote.co.uk/tags title=Tags><span>Tags</span></a></li><li><a href=https://andydote.co.uk/contact title=Contact><span>Contact</span></a></li><li><a href=https://andydote.co.uk/rss.xml title=RSS><span>RSS</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Tweaking Processes to Remove Errors</h1><div class=post-meta><span title="2017-12-09 00:00:00 +0000 UTC">December 9, 2017</span>&nbsp;·&nbsp;3 min</div></header><div class=post-content><p>When we are developing (internal) Nuget packages at work, the process used is the following:</p><ol><li>Get latest of master</li><li>New branch <code>feature-SomethingDescriptive</code></li><li>Implement feature</li><li>Push to GitHub</li><li>TeamCity builds</li><li>Publish package to the nuget feed</li><li>Pull request</li><li>Merge to master</li></ol><p>Obviously <code>3</code> to <code>6</code> can repeat many times if something doesn&rsquo;t work out quite right.</p><p>There are a number of problems with this process:</p><h3 id=pull-request-after-publishing>Pull-request after publishing<a hidden class=anchor aria-hidden=true href=#pull-request-after-publishing>#</a></h3><p>Pull requests are a great tool which we use extensively, but in this case, they are being done too late. By the time another developer has reviewed something, possibly requesting changes, the package is published.</p><h3 id=potentially-broken-packages-published>Potentially broken packages published<a hidden class=anchor aria-hidden=true href=#potentially-broken-packages-published>#</a></h3><p>As packages are test-consumed from the main package feed, there is the chance that someone else is working on another code base, and decides to update the nuget which you have just published. Now they are pulling in a potentially broken, or unreviewed package.</p><h3 id=published-package-is-not-nessacarily-what-is-on-master>Published package is not nessacarily what is on master<a hidden class=anchor aria-hidden=true href=#published-package-is-not-nessacarily-what-is-on-master>#</a></h3><p>Assuming the pull-request is approved with no changes, then the code is going to make it to master. However there is nothing to stop another developer&rsquo;s changes getting to master first, and now you have a merge&mldr;and the published package doesn&rsquo;t match what the source says it contains.</p><h3 id=featureversion-conflicts-with-multiple-developers>Feature/version conflicts with multiple developers<a hidden class=anchor aria-hidden=true href=#featureversion-conflicts-with-multiple-developers>#</a></h3><p>A few of our packages get updated fairly frequently, and there is a strong likelyhood that two developers are adding things to the same package. Both publish their package off their feature branch, and now someone&rsquo;s changes have been &ldquo;lost&rdquo; as the latest package doesn&rsquo;t have bother developer&rsquo;s changes.</p><h2 id=soltuon-continuous-delivery--master-based-development>Soltuon: Continuous Delivery / Master Based Development<a hidden class=anchor aria-hidden=true href=#soltuon-continuous-delivery--master-based-development>#</a></h2><p>We can solve all of these issues by changing the process to be more &ldquo;Trunk Based&rdquo;:</p><ol><li>Get latest of master</li><li>New branch <code>feature-SomethingDescriptive</code></li><li>Implement feature</li><li>Push to GitHub</li><li>Pull request</li><li>TeamCity builds branch</li><li>Merge to master</li><li>TeamCity builds & publishes the package</li></ol><p>All we have really changed here is to publish from master, rather than your feature branch. Now a pull-request has to happen (master branch is Protected in GitHub) before you can publish a package, meaning we have elimnated all of the issues with our previous process.</p><p>Except one, kind of.</p><p>How do developers test their new version of the package is correct from a different project? There are two solutions to this (and you could implement both):</p><ul><li>Publish package to a local nuget feed</li><li>Publish packages from feature branches as <code>-pre</code> versions</li></ul><p>The local nuget feed is super simple to implement: just use a directory e.g. I have <code>/d/dev/local-packages/</code> defined in my machine&rsquo;s nuget.config file. We use Gulp for our builds, so modifying our <code>gulp publish</code> task to publish locally when no arguments are specified would be trivial.</p><p>The publishing of Pre-release packages can also be implemented through our gulp scripts: we just need to adjust TeamCity to pass in the branch name to the gulp command (<code>gulp ci --mode=Release --barnch "%vcsroot.branch%"</code>), and we can modify the script to add the <code>-pre</code> flag to the version number if the branch parameter is not <code>master</code>.</p><p>Personally, I would use local publishing only, and implement the feature branch publishing if the package in question is consumed by multiple teams, and you would want an external team to be able to verify the changes made before a proper release.</p><p>Now our developers can still test their package works from a consuming application, and not clutter the nuget feed with potentially broken packages.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://andydote.co.uk/tags/design/>design</a></li><li><a href=https://andydote.co.uk/tags/process/>process</a></li></ul><nav class=paginav><a class=prev href=https://andydote.co.uk/2018/02/20/task-chainging-pipeline-operator/><span class=title>« Prev Page</span><br><span>Task Chaining and the Pipeline Operator</span></a>
<a class=next href=https://andydote.co.uk/2017/11/17/evolutionary-development/><span class=title>Next Page »</span><br><span>Evolutionary Development</span></a></nav></footer></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>